Disassembly Listing for Lab9
Generated From:
C:/Users/kylez/CMPE13/Lab09/Lab9.X/dist/default/debug/Lab9.X.debug.elf
Jun 1, 2019 5:43:05 PM

---  c:/users/kylez/cmpe13/lab09/lab9.x/uart1.c  --------------------------------------------------------
1:                   #include "CircularBuffer.h"
2:                   #include "Uart1.h"
3:                   
4:                   //CMPE13 Support Library
5:                   #include "BOARD.h"
6:                   
7:                   #include <xc.h>
8:                   #include <sys/attribs.h>
9:                   
10:                  static CircularBuffer uart1RxBuffer;
11:                  static uint8_t u1RxBuf[1024];
12:                  static CircularBuffer uart1TxBuffer;
13:                  static uint8_t u1TxBuf[1024];
14:                  
15:                  /*
16:                   * Private functions.
17:                   */
18:                  void Uart1StartTransmission(void);
19:                  
20:                  /**
21:                   * Initialization function for the UART_USED peripheral.
22:                   * Should be called in initialization code for the
23:                   * model. This function configures the UART
24:                   * for whatever baud rate is specified. It also configures two circular buffers
25:                   * for transmission and reception.
26:                   */
27:                  void Uart1Init(uint32_t baudRate)
28:                  {
9D003B18  27BDFFE8   ADDIU SP, SP, -24
9D003B1C  AFBF0014   SW RA, 20(SP)
9D003B20  AFBE0010   SW FP, 16(SP)
9D003B24  03A0F021   ADDU FP, SP, ZERO
9D003B28  AFC40018   SW A0, 24(FP)
29:                      // First initialize the necessary circular buffers.
30:                      CB_Init(&uart1RxBuffer, u1RxBuf, sizeof (u1RxBuf));
9D003B2C  3C02A000   LUI V0, -24576
9D003B30  24440420   ADDIU A0, V0, 1056
9D003B34  3C02A000   LUI V0, -24576
9D003B38  24450430   ADDIU A1, V0, 1072
9D003B3C  24060400   ADDIU A2, ZERO, 1024
9D003B40  0F4005B8   JAL CB_Init
9D003B44  00000000   NOP
31:                      CB_Init(&uart1TxBuffer, u1TxBuf, sizeof (u1TxBuf));
9D003B48  3C02A000   LUI V0, -24576
9D003B4C  24440830   ADDIU A0, V0, 2096
9D003B50  3C02A000   LUI V0, -24576
9D003B54  24450840   ADDIU A1, V0, 2112
9D003B58  24060400   ADDIU A2, ZERO, 1024
9D003B5C  0F4005B8   JAL CB_Init
9D003B60  00000000   NOP
32:                  
33:                  #ifdef PIC32MX
34:                      //the next few lines below are redundant with actions performed in BOARD_Init():
35:                      U1MODEbits.ON = 1; //turn on UART
9D003B64  3C03BF80   LUI V1, -16512
9D003B68  94626000   LHU V0, 24576(V1)
9D003B6C  24040001   ADDIU A0, ZERO, 1
9D003B70  7C827BC4   INS V0, A0, 15, 1
9D003B74  A4626000   SH V0, 24576(V1)
36:                      U1STAbits.UTXEN = 1; //enable TX pin
9D003B78  3C03BF80   LUI V1, -16512
9D003B7C  8C626010   LW V0, 24592(V1)
9D003B80  24040001   ADDIU A0, ZERO, 1
9D003B84  7C825284   INS V0, A0, 10, 1
9D003B88  AC626010   SW V0, 24592(V1)
37:                      U1STAbits.URXEN = 1; //enable RX oun
9D003B8C  3C03BF80   LUI V1, -16512
9D003B90  8C626010   LW V0, 24592(V1)
9D003B94  24040001   ADDIU A0, ZERO, 1
9D003B98  7C826304   INS V0, A0, 12, 1
9D003B9C  AC626010   SW V0, 24592(V1)
38:                  
39:                      // The FIFO mode here for transmission is not set to `*_TX_BUFFER_EMPTY` as that seems to fail
40:                      // with some characters dropped. This method, waiting until transmission is finished, is
41:                      // technically slower, but works quite nicely.
42:                      
43:                      U1STAbits.UTXISEL = 0b01; //interrupt when transmission is complete
9D003BA0  3C03BF80   LUI V1, -16512
9D003BA4  8C626010   LW V0, 24592(V1)
9D003BA8  24040001   ADDIU A0, ZERO, 1
9D003BAC  7C827B84   INS V0, A0, 14, 2
9D003BB0  AC626010   SW V0, 24592(V1)
44:                      U1STAbits.URXISEL = 0b00; //interrupt when RX is not empty (has at least 1 character)
9D003BB4  3C03BF80   LUI V1, -16512
9D003BB8  8C626010   LW V0, 24592(V1)
9D003BBC  7C023984   INS V0, ZERO, 6, 2
9D003BC0  AC626010   SW V0, 24592(V1)
45:                  
46:                  
47:                      // Configure UART interrupt for both RX and TX
48:                      IEC0bits.U1RXIE = 1; //enable RX interrupt
9D003BC4  3C03BF88   LUI V1, -16504
9D003BC8  8C621060   LW V0, 4192(V1)
9D003BCC  24040001   ADDIU A0, ZERO, 1
9D003BD0  7C82DEC4   INS V0, A0, 27, 1
9D003BD4  AC621060   SW V0, 4192(V1)
49:                      IEC0bits.U1TXIE = 1; //enable TX interrupt
9D003BD8  3C03BF88   LUI V1, -16504
9D003BDC  8C621060   LW V0, 4192(V1)
9D003BE0  24040001   ADDIU A0, ZERO, 1
9D003BE4  7C82E704   INS V0, A0, 28, 1
9D003BE8  AC621060   SW V0, 4192(V1)
50:                      IPC6bits.U1IP = 6; //set UART interrupt priority to 6
9D003BEC  3C03BF88   LUI V1, -16504
9D003BF0  8C6210F0   LW V0, 4336(V1)
9D003BF4  24040006   ADDIU A0, ZERO, 6
9D003BF8  7C822084   INS V0, A0, 2, 3
9D003BFC  AC6210F0   SW V0, 4336(V1)
51:                      IPC6bits.U1IS = 0; //set interrupt subpriority to 0
9D003C00  3C03BF88   LUI V1, -16504
9D003C04  8C6210F0   LW V0, 4336(V1)
9D003C08  7C020804   INS V0, ZERO, 0, 2
9D003C0C  AC6210F0   SW V0, 4336(V1)
52:                  #endif
53:                  }
9D003C10  03C0E821   ADDU SP, FP, ZERO
9D003C14  8FBF0014   LW RA, 20(SP)
9D003C18  8FBE0010   LW FP, 16(SP)
9D003C1C  27BD0018   ADDIU SP, SP, 24
9D003C20  03E00008   JR RA
9D003C24  00000000   NOP
54:                  
55:                  void Uart1ChangeBaudRate(uint16_t brgRegister)
56:                  {
9D003C28  27BDFFF0   ADDIU SP, SP, -16
9D003C2C  AFBE000C   SW FP, 12(SP)
9D003C30  03A0F021   ADDU FP, SP, ZERO
9D003C34  00801021   ADDU V0, A0, ZERO
9D003C38  A7C20010   SH V0, 16(FP)
57:                      uint8_t utxen = U1STAbits.UTXEN;
9D003C3C  3C02BF80   LUI V0, -16512
9D003C40  8C426010   LW V0, 24592(V0)
9D003C44  7C420280   EXT V0, V0, 10, 1
9D003C48  304200FF   ANDI V0, V0, 255
9D003C4C  A3C20000   SB V0, 0(FP)
58:                  
59:                      // Disable the port;
60:                      U1MODEbits.UARTEN = 0;
9D003C50  3C03BF80   LUI V1, -16512
9D003C54  94626000   LHU V0, 24576(V1)
9D003C58  7C027BC4   INS V0, ZERO, 15, 1
9D003C5C  A4626000   SH V0, 24576(V1)
61:                  
62:                      // Change the BRG register to set the new baud rate
63:                      U1BRG = brgRegister;
9D003C60  97C30010   LHU V1, 16(FP)
9D003C64  3C02BF80   LUI V0, -16512
9D003C68  AC436040   SW V1, 24640(V0)
64:                  
65:                      // Enable the port restoring the previous transmission settings
66:                      U1MODEbits.UARTEN = 1;
9D003C6C  3C03BF80   LUI V1, -16512
9D003C70  94626000   LHU V0, 24576(V1)
9D003C74  24040001   ADDIU A0, ZERO, 1
9D003C78  7C827BC4   INS V0, A0, 15, 1
9D003C7C  A4626000   SH V0, 24576(V1)
67:                      U1STAbits.UTXEN = utxen;
9D003C80  93C20000   LBU V0, 0(FP)
9D003C84  30420001   ANDI V0, V0, 1
9D003C88  304400FF   ANDI A0, V0, 255
9D003C8C  3C03BF80   LUI V1, -16512
9D003C90  8C626010   LW V0, 24592(V1)
9D003C94  7C825284   INS V0, A0, 10, 1
9D003C98  AC626010   SW V0, 24592(V1)
68:                  }
9D003C9C  03C0E821   ADDU SP, FP, ZERO
9D003CA0  8FBE000C   LW FP, 12(SP)
9D003CA4  27BD0010   ADDIU SP, SP, 16
9D003CA8  03E00008   JR RA
9D003CAC  00000000   NOP
69:                  
70:                  uint8_t Uart1HasData(void)
71:                  {
9D003CB0  27BDFFF8   ADDIU SP, SP, -8
9D003CB4  AFBE0004   SW FP, 4(SP)
9D003CB8  03A0F021   ADDU FP, SP, ZERO
72:                      return (uart1RxBuffer.dataSize > 0);
9D003CBC  3C02A000   LUI V0, -24576
9D003CC0  24420420   ADDIU V0, V0, 1056
9D003CC4  94420006   LHU V0, 6(V0)
9D003CC8  0002102B   SLTU V0, ZERO, V0
9D003CCC  304200FF   ANDI V0, V0, 255
73:                  }
9D003CD0  03C0E821   ADDU SP, FP, ZERO
9D003CD4  8FBE0004   LW FP, 4(SP)
9D003CD8  27BD0008   ADDIU SP, SP, 8
9D003CDC  03E00008   JR RA
9D003CE0  00000000   NOP
74:                  
75:                  /**
76:                   * This function actually initiates transmission. It
77:                   * attempts to start transmission with the first element
78:                   * in the queue if transmission isn't already proceeding.
79:                   * Once transmission starts the interrupt handler will
80:                   * keep things moving from there. The buffer is checked
81:                   * for new data and the transmission buffer is checked that
82:                   * it has room for new data before attempting to transmit.
83:                   */
84:                  void Uart1StartTransmission(void)
85:                  {
9D003CE4  27BDFFE0   ADDIU SP, SP, -32
9D003CE8  AFBF001C   SW RA, 28(SP)
9D003CEC  AFBE0018   SW FP, 24(SP)
9D003CF0  03A0F021   ADDU FP, SP, ZERO
86:                      while (uart1TxBuffer.dataSize > 0 && !U1STAbits.UTXBF) {
9D003CF4  0B400F49   J .LBE2
9D003CF8  00000000   NOP
9D003D24  3C02A000   LUI V0, -24576
9D003D28  24420830   ADDIU V0, V0, 2096
9D003D2C  94420006   LHU V0, 6(V0)
9D003D30  10400006   BEQ V0, ZERO, 0x9D003D4C
9D003D34  00000000   NOP
9D003D38  3C02BF80   LUI V0, -16512
9D003D3C  8C426010   LW V0, 24592(V0)
9D003D40  30420200   ANDI V0, V0, 512
9D003D44  1040FFED   BEQ V0, ZERO, .LBB2
9D003D48  00000000   NOP
87:                          // A temporary variable is used here because writing directly into U1TXREG causes some weird issues.
88:                          uint8_t c;
89:                          CB_ReadByte(&uart1TxBuffer, &c);
9D003CFC  3C02A000   LUI V0, -24576
9D003D00  24440830   ADDIU A0, V0, 2096
9D003D04  27C20010   ADDIU V0, FP, 16
9D003D08  00402821   ADDU A1, V0, ZERO
9D003D0C  0F4005F3   JAL CB_ReadByte
9D003D10  00000000   NOP
90:                          U1TXREG = c;
9D003D14  93C20010   LBU V0, 16(FP)
9D003D18  00401821   ADDU V1, V0, ZERO
9D003D1C  3C02BF80   LUI V0, -16512
9D003D20  AC436020   SW V1, 24608(V0)
91:                      }
92:                  }
9D003D4C  03C0E821   ADDU SP, FP, ZERO
9D003D50  8FBF001C   LW RA, 28(SP)
9D003D54  8FBE0018   LW FP, 24(SP)
9D003D58  27BD0020   ADDIU SP, SP, 32
9D003D5C  03E00008   JR RA
9D003D60  00000000   NOP
93:                  
94:                  int Uart1ReadByte(uint8_t *datum)
95:                  {
9D003D64  27BDFFE8   ADDIU SP, SP, -24
9D003D68  AFBF0014   SW RA, 20(SP)
9D003D6C  AFBE0010   SW FP, 16(SP)
9D003D70  03A0F021   ADDU FP, SP, ZERO
9D003D74  AFC40018   SW A0, 24(FP)
96:                      return CB_ReadByte(&uart1RxBuffer, datum);
9D003D78  3C02A000   LUI V0, -24576
9D003D7C  24440420   ADDIU A0, V0, 1056
9D003D80  8FC50018   LW A1, 24(FP)
9D003D84  0F4005F3   JAL CB_ReadByte
9D003D88  00000000   NOP
97:                  }
9D003D8C  03C0E821   ADDU SP, FP, ZERO
9D003D90  8FBF0014   LW RA, 20(SP)
9D003D94  8FBE0010   LW FP, 16(SP)
9D003D98  27BD0018   ADDIU SP, SP, 24
9D003D9C  03E00008   JR RA
9D003DA0  00000000   NOP
98:                  
99:                  /**
100:                  * This function supplements the uart1EnqueueData() function by also
101:                  * providing an interface that only enqueues a single byte.
102:                  */
103:                 void Uart1WriteByte(uint8_t datum)
104:                 {
9D003DA4  27BDFFE8   ADDIU SP, SP, -24
9D003DA8  AFBF0014   SW RA, 20(SP)
9D003DAC  AFBE0010   SW FP, 16(SP)
9D003DB0  03A0F021   ADDU FP, SP, ZERO
9D003DB4  00801021   ADDU V0, A0, ZERO
9D003DB8  A3C20018   SB V0, 24(FP)
105:                     CB_WriteByte(&uart1TxBuffer, datum);
9D003DBC  93C20018   LBU V0, 24(FP)
9D003DC0  3C03A000   LUI V1, -24576
9D003DC4  24640830   ADDIU A0, V1, 2096
9D003DC8  00402821   ADDU A1, V0, ZERO
9D003DCC  0F40068E   JAL CB_WriteByte
9D003DD0  00000000   NOP
106:                     Uart1StartTransmission();
9D003DD4  0F400F39   JAL Uart1StartTransmission
9D003DD8  00000000   NOP
107:                 }
9D003DDC  03C0E821   ADDU SP, FP, ZERO
9D003DE0  8FBF0014   LW RA, 20(SP)
9D003DE4  8FBE0010   LW FP, 16(SP)
9D003DE8  27BD0018   ADDIU SP, SP, 24
9D003DEC  03E00008   JR RA
9D003DF0  00000000   NOP
108:                 
109:                 /**
110:                  * This function enqueues all bytes in the passed data character array according to the passed
111:                  * length.
112:                  */
113:                 int Uart1WriteData(const void *data, size_t length)
114:                 {
9D003DF4  27BDFFE0   ADDIU SP, SP, -32
9D003DF8  AFBF001C   SW RA, 28(SP)
9D003DFC  AFBE0018   SW FP, 24(SP)
9D003E00  03A0F021   ADDU FP, SP, ZERO
9D003E04  AFC40020   SW A0, 32(FP)
9D003E08  AFC50024   SW A1, 36(FP)
115:                     int success = CB_WriteMany(&uart1TxBuffer, data, length, FALSE);
9D003E0C  8FC20024   LW V0, 36(FP)
9D003E10  3042FFFF   ANDI V0, V0, -1
9D003E14  3C03A000   LUI V1, -24576
9D003E18  24640830   ADDIU A0, V1, 2096
9D003E1C  8FC50020   LW A1, 32(FP)
9D003E20  00403021   ADDU A2, V0, ZERO
9D003E24  00003821   ADDU A3, ZERO, ZERO
9D003E28  0F4006CE   JAL CB_WriteMany
9D003E2C  00000000   NOP
9D003E30  AFC20010   SW V0, 16(FP)
116:                 
117:                     Uart1StartTransmission();
9D003E34  0F400F39   JAL Uart1StartTransmission
9D003E38  00000000   NOP
118:                 
119:                     return success;
9D003E3C  8FC20010   LW V0, 16(FP)
120:                 }
9D003E40  03C0E821   ADDU SP, FP, ZERO
9D003E44  8FBF001C   LW RA, 28(SP)
9D003E48  8FBE0018   LW FP, 24(SP)
9D003E4C  27BD0020   ADDIU SP, SP, 32
9D003E50  03E00008   JR RA
9D003E54  00000000   NOP
121:                 
122:                 #ifdef PIC32MX
123:                 
124:                 void __ISR(_UART_1_VECTOR, ipl6auto) Uart1Interrupt(void)
125:                 {
9D003E58  415DE800   RDPGPR SP, SP
9D003E5C  401B7000   MFC0 K1, EPC
9D003E60  401A6002   MFC0 K0, SRSCtl
9D003E64  27BDFF88   ADDIU SP, SP, -120
9D003E68  AFBB0074   SW K1, 116(SP)
9D003E6C  401B6000   MFC0 K1, Status
9D003E70  AFBA006C   SW K0, 108(SP)
9D003E74  AFBB0070   SW K1, 112(SP)
9D003E78  7C1B7844   INS K1, ZERO, 1, 15
9D003E7C  377B1800   ORI K1, K1, 6144
9D003E80  409B6000   MTC0 K1, Status
9D003E84  AFA3001C   SW V1, 28(SP)
9D003E88  AFA20018   SW V0, 24(SP)
9D003E8C  8FA3006C   LW V1, 108(SP)
9D003E90  3063000F   ANDI V1, V1, 15
9D003E94  14600012   BNE V1, ZERO, 0x9D003EE0
9D003E98  00000000   NOP
9D003E9C  AFBF005C   SW RA, 92(SP)
9D003EA0  AFBE0058   SW FP, 88(SP)
9D003EA4  AFB90054   SW T9, 84(SP)
9D003EA8  AFB80050   SW T8, 80(SP)
9D003EAC  AFAF004C   SW T7, 76(SP)
9D003EB0  AFAE0048   SW T6, 72(SP)
9D003EB4  AFAD0044   SW T5, 68(SP)
9D003EB8  AFAC0040   SW T4, 64(SP)
9D003EBC  AFAB003C   SW T3, 60(SP)
9D003EC0  AFAA0038   SW T2, 56(SP)
9D003EC4  AFA90034   SW T1, 52(SP)
9D003EC8  AFA80030   SW T0, 48(SP)
9D003ECC  AFA7002C   SW A3, 44(SP)
9D003ED0  AFA60028   SW A2, 40(SP)
9D003ED4  AFA50024   SW A1, 36(SP)
9D003ED8  AFA40020   SW A0, 32(SP)
9D003EDC  AFA10014   SW AT, 20(SP)
9D003EE0  00000000   NOP
9D003EE4  00001012   MFLO V0
9D003EE8  AFA20064   SW V0, 100(SP)
9D003EEC  00001810   MFHI V1
9D003EF0  AFA30060   SW V1, 96(SP)
9D003EF4  03A0F021   ADDU FP, SP, ZERO
126:                     // if receive flag is set, handle received character input
127:                     if (IFS0bits.U1RXIF) {
9D003EF8  3C02BF88   LUI V0, -16504
9D003EFC  8C431030   LW V1, 4144(V0)
9D003F00  3C020800   LUI V0, 2048
9D003F04  00621024   AND V0, V1, V0
9D003F08  1040001D   BEQ V0, ZERO, 0x9D003F80
9D003F0C  00000000   NOP
128:                         // Keep receiving new bytes while the buffer has data.
129:                         while (U1STAbits.URXDA == 1) {
9D003F10  0B400FCE   J .LVL29
9D003F14  00000000   NOP
9D003F38  3C02BF80   LUI V0, -16512
9D003F3C  8C426010   LW V0, 24592(V0)
9D003F40  30420001   ANDI V0, V0, 1
9D003F44  1440FFF4   BNE V0, ZERO, 0x9D003F18
9D003F48  00000000   NOP
130:                             CB_WriteByte(&uart1RxBuffer, (uint8_t) U1RXREG);
9D003F18  3C02BF80   LUI V0, -16512
9D003F1C  8C426030   LW V0, 24624(V0)
9D003F20  304200FF   ANDI V0, V0, 255
9D003F24  3C03A000   LUI V1, -24576
9D003F28  24640420   ADDIU A0, V1, 1056
9D003F2C  00402821   ADDU A1, V0, ZERO
9D003F30  0F40068E   JAL CB_WriteByte
9D003F34  00000000   NOP
131:                         }
132:                 
133:                         // Clear buffer overflow bit if triggered
134:                         if (U1STAbits.OERR == 1) {
9D003F4C  3C02BF80   LUI V0, -16512
9D003F50  8C426010   LW V0, 24592(V0)
9D003F54  30420002   ANDI V0, V0, 2
9D003F58  10400005   BEQ V0, ZERO, 0x9D003F70
9D003F5C  00000000   NOP
135:                             U1STAbits.OERR = 0;
9D003F60  3C03BF80   LUI V1, -16512
9D003F64  8C626010   LW V0, 24592(V1)
9D003F68  7C020844   INS V0, ZERO, 1, 1
9D003F6C  AC626010   SW V0, 24592(V1)
136:                         }
137:                 
138:                         // Clear the interrupt flag
139:                         IFS0bits.U1RXIF = 0;
9D003F70  3C03BF88   LUI V1, -16504
9D003F74  8C621030   LW V0, 4144(V1)
9D003F78  7C02DEC4   INS V0, ZERO, 27, 1
9D003F7C  AC621030   SW V0, 4144(V1)
140:                     }
141:                 
142:                     // Handle transmission interrupt
143:                     if (IFS0bits.U1TXIF) {
9D003F80  3C02BF88   LUI V0, -16504
9D003F84  8C431030   LW V1, 4144(V0)
9D003F88  3C021000   LUI V0, 4096
9D003F8C  00621024   AND V0, V1, V0
9D003F90  10400007   BEQ V0, ZERO, 0x9D003FB0
9D003F94  00000000   NOP
144:                         Uart1StartTransmission();
9D003F98  0F400F39   JAL Uart1StartTransmission
9D003F9C  00000000   NOP
145:                 
146:                         // Clear the interrupt flag
147:                         IFS0bits.U1TXIF = 0;
9D003FA0  3C03BF88   LUI V1, -16504
9D003FA4  8C621030   LW V0, 4144(V1)
9D003FA8  7C02E704   INS V0, ZERO, 28, 1
9D003FAC  AC621030   SW V0, 4144(V1)
148:                     }
149:                 }
9D003FB0  03C0E821   ADDU SP, FP, ZERO
150:                 #endif
---  c:/users/kylez/cmpe13/lab09/lab9.x/oleddriver.c  ---------------------------------------------------
1:                   #include <stdint.h>
2:                   
3:                   //CMPE13 Support Library
4:                   #include "BOARD.h"
5:                   
6:                   #include <xc.h>
7:                   
8:                   
9:                   #include "OledDriver.h"
10:                  
11:                  #define SPI_CHANNEL SPI_CHANNEL2
12:                  
13:                  /**
14:                   * Constants for the various command values that can be sent to the OLED driver.
15:                   */
16:                  typedef enum {
17:                      OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0 = 0x00,
18:                      OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0 = 0x10,
19:                      OLED_COMMAND_SET_PAGE = 0x22,
20:                      OLED_COMMAND_SET_CHARGE_PUMP = 0x8D,
21:                      OLED_COMMAND_SET_SEGMENT_REMAP = 0xA1,
22:                      OLED_COMMAND_DISPLAY_NORMAL = 0xA6,
23:                      OLED_COMMAND_DISPLAY_INVERTED = 0xA7,
24:                      OLED_COMMAND_DISPLAY_OFF = 0xAE,
25:                      OLED_COMMAND_DISPLAY_ON = 0xAF,
26:                      OLED_COMMAND_SET_PRECHARGE_PERIOD = 0xD9,
27:                      OLED_COMMAND_SET_COM_PINS_CONFIG = 0xDA
28:                  } OledCommand;
29:                  
30:                  /**
31:                   * Store constants for all settings used with the OLED driver.
32:                   */
33:                  typedef enum {
34:                      OLED_SETTING_ENABLE_CHARGE_PUMP = 0x14,
35:                      OLED_SETTING_MAXIMUM_PRECHARGE = 0xF1,
36:                      OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED = 0x20,
37:                      OLED_SETTING_REVERSE_ROW_ORDERING = 0xC8
38:                  } OledSetting;
39:                  
40:                  #define OLED_DRIVER_PAGES 4
41:                  
42:                  /**
43:                   * This array is the off-screen frame buffer used for rendering.
44:                   * It isn't possible to read back from the OLED display device,
45:                   * so display data is rendered into this off-screen buffer and then
46:                   * copied to the display.
47:                   * @note Any time this is updated, An `OledDriverUpdateDisplay()` call must be performed.
48:                   */
49:                  uint8_t rgbOledBmp[OLED_DRIVER_BUFFER_SIZE];
50:                  
51:                  // Function prototypes for internal-use functions.
52:                  void OledPutBuffer(int size, uint8_t *buffer);
53:                  uint8_t Spi2Put(uint8_t bVal);
54:                  void DelayMs(unsigned int msec);
55:                  
56:                  /**
57:                   * Initialize the PIC32MX to communicate with the UG-23832HSWEG04 OLED display through the SSD1306
58:                   * display controller.
59:                   */
60:                  void OledHostInit(void)
61:                  {
9D003558  27BDFFF0   ADDIU SP, SP, -16
9D00355C  AFBE000C   SW FP, 12(SP)
9D003560  03A0F021   ADDU FP, SP, ZERO
62:                      // Open SPI2 as a master in 1-byte mode running at 10MHz.
63:                      // The peripheral bus is running at 10Mhz, and we want a 10MHz SPI bus clock.
64:                      int pbClkDiv = 20000000 / 10000000;
9D003564  24020002   ADDIU V0, ZERO, 2
9D003568  AFC20000   SW V0, 0(FP)
65:                      SPI2CON = 0; // reset and clear the SPI config register
9D00356C  3C02BF80   LUI V0, -16512
9D003570  AC405A00   SW ZERO, 23040(V0)
66:                      SPI2CONbits.MSTEN = 1; // We are a Master
9D003574  3C03BF80   LUI V1, -16512
9D003578  8C625A00   LW V0, 23040(V1)
9D00357C  24040001   ADDIU A0, ZERO, 1
9D003580  7C822944   INS V0, A0, 5, 1
9D003584  AC625A00   SW V0, 23040(V1)
67:                      SPI2CONbits.CKP = 1; // Idle is high level
9D003588  3C03BF80   LUI V1, -16512
9D00358C  8C625A00   LW V0, 23040(V1)
9D003590  24040001   ADDIU A0, ZERO, 1
9D003594  7C823184   INS V0, A0, 6, 1
9D003598  AC625A00   SW V0, 23040(V1)
68:                      SPI2BRG = (pbClkDiv >> 1) - 1; // set the baud rate to the correct setting.
9D00359C  8FC20000   LW V0, 0(FP)
9D0035A0  00021043   SRA V0, V0, 1
9D0035A4  2442FFFF   ADDIU V0, V0, -1
9D0035A8  00401821   ADDU V1, V0, ZERO
9D0035AC  3C02BF80   LUI V0, -16512
9D0035B0  AC435A30   SW V1, 23088(V0)
69:                      SPI2CONbits.ON = 1; // turn it on
9D0035B4  3C03BF80   LUI V1, -16512
9D0035B8  8C625A00   LW V0, 23040(V1)
9D0035BC  24040001   ADDIU A0, ZERO, 1
9D0035C0  7C827BC4   INS V0, A0, 15, 1
9D0035C4  AC625A00   SW V0, 23040(V1)
70:                  
71:                  
72:                      // Set RF4-6 as digital outputs for controlling data/command selection, logic power, and display
73:                      // power. They're all initialized high beforehand, because that disables power.
74:                      OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
9D0035C8  3C03BF88   LUI V1, -16504
9D0035CC  90626150   LBU V0, 24912(V1)
9D0035D0  24040001   ADDIU A0, ZERO, 1
9D0035D4  7C823184   INS V0, A0, 6, 1
9D0035D8  A0626150   SB V0, 24912(V1)
75:                      OLED_DRIVER_OLED_POWER_PORT = 1;
9D0035DC  3C03BF88   LUI V1, -16504
9D0035E0  90626150   LBU V0, 24912(V1)
9D0035E4  24040001   ADDIU A0, ZERO, 1
9D0035E8  7C822944   INS V0, A0, 5, 1
9D0035EC  A0626150   SB V0, 24912(V1)
76:                      OLED_DRIVER_MODE_PORT = 1;
9D0035F0  3C03BF88   LUI V1, -16504
9D0035F4  90626150   LBU V0, 24912(V1)
9D0035F8  24040001   ADDIU A0, ZERO, 1
9D0035FC  7C822104   INS V0, A0, 4, 1
9D003600  A0626150   SB V0, 24912(V1)
77:                  
78:                      OLED_DRIVER_MODE_TRIS = 0;
9D003604  3C03BF88   LUI V1, -16504
9D003608  90626140   LBU V0, 24896(V1)
9D00360C  7C022104   INS V0, ZERO, 4, 1
9D003610  A0626140   SB V0, 24896(V1)
79:                      OLED_DRIVER_CONTROLLER_POWER_TRIS = 0;
9D003614  3C03BF88   LUI V1, -16504
9D003618  90626140   LBU V0, 24896(V1)
9D00361C  7C023184   INS V0, ZERO, 6, 1
9D003620  A0626140   SB V0, 24896(V1)
80:                      OLED_DRIVER_OLED_POWER_TRIS = 0;
9D003624  3C03BF88   LUI V1, -16504
9D003628  90626140   LBU V0, 24896(V1)
9D00362C  7C022944   INS V0, ZERO, 5, 1
9D003630  A0626140   SB V0, 24896(V1)
81:                  
82:                      // Set RG9 as a digital output, tied to the reset pin on the SG1306 controller, low => reset.
83:                      OLED_DRIVER_RESET_PORT = 1;
9D003634  3C03BF88   LUI V1, -16504
9D003638  94626190   LHU V0, 24976(V1)
9D00363C  24040001   ADDIU A0, ZERO, 1
9D003640  7C824A44   INS V0, A0, 9, 1
9D003644  A4626190   SH V0, 24976(V1)
84:                      OLED_DRIVER_RESET_TRIS = 0;
9D003648  3C03BF88   LUI V1, -16504
9D00364C  94626180   LHU V0, 24960(V1)
9D003650  7C024A44   INS V0, ZERO, 9, 1
9D003654  A4626180   SH V0, 24960(V1)
85:                  }
9D003658  03C0E821   ADDU SP, FP, ZERO
9D00365C  8FBE000C   LW FP, 12(SP)
9D003660  27BD0010   ADDIU SP, SP, 16
9D003664  03E00008   JR RA
9D003668  00000000   NOP
86:                  
87:                  /**
88:                   * Initialize the OLED display and driver circuitry.
89:                   */
90:                  void OledDriverInitDisplay(void)
91:                  {
9D00366C  27BDFFE8   ADDIU SP, SP, -24
9D003670  AFBF0014   SW RA, 20(SP)
9D003674  AFBE0010   SW FP, 16(SP)
9D003678  03A0F021   ADDU FP, SP, ZERO
92:                      // Set the OLED into command mode.
93:                      OLED_DRIVER_MODE_PORT = 0;
9D00367C  3C03BF88   LUI V1, -16504
9D003680  90626150   LBU V0, 24912(V1)
9D003684  7C022104   INS V0, ZERO, 4, 1
9D003688  A0626150   SB V0, 24912(V1)
94:                  
95:                      // Power on the display logic, waiting 1ms for it to start up.
96:                      OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
9D00368C  3C03BF88   LUI V1, -16504
9D003690  90626150   LBU V0, 24912(V1)
9D003694  7C023184   INS V0, ZERO, 6, 1
9D003698  A0626150   SB V0, 24912(V1)
97:                      DelayMs(1);
9D00369C  24040001   ADDIU A0, ZERO, 1
9D0036A0  0F400EA3   JAL DelayMs
9D0036A4  00000000   NOP
98:                  
99:                      // Turn off the display.
100:                     Spi2Put(OLED_COMMAND_DISPLAY_OFF);
9D0036A8  240400AE   ADDIU A0, ZERO, 174
9D0036AC  0F400E86   JAL Spi2Put
9D0036B0  00000000   NOP
101:                 
102:                     // Toggle the reset pin.
103:                     OLED_DRIVER_RESET_PORT = 0;
9D0036B4  3C03BF88   LUI V1, -16504
9D0036B8  94626190   LHU V0, 24976(V1)
9D0036BC  7C024A44   INS V0, ZERO, 9, 1
9D0036C0  A4626190   SH V0, 24976(V1)
104:                     DelayMs(1);
9D0036C4  24040001   ADDIU A0, ZERO, 1
9D0036C8  0F400EA3   JAL DelayMs
9D0036CC  00000000   NOP
105:                     OLED_DRIVER_RESET_PORT = 1;
9D0036D0  3C03BF88   LUI V1, -16504
9D0036D4  94626190   LHU V0, 24976(V1)
9D0036D8  24040001   ADDIU A0, ZERO, 1
9D0036DC  7C824A44   INS V0, A0, 9, 1
9D0036E0  A4626190   SH V0, 24976(V1)
106:                 
107:                     // Enable the charge pump and
108:                     Spi2Put(OLED_COMMAND_SET_CHARGE_PUMP);
9D0036E4  2404008D   ADDIU A0, ZERO, 141
9D0036E8  0F400E86   JAL Spi2Put
9D0036EC  00000000   NOP
109:                     Spi2Put(OLED_SETTING_ENABLE_CHARGE_PUMP);
9D0036F0  24040014   ADDIU A0, ZERO, 20
9D0036F4  0F400E86   JAL Spi2Put
9D0036F8  00000000   NOP
110:                     Spi2Put(OLED_COMMAND_SET_PRECHARGE_PERIOD);
9D0036FC  240400D9   ADDIU A0, ZERO, 217
9D003700  0F400E86   JAL Spi2Put
9D003704  00000000   NOP
111:                     Spi2Put(OLED_SETTING_MAXIMUM_PRECHARGE);
9D003708  240400F1   ADDIU A0, ZERO, 241
9D00370C  0F400E86   JAL Spi2Put
9D003710  00000000   NOP
112:                 
113:                     // Power on the display, giving it 100ms to start up.
114:                     OLED_DRIVER_OLED_POWER_PORT = 0;
9D003714  3C03BF88   LUI V1, -16504
9D003718  90626150   LBU V0, 24912(V1)
9D00371C  7C022944   INS V0, ZERO, 5, 1
9D003720  A0626150   SB V0, 24912(V1)
115:                 
116:                     DelayMs(100);
9D003724  24040064   ADDIU A0, ZERO, 100
9D003728  0F400EA3   JAL DelayMs
9D00372C  00000000   NOP
117:                 
118:                     // Invert row numbering so that (0,0) is upper-right.
119:                     Spi2Put(OLED_COMMAND_SET_SEGMENT_REMAP);
9D003730  240400A1   ADDIU A0, ZERO, 161
9D003734  0F400E86   JAL Spi2Put
9D003738  00000000   NOP
120:                     Spi2Put(OLED_SETTING_REVERSE_ROW_ORDERING);
9D00373C  240400C8   ADDIU A0, ZERO, 200
9D003740  0F400E86   JAL Spi2Put
9D003744  00000000   NOP
121:                 
122:                     // Set sequential COM configuration with non-interleaved memory.
123:                     Spi2Put(OLED_COMMAND_SET_COM_PINS_CONFIG);
9D003748  240400DA   ADDIU A0, ZERO, 218
9D00374C  0F400E86   JAL Spi2Put
9D003750  00000000   NOP
124:                     Spi2Put(OLED_SETTING_SEQUENTIAL_COM_NON_INTERLEAVED);
9D003754  24040020   ADDIU A0, ZERO, 32
9D003758  0F400E86   JAL Spi2Put
9D00375C  00000000   NOP
125:                 
126:                     // And turn on the display.
127:                     Spi2Put(OLED_COMMAND_DISPLAY_ON);
9D003760  240400AF   ADDIU A0, ZERO, 175
9D003764  0F400E86   JAL Spi2Put
9D003768  00000000   NOP
128:                 }
9D00376C  03C0E821   ADDU SP, FP, ZERO
9D003770  8FBF0014   LW RA, 20(SP)
9D003774  8FBE0010   LW FP, 16(SP)
9D003778  27BD0018   ADDIU SP, SP, 24
9D00377C  03E00008   JR RA
9D003780  00000000   NOP
129:                 
130:                 /**
131:                  * Set the LCD to display pixel values as the opposite of how they are actually stored in NVRAM. So
132:                  * pixels set to black (0) will display as white, and pixels set to white (1) will display as black.
133:                  */
134:                 void OledDriverSetDisplayInverted(void)
135:                 {
9D003784  27BDFFE8   ADDIU SP, SP, -24
9D003788  AFBF0014   SW RA, 20(SP)
9D00378C  AFBE0010   SW FP, 16(SP)
9D003790  03A0F021   ADDU FP, SP, ZERO
136:                     // Set the OLED into command mode.
137:                     OLED_DRIVER_MODE_PORT = 0;
9D003794  3C03BF88   LUI V1, -16504
9D003798  90626150   LBU V0, 24912(V1)
9D00379C  7C022104   INS V0, ZERO, 4, 1
9D0037A0  A0626150   SB V0, 24912(V1)
138:                 
139:                     Spi2Put(OLED_COMMAND_DISPLAY_INVERTED);
9D0037A4  240400A7   ADDIU A0, ZERO, 167
9D0037A8  0F400E86   JAL Spi2Put
9D0037AC  00000000   NOP
140:                 }
9D0037B0  03C0E821   ADDU SP, FP, ZERO
9D0037B4  8FBF0014   LW RA, 20(SP)
9D0037B8  8FBE0010   LW FP, 16(SP)
9D0037BC  27BD0018   ADDIU SP, SP, 24
9D0037C0  03E00008   JR RA
9D0037C4  00000000   NOP
141:                 
142:                 /**
143:                  * Set the LCD to display pixel values normally, where a 1 indicates white and a 0 indicates black.
144:                  * This is the default operating mode of the LCD and the mode it starts up in.
145:                  */
146:                 void OledDriverSetDisplayNormal(void)
147:                 {
9D0037C8  27BDFFE8   ADDIU SP, SP, -24
9D0037CC  AFBF0014   SW RA, 20(SP)
9D0037D0  AFBE0010   SW FP, 16(SP)
9D0037D4  03A0F021   ADDU FP, SP, ZERO
148:                     // Set the OLED into command mode.
149:                     OLED_DRIVER_MODE_PORT = 0;
9D0037D8  3C03BF88   LUI V1, -16504
9D0037DC  90626150   LBU V0, 24912(V1)
9D0037E0  7C022104   INS V0, ZERO, 4, 1
9D0037E4  A0626150   SB V0, 24912(V1)
150:                 
151:                     Spi2Put(OLED_COMMAND_DISPLAY_NORMAL);
9D0037E8  240400A6   ADDIU A0, ZERO, 166
9D0037EC  0F400E86   JAL Spi2Put
9D0037F0  00000000   NOP
152:                 }
9D0037F4  03C0E821   ADDU SP, FP, ZERO
9D0037F8  8FBF0014   LW RA, 20(SP)
9D0037FC  8FBE0010   LW FP, 16(SP)
9D003800  27BD0018   ADDIU SP, SP, 24
9D003804  03E00008   JR RA
9D003808  00000000   NOP
153:                 
154:                 /**
155:                  * Disable the Oled display before power-off. This means powering it up, sending the display off
156:                  * command, and finally disabling Vbat.
157:                  */
158:                 void OledDriverDisableDisplay(void)
159:                 {
9D00380C  27BDFFE8   ADDIU SP, SP, -24
9D003810  AFBF0014   SW RA, 20(SP)
9D003814  AFBE0010   SW FP, 16(SP)
9D003818  03A0F021   ADDU FP, SP, ZERO
160:                     // Set the OLED into command mode.
161:                     OLED_DRIVER_MODE_PORT = 0;
9D00381C  3C03BF88   LUI V1, -16504
9D003820  90626150   LBU V0, 24912(V1)
9D003824  7C022104   INS V0, ZERO, 4, 1
9D003828  A0626150   SB V0, 24912(V1)
162:                 
163:                     // Power on the OLED display logic, waiting for 1ms for it to start up.
164:                     OLED_DRIVER_CONTROLLER_POWER_PORT = 0;
9D00382C  3C03BF88   LUI V1, -16504
9D003830  90626150   LBU V0, 24912(V1)
9D003834  7C023184   INS V0, ZERO, 6, 1
9D003838  A0626150   SB V0, 24912(V1)
165:                     DelayMs(1);
9D00383C  24040001   ADDIU A0, ZERO, 1
9D003840  0F400EA3   JAL DelayMs
9D003844  00000000   NOP
166:                 
167:                     // Send the display off command.
168:                     Spi2Put(OLED_COMMAND_DISPLAY_OFF);
9D003848  240400AE   ADDIU A0, ZERO, 174
9D00384C  0F400E86   JAL Spi2Put
9D003850  00000000   NOP
169:                 
170:                     // And finally power off the display, giving it 100ms to do so.
171:                     OLED_DRIVER_CONTROLLER_POWER_PORT = 1;
9D003854  3C03BF88   LUI V1, -16504
9D003858  90626150   LBU V0, 24912(V1)
9D00385C  24040001   ADDIU A0, ZERO, 1
9D003860  7C823184   INS V0, A0, 6, 1
9D003864  A0626150   SB V0, 24912(V1)
172:                     DelayMs(100);
9D003868  24040064   ADDIU A0, ZERO, 100
9D00386C  0F400EA3   JAL DelayMs
9D003870  00000000   NOP
173:                 }
9D003874  03C0E821   ADDU SP, FP, ZERO
9D003878  8FBF0014   LW RA, 20(SP)
9D00387C  8FBE0010   LW FP, 16(SP)
9D003880  27BD0018   ADDIU SP, SP, 24
9D003884  03E00008   JR RA
9D003888  00000000   NOP
174:                 
175:                 /**
176:                  * Update the display with the contents of rgb0ledBmp.
177:                  */
178:                 void OledDriverUpdateDisplay(void)
179:                 {
9D00388C  27BDFFE0   ADDIU SP, SP, -32
9D003890  AFBF001C   SW RA, 28(SP)
9D003894  AFBE0018   SW FP, 24(SP)
9D003898  03A0F021   ADDU FP, SP, ZERO
180:                     uint8_t *pb = rgbOledBmp;
9D00389C  3C02A000   LUI V0, -24576
9D0038A0  24420220   ADDIU V0, V0, 544
9D0038A4  AFC20010   SW V0, 16(FP)
181:                     int page;
182:                     for (page = 0; page < OLED_DRIVER_PAGES; page++) {
9D0038A8  AFC00014   SW ZERO, 20(FP)
9D0038AC  0B400E4E   J 0x9D003938
9D0038B0  00000000   NOP
9D00392C  8FC20014   LW V0, 20(FP)
9D003930  24420001   ADDIU V0, V0, 1
9D003934  AFC20014   SW V0, 20(FP)
9D003938  8FC20014   LW V0, 20(FP)
9D00393C  28420004   SLTI V0, V0, 4
9D003940  1440FFDC   BNE V0, ZERO, 0x9D0038B4
9D003944  00000000   NOP
183:                         // Set the LCD into command mode.
184:                         //        PORTClearBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
185:                         OLED_DRIVER_MODE_PORT = 0;
9D0038B4  3C03BF88   LUI V1, -16504
9D0038B8  90626150   LBU V0, 24912(V1)
9D0038BC  7C022104   INS V0, ZERO, 4, 1
9D0038C0  A0626150   SB V0, 24912(V1)
186:                 
187:                         // Set the desired page.
188:                         Spi2Put(OLED_COMMAND_SET_PAGE);
9D0038C4  24040022   ADDIU A0, ZERO, 34
9D0038C8  0F400E86   JAL Spi2Put
9D0038CC  00000000   NOP
189:                         Spi2Put(page);
9D0038D0  8FC20014   LW V0, 20(FP)
9D0038D4  304200FF   ANDI V0, V0, 255
9D0038D8  00402021   ADDU A0, V0, ZERO
9D0038DC  0F400E86   JAL Spi2Put
9D0038E0  00000000   NOP
190:                 
191:                         // Set the starting column back to the origin.
192:                         Spi2Put(OLED_COMMAND_SET_DISPLAY_LOWER_COLUMN_0);
9D0038E4  00002021   ADDU A0, ZERO, ZERO
9D0038E8  0F400E86   JAL Spi2Put
9D0038EC  00000000   NOP
193:                         Spi2Put(OLED_COMMAND_SET_DISPLAY_UPPER_COLUMN_0);
9D0038F0  24040010   ADDIU A0, ZERO, 16
9D0038F4  0F400E86   JAL Spi2Put
9D0038F8  00000000   NOP
194:                 
195:                         // Return the LCD to data mode.
196:                         //        PORTSetBits(OLED_DRIVER_MODE_PORT, OLED_DRIVER_MODE_BIT);
197:                         OLED_DRIVER_MODE_PORT = 1;
9D0038FC  3C03BF88   LUI V1, -16504
9D003900  90626150   LBU V0, 24912(V1)
9D003904  24040001   ADDIU A0, ZERO, 1
9D003908  7C822104   INS V0, A0, 4, 1
9D00390C  A0626150   SB V0, 24912(V1)
198:                 
199:                         // Finally write this entire column to the OLED.
200:                         //		SpiChnPutS()
201:                         OledPutBuffer(OLED_DRIVER_PIXEL_COLUMNS, pb);
9D003910  24040080   ADDIU A0, ZERO, 128
9D003914  8FC50010   LW A1, 16(FP)
9D003918  0F400E58   JAL OledPutBuffer
9D00391C  00000000   NOP
202:                         pb += OLED_DRIVER_PIXEL_COLUMNS;
9D003920  8FC20010   LW V0, 16(FP)
9D003924  24420080   ADDIU V0, V0, 128
9D003928  AFC20010   SW V0, 16(FP)
203:                     }
204:                 }
9D003948  03C0E821   ADDU SP, FP, ZERO
9D00394C  8FBF001C   LW RA, 28(SP)
9D003950  8FBE0018   LW FP, 24(SP)
9D003954  27BD0020   ADDIU SP, SP, 32
9D003958  03E00008   JR RA
9D00395C  00000000   NOP
205:                 
206:                 /**
207:                  * Write an entire array of uint8_ts over SPI2.
208:                  * @param size The number of uint8_ts to write.
209:                  * @param buffer The start of the uint8_t array to write.
210:                  */
211:                 void OledPutBuffer(int size, uint8_t *buffer)
212:                 {
9D003960  27BDFFF0   ADDIU SP, SP, -16
9D003964  AFBE000C   SW FP, 12(SP)
9D003968  03A0F021   ADDU FP, SP, ZERO
9D00396C  AFC40010   SW A0, 16(FP)
9D003970  AFC50014   SW A1, 20(FP)
213:                     uint8_t bTmp = 0;
9D003974  A3C00004   SB ZERO, 4(FP)
214:                     int i = bTmp; //non ideal way of forcing Wall error to go away
9D003978  93C20004   LBU V0, 4(FP)
9D00397C  AFC20000   SW V0, 0(FP)
215:                     for (i = 0; i < size; ++i) {
9D003980  AFC00000   SW ZERO, 0(FP)
9D003984  0B400E7C   J 0x9D0039F0
9D003988  00000000   NOP
9D0039E4  8FC20000   LW V0, 0(FP)
9D0039E8  24420001   ADDIU V0, V0, 1
9D0039EC  AFC20000   SW V0, 0(FP)
9D0039F0  8FC30000   LW V1, 0(FP)
9D0039F4  8FC20010   LW V0, 16(FP)
9D0039F8  0062102A   SLT V0, V1, V0
9D0039FC  1440FFE3   BNE V0, ZERO, 0x9D00398C
9D003A00  00000000   NOP
216:                         // Make sure the transmitter is ready
217:                         while (SPI2STATbits.SPITBE == 0);
9D00398C  00000000   NOP
9D003990  3C02BF80   LUI V0, -16512
9D003994  8C425A10   LW V0, 23056(V0)
9D003998  30420008   ANDI V0, V0, 8
9D00399C  1040FFFC   BEQ V0, ZERO, 0x9D003990
9D0039A0  00000000   NOP
218:                 
219:                         // Then transmit the desired uint8_t.
220:                         SPI2BUF = *buffer++;
9D0039A4  8FC20014   LW V0, 20(FP)
9D0039A8  24430001   ADDIU V1, V0, 1
9D0039AC  AFC30014   SW V1, 20(FP)
9D0039B0  90420000   LBU V0, 0(V0)
9D0039B4  00401821   ADDU V1, V0, ZERO
9D0039B8  3C02BF80   LUI V0, -16512
9D0039BC  AC435A20   SW V1, 23072(V0)
221:                 
222:                         // And wait for a response. It's ignored, but we read it out of the buffer anyways to keep
223:                         // the buffer clear.
224:                         while (SPI2STATbits.SPIRBF == 0);
9D0039C0  00000000   NOP
9D0039C4  3C02BF80   LUI V0, -16512
9D0039C8  8C425A10   LW V0, 23056(V0)
9D0039CC  30420001   ANDI V0, V0, 1
9D0039D0  1040FFFC   BEQ V0, ZERO, 0x9D0039C4
9D0039D4  00000000   NOP
225:                         bTmp = SPI2BUF;
9D0039D8  3C02BF80   LUI V0, -16512
9D0039DC  8C425A20   LW V0, 23072(V0)
9D0039E0  A3C20004   SB V0, 4(FP)
226:                     }
227:                 }
9D003A04  03C0E821   ADDU SP, FP, ZERO
9D003A08  8FBE000C   LW FP, 12(SP)
9D003A0C  27BD0010   ADDIU SP, SP, 16
9D003A10  03E00008   JR RA
9D003A14  00000000   NOP
228:                 
229:                 /**
230:                  * Performs a blocking write of a single uint8_t over SPI2. The response uint8_t is returned.
231:                  * @param bVal The uint8_t to write over SPI.
232:                  * @return The response to the transmission.
233:                  */
234:                 uint8_t Spi2Put(uint8_t bVal)
235:                 {
9D003A18  27BDFFF0   ADDIU SP, SP, -16
9D003A1C  AFBE000C   SW FP, 12(SP)
9D003A20  03A0F021   ADDU FP, SP, ZERO
9D003A24  00801021   ADDU V0, A0, ZERO
9D003A28  A3C20010   SB V0, 16(FP)
236:                     // Make sure the transmitter is ready
237:                     while (SPI2STATbits.SPITBE == 0);
9D003A2C  00000000   NOP
9D003A30  3C02BF80   LUI V0, -16512
9D003A34  8C425A10   LW V0, 23056(V0)
9D003A38  30420008   ANDI V0, V0, 8
9D003A3C  1040FFFC   BEQ V0, ZERO, 0x9D003A30
9D003A40  00000000   NOP
238:                 
239:                     // Then transmit the desired uint8_t.
240:                     SPI2BUF = bVal;
9D003A44  93C30010   LBU V1, 16(FP)
9D003A48  3C02BF80   LUI V0, -16512
9D003A4C  AC435A20   SW V1, 23072(V0)
241:                 
242:                     // And wait for a response.
243:                     while (SPI2STATbits.SPIRBF == 0);
9D003A50  00000000   NOP
9D003A54  3C02BF80   LUI V0, -16512
9D003A58  8C425A10   LW V0, 23056(V0)
9D003A5C  30420001   ANDI V0, V0, 1
9D003A60  1040FFFC   BEQ V0, ZERO, 0x9D003A54
9D003A64  00000000   NOP
244:                 
245:                     // Before returning it.
246:                     uint8_t bRx = SPI2BUF;
9D003A68  3C02BF80   LUI V0, -16512
9D003A6C  8C425A20   LW V0, 23072(V0)
9D003A70  A3C20000   SB V0, 0(FP)
247:                     return bRx;
9D003A74  93C20000   LBU V0, 0(FP)
248:                 }
9D003A78  03C0E821   ADDU SP, FP, ZERO
9D003A7C  8FBE000C   LW FP, 12(SP)
9D003A80  27BD0010   ADDIU SP, SP, 16
9D003A84  03E00008   JR RA
9D003A88  00000000   NOP
249:                 
250:                 /**
251:                  * Block the processor for the desired number of milliseconds.
252:                  * @note Assumes processor frequency of 80Mhz.
253:                  * @param msec The number of milliseconds to block for.
254:                  */
255:                 void DelayMs(uint32_t msec)
256:                 {
9D003A8C  27BDFFE8   ADDIU SP, SP, -24
9D003A90  AFBE0014   SW FP, 20(SP)
9D003A94  03A0F021   ADDU FP, SP, ZERO
9D003A98  AFC40018   SW A0, 24(FP)
257:                     uint32_t tWait, tStart, tCurrent;
258:                 
259:                     // Calculate the amount of wait time in terms of core processor frequency.
260:                     tWait = (80000000L / 2000) * msec;
9D003A9C  8FC40018   LW A0, 24(FP)
9D003AA0  00801821   ADDU V1, A0, ZERO
9D003AA4  00031080   SLL V0, V1, 2
9D003AA8  00401821   ADDU V1, V0, ZERO
9D003AAC  00031140   SLL V0, V1, 5
9D003AB0  00431023   SUBU V0, V0, V1
9D003AB4  00441021   ADDU V0, V0, A0
9D003AB8  00021880   SLL V1, V0, 2
9D003ABC  00431021   ADDU V0, V0, V1
9D003AC0  00021180   SLL V0, V0, 6
9D003AC4  AFC20004   SW V0, 4(FP)
261:                     asm volatile("mfc0   %0, $9" : "=r"(tStart));
9D003AC8  40024800   MFC0 V0, Count
9D003ACC  AFC20008   SW V0, 8(FP)
262:                     tCurrent = tStart;
9D003AD0  8FC20008   LW V0, 8(FP)
9D003AD4  AFC20000   SW V0, 0(FP)
263:                     while ((tCurrent - tStart) < tWait) {
9D003AD8  0B400EBA   J 0x9D003AE8
9D003ADC  00000000   NOP
9D003AE8  8FC30000   LW V1, 0(FP)
9D003AEC  8FC20008   LW V0, 8(FP)
9D003AF0  00621823   SUBU V1, V1, V0
9D003AF4  8FC20004   LW V0, 4(FP)
9D003AF8  0062102B   SLTU V0, V1, V0
9D003AFC  1440FFF8   BNE V0, ZERO, 0x9D003AE0
9D003B00  00000000   NOP
264:                         asm volatile("mfc0   %0, $9" : "=r"(tCurrent));
9D003AE0  40024800   MFC0 V0, Count
9D003AE4  AFC20000   SW V0, 0(FP)
265:                     }// wait for the time to pass
266:                 }
9D003B04  03C0E821   ADDU SP, FP, ZERO
---  c:/users/kylez/cmpe13/lab09/lab9.x/messagetest.c  --------------------------------------------------
1:                   /*
2:                    * File:   MessageTest.c
3:                    * Author: kylez
4:                    *
5:                    * Created on May 31, 2019, 8:18 PM
6:                    */
7:                   
8:                   
9:                   #include "xc.h"
10:                  #include <stdio.h>
11:                  #include <stdlib.h>
12:                  #include "Message.h"
13:                  #include "BOARD.h"
14:                  
15:                  char *msg = "$RES,4,8,1*55";
16:                  static Message message_in;
17:                  char* message;
18:                  uint8_t checksum;
19:                  int x;
20:                  int main(void)
21:                  {
9D0062A8  27BDFFE0   ADDIU SP, SP, -32
9D0062AC  AFBF001C   SW RA, 28(SP)
9D0062B0  AFBE0018   SW FP, 24(SP)
9D0062B4  03A0F021   ADDU FP, SP, ZERO
22:                      message_in.param0 = 1;
9D0062B8  3C02A000   LUI V0, -24576
9D0062BC  24420D7C   ADDIU V0, V0, 3452
9D0062C0  24030001   ADDIU V1, ZERO, 1
9D0062C4  AC430004   SW V1, 4(V0)
23:                      message_in.type = MESSAGE_CHA;
9D0062C8  3C02A000   LUI V0, -24576
9D0062CC  24030001   ADDIU V1, ZERO, 1
9D0062D0  AC430D7C   SW V1, 3452(V0)
24:                      checksum = Message_CalculateChecksum(msg);
9D0062D4  8F828010   LW V0, -32752(GP)
9D0062D8  00402021   ADDU A0, V0, ZERO
9D0062DC  0F400323   JAL Message_CalculateChecksum
9D0062E0  00000000   NOP
9D0062E4  A382802C   SB V0, -32724(GP)
25:                      printf("%X\n", checksum);
9D0062E8  9382802C   LBU V0, -32724(GP)
9D0062EC  3C039D00   LUI V1, -25344
9D0062F0  246469AC   ADDIU A0, V1, 27052
9D0062F4  00402821   ADDU A1, V0, ZERO
9D0062F8  0F401A44   JAL _printf_cdnopsuxX
9D0062FC  00000000   NOP
26:                      x = Message_Encode(message, message_in);
9D006300  8F838028   LW V1, -32728(GP)
9D006304  3C02A000   LUI V0, -24576
9D006308  24440D7C   ADDIU A0, V0, 3452
9D00630C  8C84000C   LW A0, 12(A0)
9D006310  AFA40010   SW A0, 16(SP)
9D006314  8C450D7C   LW A1, 3452(V0)
9D006318  24440D7C   ADDIU A0, V0, 3452
9D00631C  8C860004   LW A2, 4(A0)
9D006320  24420D7C   ADDIU V0, V0, 3452
9D006324  8C470008   LW A3, 8(V0)
9D006328  00602021   ADDU A0, V1, ZERO
9D00632C  0F40049C   JAL Message_Encode
9D006330  00000000   NOP
9D006334  AF828024   SW V0, -32732(GP)
27:                      printf("%d\n", x);
9D006338  8F828024   LW V0, -32732(GP)
9D00633C  3C039D00   LUI V1, -25344
9D006340  246469B0   ADDIU A0, V1, 27056
9D006344  00402821   ADDU A1, V0, ZERO
9D006348  0F401A44   JAL _printf_cdnopsuxX
9D00634C  00000000   NOP
28:                      printf("%s", message);
9D006350  8F828028   LW V0, -32728(GP)
9D006354  3C039D00   LUI V1, -25344
9D006358  246469B4   ADDIU A0, V1, 27060
9D00635C  00402821   ADDU A1, V0, ZERO
9D006360  0F401A44   JAL _printf_cdnopsuxX
9D006364  00000000   NOP
29:                      
30:                      while(1);
9D006368  0B4018DA   J .LVL4
31:                  }
---  c:/users/kylez/cmpe13/lab09/lab9.x/message.c  ------------------------------------------------------
1:                   /*
2:                    * File:   Message.c
3:                    * Author: kylez
4:                    *
5:                    * Created on May 31, 2019, 7:00 PM
6:                    */
7:                   
8:                   #include <stdio.h>
9:                   #include <stdlib.h>
10:                  #include <string.h>
11:                  #include "Message.h"
12:                  #include "BOARD.h"
13:                  #include "xc.h"
14:                  
15:                  #define CHA "CHA"
16:                  #define ACC "ACC"
17:                  #define REV "REV"
18:                  #define SHO "SHO"
19:                  #define RES "RES"
20:                  #define CHECKSUM_MAX_LEN 2
21:                  
22:                  typedef enum {
23:                      WAITING_FOR_START_DELIMITER,
24:                      RECORDING_PAYLOAD,
25:                      RECORDING_CHECKSUM
26:                  } decodestate;
27:                  
28:                  static uint8_t payloadmax = 0;
29:                  static char load[MESSAGE_MAX_LEN];
30:                  static char chksum[CHECKSUM_MAX_LEN];
31:                  static uint8_t msg1index = 0;
32:                  static uint8_t checksumlen;
33:                  static decodestate state;
34:                  
35:                  uint8_t Message_CalculateChecksum(const char* payload)
36:                  {
9D000C8C  27BDFFF0   ADDIU SP, SP, -16
9D000C90  AFBE000C   SW FP, 12(SP)
9D000C94  03A0F021   ADDU FP, SP, ZERO
9D000C98  AFC40010   SW A0, 16(FP)
37:                      uint8_t checksum = 0;
9D000C9C  A3C00000   SB ZERO, 0(FP)
38:                      for (payload = payload + 1; *payload != '*' && *payload != NULL; payload++) {
9D000CA0  8FC20010   LW V0, 16(FP)
9D000CA4  24420001   ADDIU V0, V0, 1
9D000CA8  AFC20010   SW V0, 16(FP)
9D000CAC  0B400336   J 0x9D000CD8
9D000CB0  00000000   NOP
9D000CCC  8FC20010   LW V0, 16(FP)
9D000CD0  24420001   ADDIU V0, V0, 1
9D000CD4  AFC20010   SW V0, 16(FP)
9D000CD8  8FC20010   LW V0, 16(FP)
9D000CDC  80430000   LB V1, 0(V0)
9D000CE0  2402002A   ADDIU V0, ZERO, 42
9D000CE4  10620005   BEQ V1, V0, 0x9D000CFC
9D000CE8  00000000   NOP
9D000CEC  8FC20010   LW V0, 16(FP)
9D000CF0  80420000   LB V0, 0(V0)
9D000CF4  1440FFEF   BNE V0, ZERO, 0x9D000CB4
9D000CF8  00000000   NOP
39:                          checksum ^= *payload;
9D000CB4  8FC20010   LW V0, 16(FP)
9D000CB8  80430000   LB V1, 0(V0)
9D000CBC  83C20000   LB V0, 0(FP)
9D000CC0  00621026   XOR V0, V1, V0
9D000CC4  7C021420   SEB V0, V0
9D000CC8  A3C20000   SB V0, 0(FP)
40:                      }
41:                      return checksum;
9D000CFC  93C20000   LBU V0, 0(FP)
42:                  }
9D000D00  03C0E821   ADDU SP, FP, ZERO
9D000D04  8FBE000C   LW FP, 12(SP)
9D000D08  27BD0010   ADDIU SP, SP, 16
9D000D0C  03E00008   JR RA
9D000D10  00000000   NOP
43:                  
44:                  /**
45:                   * Given a payload and its checksum, verify that the payload matches the checksum
46:                   * 
47:                   * @param payload       //the payload of a message
48:                   * @param checksum      //the checksum (in string form) of  a message,
49:                   *                          should be exactly 2 chars long, plus a null char
50:                   * @param message_event //An event corresponding to the parsed message.
51:                   *                      //If the message could be parsed successfully,
52:                   *                          message_event's type will correspond to the message type and 
53:                   *                          its parameters will match the message's data fields.
54:                   *                      //If the message could not be parsed,
55:                   *                          message_events type will be BB_EVENT_ERROR
56:                   * 
57:                   * @return STANDARD_ERROR if:
58:                   *              the payload does not match the checksum
59:                   *              the checksum string is not two characters long
60:                   *              the message does not match any message template
61:                   *          SUCCESS otherwise
62:                   * 
63:                   * Please note!  sscanf() has a couple compiler bugs that make it a very
64:                   * unreliable tool for implementing this function. * 
65:                   */
66:                  int Message_ParseMessage(const char* payload,
67:                          const char* checksum_string, BB_Event * message_event)
68:                  {
9D000D14  27BDFFC0   ADDIU SP, SP, -64
9D000D18  AFBF003C   SW RA, 60(SP)
9D000D1C  AFBE0038   SW FP, 56(SP)
9D000D20  03A0F021   ADDU FP, SP, ZERO
9D000D24  AFC40040   SW A0, 64(FP)
9D000D28  AFC50044   SW A1, 68(FP)
9D000D2C  AFC60048   SW A2, 72(FP)
69:                      int x = 0;
9D000D30  AFC00018   SW ZERO, 24(FP)
70:                      uint16_t data1, data2, data3;
71:                      uint8_t checksum;
72:                      char* checksumstr, *msg1, *msg2, *msgtemp, *msg1type, *tok;
73:                      checksum = Message_CalculateChecksum(payload);
9D000D34  8FC40040   LW A0, 64(FP)
9D000D38  0F400323   JAL Message_CalculateChecksum
9D000D3C  00000000   NOP
9D000D40  A3C2001C   SB V0, 28(FP)
74:                      if (strlen(checksum_string) != 2) {
9D000D44  8FC40044   LW A0, 68(FP)
9D000D48  0F4015C5   JAL strlen
9D000D4C  00000000   NOP
9D000D50  00401821   ADDU V1, V0, ZERO
9D000D54  24020002   ADDIU V0, ZERO, 2
9D000D58  10620004   BEQ V1, V0, 0x9D000D6C
9D000D5C  00000000   NOP
75:                          return STANDARD_ERROR;
9D000D60  00001021   ADDU V0, ZERO, ZERO
9D000D64  0B400496   J 0x9D001258
9D000D68  00000000   NOP
76:                      }
77:                      sprintf(checksumstr, "%02X", checksum);
9D000D6C  93C2001C   LBU V0, 28(FP)
9D000D70  8FC40020   LW A0, 32(FP)
9D000D74  3C039D00   LUI V1, -25344
9D000D78  246566E0   ADDIU A1, V1, 26336
9D000D7C  00403021   ADDU A2, V0, ZERO
9D000D80  0F40199E   JAL _sprintf_cdnopsuxX
9D000D84  00000000   NOP
78:                      if (strcmp(checksumstr, checksum_string) != 0) {
9D000D88  8FC40020   LW A0, 32(FP)
9D000D8C  8FC50044   LW A1, 68(FP)
9D000D90  0F40170B   JAL .LFE0, strcmp
9D000D94  00000000   NOP
9D000D98  10400004   BEQ V0, ZERO, 0x9D000DAC
9D000D9C  00000000   NOP
79:                          return STANDARD_ERROR;
9D000DA0  00001021   ADDU V0, ZERO, ZERO
9D000DA4  0B400496   J 0x9D001258
9D000DA8  00000000   NOP
80:                      }
81:                      msg1type = strtok(payload, ",");
9D000DAC  8FC40040   LW A0, 64(FP)
9D000DB0  3C029D00   LUI V0, -25344
9D000DB4  244566E8   ADDIU A1, V0, 26344
9D000DB8  0F401841   JAL strtok
9D000DBC  00000000   NOP
9D000DC0  AFC20024   SW V0, 36(FP)
82:                      tok = strtok(NULL, ",");
9D000DC4  00002021   ADDU A0, ZERO, ZERO
9D000DC8  3C029D00   LUI V0, -25344
9D000DCC  244566E8   ADDIU A1, V0, 26344
9D000DD0  0F401841   JAL strtok
9D000DD4  00000000   NOP
9D000DD8  AFC20028   SW V0, 40(FP)
83:                      if (tok == NULL) {
9D000DDC  8FC20028   LW V0, 40(FP)
9D000DE0  14400004   BNE V0, ZERO, 0x9D000DF4
9D000DE4  00000000   NOP
84:                          return STANDARD_ERROR;
9D000DE8  00001021   ADDU V0, ZERO, ZERO
9D000DEC  0B400496   J 0x9D001258
9D000DF0  00000000   NOP
85:                      } else {
86:                          message_event->param0 = atof(tok);
9D000DF4  8FC40028   LW A0, 40(FP)
9D000DF8  0F401A75   JAL atof
9D000DFC  00000000   NOP
9D000E00  00402021   ADDU A0, V0, ZERO
9D000E04  0F401947   JAL fptoui
9D000E08  00000000   NOP
9D000E0C  3043FFFF   ANDI V1, V0, -1
9D000E10  8FC20048   LW V0, 72(FP)
9D000E14  A4430004   SH V1, 4(V0)
87:                      }
88:                      tok = strtok(NULL, ",");
9D000E18  00002021   ADDU A0, ZERO, ZERO
9D000E1C  3C029D00   LUI V0, -25344
9D000E20  244566E8   ADDIU A1, V0, 26344
9D000E24  0F401841   JAL strtok
9D000E28  00000000   NOP
9D000E2C  AFC20028   SW V0, 40(FP)
89:                      message_event->param1 = atof(tok);
9D000E30  8FC40028   LW A0, 40(FP)
9D000E34  0F401A75   JAL atof
9D000E38  00000000   NOP
9D000E3C  00402021   ADDU A0, V0, ZERO
9D000E40  0F401947   JAL fptoui
9D000E44  00000000   NOP
9D000E48  3043FFFF   ANDI V1, V0, -1
9D000E4C  8FC20048   LW V0, 72(FP)
9D000E50  A4430006   SH V1, 6(V0)
90:                      tok = strtok(NULL, ",");
9D000E54  00002021   ADDU A0, ZERO, ZERO
9D000E58  3C029D00   LUI V0, -25344
9D000E5C  244566E8   ADDIU A1, V0, 26344
9D000E60  0F401841   JAL strtok
9D000E64  00000000   NOP
9D000E68  AFC20028   SW V0, 40(FP)
91:                      message_event->param2 = atof(tok);
9D000E6C  8FC40028   LW A0, 40(FP)
9D000E70  0F401A75   JAL atof
9D000E74  00000000   NOP
9D000E78  00402021   ADDU A0, V0, ZERO
9D000E7C  0F401947   JAL fptoui
9D000E80  00000000   NOP
9D000E84  3043FFFF   ANDI V1, V0, -1
9D000E88  8FC20048   LW V0, 72(FP)
9D000E8C  A4430008   SH V1, 8(V0)
92:                      if (strcmp(msg1type, CHA) != 0) {
9D000E90  8FC40024   LW A0, 36(FP)
9D000E94  3C029D00   LUI V0, -25344
9D000E98  244566EC   ADDIU A1, V0, 26348
9D000E9C  0F40170B   JAL .LFE0, strcmp
9D000EA0  00000000   NOP
9D000EA4  10400028   BEQ V0, ZERO, 0x9D000F48
9D000EA8  00000000   NOP
93:                          sprintf(msgtemp, PAYLOAD_TEMPLATE_CHA, message_event->param0);
9D000EAC  8FC20048   LW V0, 72(FP)
9D000EB0  94420004   LHU V0, 4(V0)
9D000EB4  8FC4002C   LW A0, 44(FP)
9D000EB8  3C039D00   LUI V1, -25344
9D000EBC  246566F0   ADDIU A1, V1, 26352
9D000EC0  00403021   ADDU A2, V0, ZERO
9D000EC4  0F40199E   JAL _sprintf_cdnopsuxX
9D000EC8  00000000   NOP
94:                          sprintf(msg1, MESSAGE_TEMPLATE, msgtemp, checksum);
9D000ECC  93C2001C   LBU V0, 28(FP)
9D000ED0  8FC40030   LW A0, 48(FP)
9D000ED4  3C039D00   LUI V1, -25344
9D000ED8  246566F8   ADDIU A1, V1, 26360
9D000EDC  8FC6002C   LW A2, 44(FP)
9D000EE0  00403821   ADDU A3, V0, ZERO
9D000EE4  0F40199E   JAL _sprintf_cdnopsuxX
9D000EE8  00000000   NOP
95:                          sprintf(msg2, MESSAGE_TEMPLATE, payload, checksum);
9D000EEC  93C2001C   LBU V0, 28(FP)
9D000EF0  8FC40034   LW A0, 52(FP)
9D000EF4  3C039D00   LUI V1, -25344
9D000EF8  246566F8   ADDIU A1, V1, 26360
9D000EFC  8FC60040   LW A2, 64(FP)
9D000F00  00403821   ADDU A3, V0, ZERO
9D000F04  0F40199E   JAL _sprintf_cdnopsuxX
9D000F08  00000000   NOP
96:                          if (strcmp(msg1, msg2) != 0) {
9D000F0C  8FC40030   LW A0, 48(FP)
9D000F10  8FC50034   LW A1, 52(FP)
9D000F14  0F40170B   JAL .LFE0, strcmp
9D000F18  00000000   NOP
9D000F1C  10400004   BEQ V0, ZERO, 0x9D000F30
9D000F20  00000000   NOP
97:                              return STANDARD_ERROR;
9D000F24  00001021   ADDU V0, ZERO, ZERO
9D000F28  0B400496   J 0x9D001258
9D000F2C  00000000   NOP
98:                          } else {
99:                              message_event->type = BB_EVENT_CHA_RECEIVED;
9D000F30  8FC20048   LW V0, 72(FP)
9D000F34  24030003   ADDIU V1, ZERO, 3
9D000F38  AC430000   SW V1, 0(V0)
100:                             return SUCCESS;
9D000F3C  24020001   ADDIU V0, ZERO, 1
9D000F40  0B400496   J 0x9D001258
9D000F44  00000000   NOP
101:                         }
102:                     } else if (strcmp(msg1type, ACC) != 0) {
9D000F48  8FC40024   LW A0, 36(FP)
9D000F4C  3C029D00   LUI V0, -25344
9D000F50  24456704   ADDIU A1, V0, 26372
9D000F54  0F40170B   JAL .LFE0, strcmp
9D000F58  00000000   NOP
9D000F5C  10400028   BEQ V0, ZERO, 0x9D001000
9D000F60  00000000   NOP
103:                         sprintf(msgtemp, PAYLOAD_TEMPLATE_ACC, message_event->param0);
9D000F64  8FC20048   LW V0, 72(FP)
9D000F68  94420004   LHU V0, 4(V0)
9D000F6C  8FC4002C   LW A0, 44(FP)
9D000F70  3C039D00   LUI V1, -25344
9D000F74  24656708   ADDIU A1, V1, 26376
9D000F78  00403021   ADDU A2, V0, ZERO
9D000F7C  0F40199E   JAL _sprintf_cdnopsuxX
9D000F80  00000000   NOP
104:                         sprintf(msg1, MESSAGE_TEMPLATE, msgtemp, checksum);
9D000F84  93C2001C   LBU V0, 28(FP)
9D000F88  8FC40030   LW A0, 48(FP)
9D000F8C  3C039D00   LUI V1, -25344
9D000F90  246566F8   ADDIU A1, V1, 26360
9D000F94  8FC6002C   LW A2, 44(FP)
9D000F98  00403821   ADDU A3, V0, ZERO
9D000F9C  0F40199E   JAL _sprintf_cdnopsuxX
9D000FA0  00000000   NOP
105:                         sprintf(msg2, MESSAGE_TEMPLATE, payload, checksum);
9D000FA4  93C2001C   LBU V0, 28(FP)
9D000FA8  8FC40034   LW A0, 52(FP)
9D000FAC  3C039D00   LUI V1, -25344
9D000FB0  246566F8   ADDIU A1, V1, 26360
9D000FB4  8FC60040   LW A2, 64(FP)
9D000FB8  00403821   ADDU A3, V0, ZERO
9D000FBC  0F40199E   JAL _sprintf_cdnopsuxX
9D000FC0  00000000   NOP
106:                         if (strcmp(msg1, msg2) != 0) {
9D000FC4  8FC40030   LW A0, 48(FP)
9D000FC8  8FC50034   LW A1, 52(FP)
9D000FCC  0F40170B   JAL .LFE0, strcmp
9D000FD0  00000000   NOP
9D000FD4  10400004   BEQ V0, ZERO, 0x9D000FE8
9D000FD8  00000000   NOP
107:                             return STANDARD_ERROR;
9D000FDC  00001021   ADDU V0, ZERO, ZERO
9D000FE0  0B400496   J 0x9D001258
9D000FE4  00000000   NOP
108:                         } else {
109:                             message_event->type = BB_EVENT_ACC_RECEIVED;
9D000FE8  8FC20048   LW V0, 72(FP)
9D000FEC  24030004   ADDIU V1, ZERO, 4
9D000FF0  AC430000   SW V1, 0(V0)
110:                             return SUCCESS;
9D000FF4  24020001   ADDIU V0, ZERO, 1
9D000FF8  0B400496   J 0x9D001258
9D000FFC  00000000   NOP
111:                         }
112:                     } else if (strcmp(msg1type, REV) != 0) {
9D001000  8FC40024   LW A0, 36(FP)
9D001004  3C029D00   LUI V0, -25344
9D001008  24456710   ADDIU A1, V0, 26384
9D00100C  0F40170B   JAL .LFE0, strcmp
9D001010  00000000   NOP
9D001014  10400028   BEQ V0, ZERO, 0x9D0010B8
9D001018  00000000   NOP
113:                         sprintf(msgtemp, PAYLOAD_TEMPLATE_REV, message_event->param0);
9D00101C  8FC20048   LW V0, 72(FP)
9D001020  94420004   LHU V0, 4(V0)
9D001024  8FC4002C   LW A0, 44(FP)
9D001028  3C039D00   LUI V1, -25344
9D00102C  24656714   ADDIU A1, V1, 26388
9D001030  00403021   ADDU A2, V0, ZERO
9D001034  0F40199E   JAL _sprintf_cdnopsuxX
9D001038  00000000   NOP
114:                         sprintf(msg1, MESSAGE_TEMPLATE, msgtemp, checksum);
9D00103C  93C2001C   LBU V0, 28(FP)
9D001040  8FC40030   LW A0, 48(FP)
9D001044  3C039D00   LUI V1, -25344
9D001048  246566F8   ADDIU A1, V1, 26360
9D00104C  8FC6002C   LW A2, 44(FP)
9D001050  00403821   ADDU A3, V0, ZERO
9D001054  0F40199E   JAL _sprintf_cdnopsuxX
9D001058  00000000   NOP
115:                         sprintf(msg2, MESSAGE_TEMPLATE, payload, checksum);
9D00105C  93C2001C   LBU V0, 28(FP)
9D001060  8FC40034   LW A0, 52(FP)
9D001064  3C039D00   LUI V1, -25344
9D001068  246566F8   ADDIU A1, V1, 26360
9D00106C  8FC60040   LW A2, 64(FP)
9D001070  00403821   ADDU A3, V0, ZERO
9D001074  0F40199E   JAL _sprintf_cdnopsuxX
9D001078  00000000   NOP
116:                         if (strcmp(msg1, msg2) != 0) {
9D00107C  8FC40030   LW A0, 48(FP)
9D001080  8FC50034   LW A1, 52(FP)
9D001084  0F40170B   JAL .LFE0, strcmp
9D001088  00000000   NOP
9D00108C  10400004   BEQ V0, ZERO, 0x9D0010A0
9D001090  00000000   NOP
117:                             return STANDARD_ERROR;
9D001094  00001021   ADDU V0, ZERO, ZERO
9D001098  0B400496   J 0x9D001258
9D00109C  00000000   NOP
118:                         } else {
119:                             message_event->type = BB_EVENT_REV_RECEIVED;
9D0010A0  8FC20048   LW V0, 72(FP)
9D0010A4  24030005   ADDIU V1, ZERO, 5
9D0010A8  AC430000   SW V1, 0(V0)
120:                             return SUCCESS;
9D0010AC  24020001   ADDIU V0, ZERO, 1
9D0010B0  0B400496   J 0x9D001258
9D0010B4  00000000   NOP
121:                         }
122:                     } else if (strcmp(msg1type, SHO) != 0) {
9D0010B8  8FC40024   LW A0, 36(FP)
9D0010BC  3C029D00   LUI V0, -25344
9D0010C0  2445671C   ADDIU A1, V0, 26396
9D0010C4  0F40170B   JAL .LFE0, strcmp
9D0010C8  00000000   NOP
9D0010CC  1040002C   BEQ V0, ZERO, 0x9D001180
9D0010D0  00000000   NOP
123:                         sprintf(msgtemp, PAYLOAD_TEMPLATE_SHO, message_event->param0, message_event->param1);
9D0010D4  8FC20048   LW V0, 72(FP)
9D0010D8  94420004   LHU V0, 4(V0)
9D0010DC  00401821   ADDU V1, V0, ZERO
9D0010E0  8FC20048   LW V0, 72(FP)
9D0010E4  94420006   LHU V0, 6(V0)
9D0010E8  8FC4002C   LW A0, 44(FP)
9D0010EC  3C059D00   LUI A1, -25344
9D0010F0  24A56720   ADDIU A1, A1, 26400
9D0010F4  00603021   ADDU A2, V1, ZERO
9D0010F8  00403821   ADDU A3, V0, ZERO
9D0010FC  0F40199E   JAL _sprintf_cdnopsuxX
9D001100  00000000   NOP
124:                         sprintf(msg1, MESSAGE_TEMPLATE, msgtemp, checksum);
9D001104  93C2001C   LBU V0, 28(FP)
9D001108  8FC40030   LW A0, 48(FP)
9D00110C  3C039D00   LUI V1, -25344
9D001110  246566F8   ADDIU A1, V1, 26360
9D001114  8FC6002C   LW A2, 44(FP)
9D001118  00403821   ADDU A3, V0, ZERO
9D00111C  0F40199E   JAL _sprintf_cdnopsuxX
9D001120  00000000   NOP
125:                         sprintf(msg2, MESSAGE_TEMPLATE, payload, checksum);
9D001124  93C2001C   LBU V0, 28(FP)
9D001128  8FC40034   LW A0, 52(FP)
9D00112C  3C039D00   LUI V1, -25344
9D001130  246566F8   ADDIU A1, V1, 26360
9D001134  8FC60040   LW A2, 64(FP)
9D001138  00403821   ADDU A3, V0, ZERO
9D00113C  0F40199E   JAL _sprintf_cdnopsuxX
9D001140  00000000   NOP
126:                         if (strcmp(msg1, msg2) != 0) {
9D001144  8FC40030   LW A0, 48(FP)
9D001148  8FC50034   LW A1, 52(FP)
9D00114C  0F40170B   JAL .LFE0, strcmp
9D001150  00000000   NOP
9D001154  10400004   BEQ V0, ZERO, 0x9D001168
9D001158  00000000   NOP
127:                             return STANDARD_ERROR;
9D00115C  00001021   ADDU V0, ZERO, ZERO
9D001160  0B400496   J 0x9D001258
9D001164  00000000   NOP
128:                         } else {
129:                             message_event->type = BB_EVENT_SHO_RECEIVED;
9D001168  8FC20048   LW V0, 72(FP)
9D00116C  24030006   ADDIU V1, ZERO, 6
9D001170  AC430000   SW V1, 0(V0)
130:                             return SUCCESS;
9D001174  24020001   ADDIU V0, ZERO, 1
9D001178  0B400496   J 0x9D001258
9D00117C  00000000   NOP
131:                         }
132:                     } else if (strcmp(msg1type, RES) != 0) {
9D001180  8FC40024   LW A0, 36(FP)
9D001184  3C029D00   LUI V0, -25344
9D001188  2445672C   ADDIU A1, V0, 26412
9D00118C  0F40170B   JAL .LFE0, strcmp
9D001190  00000000   NOP
9D001194  1040002F   BEQ V0, ZERO, 0x9D001254
9D001198  00000000   NOP
133:                         sprintf(msgtemp, PAYLOAD_TEMPLATE_RES, message_event->param0, message_event->param1,
9D00119C  8FC20048   LW V0, 72(FP)
9D0011A0  94420004   LHU V0, 4(V0)
9D0011A4  00401821   ADDU V1, V0, ZERO
9D0011A8  8FC20048   LW V0, 72(FP)
9D0011AC  94420006   LHU V0, 6(V0)
9D0011B8  AFA40010   SW A0, 16(SP)
9D0011BC  8FC4002C   LW A0, 44(FP)
9D0011C0  3C059D00   LUI A1, -25344
9D0011C4  24A56730   ADDIU A1, A1, 26416
9D0011C8  00603021   ADDU A2, V1, ZERO
9D0011CC  00403821   ADDU A3, V0, ZERO
9D0011D0  0F40199E   JAL _sprintf_cdnopsuxX
9D0011D4  00000000   NOP
134:                                 message_event->param2);
9D0011B0  8FC40048   LW A0, 72(FP)
9D0011B4  94840008   LHU A0, 8(A0)
135:                         sprintf(msg1, MESSAGE_TEMPLATE, msgtemp, checksum);
9D0011D8  93C2001C   LBU V0, 28(FP)
9D0011DC  8FC40030   LW A0, 48(FP)
9D0011E0  3C039D00   LUI V1, -25344
9D0011E4  246566F8   ADDIU A1, V1, 26360
9D0011E8  8FC6002C   LW A2, 44(FP)
9D0011EC  00403821   ADDU A3, V0, ZERO
9D0011F0  0F40199E   JAL _sprintf_cdnopsuxX
9D0011F4  00000000   NOP
136:                         sprintf(msg2, MESSAGE_TEMPLATE, payload, checksum);
9D0011F8  93C2001C   LBU V0, 28(FP)
9D0011FC  8FC40034   LW A0, 52(FP)
9D001200  3C039D00   LUI V1, -25344
9D001204  246566F8   ADDIU A1, V1, 26360
9D001208  8FC60040   LW A2, 64(FP)
9D00120C  00403821   ADDU A3, V0, ZERO
9D001210  0F40199E   JAL _sprintf_cdnopsuxX
9D001214  00000000   NOP
137:                         if (strcmp(msg1, msg2) != 0) {
9D001218  8FC40030   LW A0, 48(FP)
9D00121C  8FC50034   LW A1, 52(FP)
9D001220  0F40170B   JAL .LFE0, strcmp
9D001224  00000000   NOP
9D001228  10400004   BEQ V0, ZERO, 0x9D00123C
9D00122C  00000000   NOP
138:                             return STANDARD_ERROR;
9D001230  00001021   ADDU V0, ZERO, ZERO
9D001234  0B400496   J 0x9D001258
9D001238  00000000   NOP
139:                         } else {
140:                             message_event->type = BB_EVENT_RES_RECEIVED;
9D00123C  8FC20048   LW V0, 72(FP)
9D001240  24030007   ADDIU V1, ZERO, 7
9D001244  AC430000   SW V1, 0(V0)
141:                             return SUCCESS;
9D001248  24020001   ADDIU V0, ZERO, 1
9D00124C  0B400496   J 0x9D001258
9D001250  00000000   NOP
142:                         }
143:                     } else {
144:                         return STANDARD_ERROR;
9D001254  00001021   ADDU V0, ZERO, ZERO
145:                     }
146:                     return SUCCESS;
147:                 }
9D001258  03C0E821   ADDU SP, FP, ZERO
9D00125C  8FBF003C   LW RA, 60(SP)
9D001260  8FBE0038   LW FP, 56(SP)
9D001264  27BD0040   ADDIU SP, SP, 64
9D001268  03E00008   JR RA
9D00126C  00000000   NOP
148:                 
149:                 /**
150:                  * Encodes the coordinate data for a guess into the string `message`. This string must be big
151:                  * enough to contain all of the necessary data. The format is specified in PAYLOAD_TEMPLATE_COO,
152:                  * which is then wrapped within the message as defined by MESSAGE_TEMPLATE. 
153:                  * 
154:                  * The final length of this
155:                  * message is then returned. There is no failure mode for this function as there is no checking
156:                  * for NULL pointers.
157:                  * 
158:                  * @param message            The character array used for storing the output. 
159:                  *                              Must be long enough to store the entire string,
160:                  *                              see MESSAGE_MAX_LEN.
161:                  * @param message_to_encode  A message to encode
162:                  * @return                   The length of the string stored into 'message_string'.
163:                                              Return 0 if message type is MESSAGE_NONE.
164:                  */
165:                 int Message_Encode(char *message_string, Message message_to_encode)
166:                 {
9D001270  27BDFFD0   ADDIU SP, SP, -48
9D001274  AFBF002C   SW RA, 44(SP)
9D001278  AFBE0028   SW FP, 40(SP)
9D00127C  03A0F021   ADDU FP, SP, ZERO
9D001280  AFC40030   SW A0, 48(FP)
9D001284  AFC50034   SW A1, 52(FP)
9D001288  AFC60038   SW A2, 56(FP)
9D00128C  AFC7003C   SW A3, 60(FP)
167:                     uint8_t checksum;
168:                     char* payload;
169:                     char* message;
170:                     if (message_to_encode.type == MESSAGE_CHA) {
9D001290  8FC30034   LW V1, 52(FP)
9D001294  24020001   ADDIU V0, ZERO, 1
9D001298  1462000A   BNE V1, V0, 0x9D0012C4
9D00129C  00000000   NOP
171:                         sprintf(payload, PAYLOAD_TEMPLATE_CHA, message_to_encode.param0);
9D0012A0  8FC20038   LW V0, 56(FP)
9D0012A4  8FC4001C   LW A0, 28(FP)
9D0012A8  3C039D00   LUI V1, -25344
9D0012AC  246566F0   ADDIU A1, V1, 26352
9D0012B0  00403021   ADDU A2, V0, ZERO
9D0012B4  0F40199E   JAL _sprintf_cdnopsuxX
9D0012B8  00000000   NOP
9D0012BC  0B4004E9   J .LVL76
9D0012C0  00000000   NOP
172:                     } else if (message_to_encode.type == MESSAGE_ACC) {
9D0012C4  8FC30034   LW V1, 52(FP)
9D0012C8  24020002   ADDIU V0, ZERO, 2
9D0012CC  1462000A   BNE V1, V0, 0x9D0012F8
9D0012D0  00000000   NOP
173:                         sprintf(payload, PAYLOAD_TEMPLATE_ACC, message_to_encode.param0);
9D0012D4  8FC20038   LW V0, 56(FP)
9D0012D8  8FC4001C   LW A0, 28(FP)
9D0012DC  3C039D00   LUI V1, -25344
9D0012E0  24656708   ADDIU A1, V1, 26376
9D0012E4  00403021   ADDU A2, V0, ZERO
9D0012E8  0F40199E   JAL _sprintf_cdnopsuxX
9D0012EC  00000000   NOP
9D0012F0  0B4004E9   J .LVL76
9D0012F4  00000000   NOP
174:                     } else if (message_to_encode.type == MESSAGE_RES) {
9D0012F8  8FC30034   LW V1, 52(FP)
9D0012FC  24020005   ADDIU V0, ZERO, 5
9D001300  1462000A   BNE V1, V0, 0x9D00132C
9D001304  00000000   NOP
175:                         sprintf(payload, PAYLOAD_TEMPLATE_REV, message_to_encode.param0);
9D001308  8FC20038   LW V0, 56(FP)
9D00130C  8FC4001C   LW A0, 28(FP)
9D001310  3C039D00   LUI V1, -25344
9D001314  24656714   ADDIU A1, V1, 26388
9D001318  00403021   ADDU A2, V0, ZERO
9D00131C  0F40199E   JAL _sprintf_cdnopsuxX
9D001320  00000000   NOP
9D001324  0B4004E9   J .LVL76
9D001328  00000000   NOP
176:                     } else if (message_to_encode.type == MESSAGE_SHO) {
9D00132C  8FC30034   LW V1, 52(FP)
9D001330  24020004   ADDIU V0, ZERO, 4
9D001334  1462000C   BNE V1, V0, 0x9D001368
9D001338  00000000   NOP
177:                         sprintf(payload, PAYLOAD_TEMPLATE_SHO, message_to_encode.param0,
9D00133C  8FC30038   LW V1, 56(FP)
9D001340  8FC2003C   LW V0, 60(FP)
9D001344  8FC4001C   LW A0, 28(FP)
9D001348  3C059D00   LUI A1, -25344
9D00134C  24A56720   ADDIU A1, A1, 26400
9D001350  00603021   ADDU A2, V1, ZERO
9D001354  00403821   ADDU A3, V0, ZERO
9D001358  0F40199E   JAL _sprintf_cdnopsuxX
9D00135C  00000000   NOP
9D001360  0B4004E9   J .LVL76
9D001364  00000000   NOP
178:                                 message_to_encode.param1);
179:                     } else if (message_to_encode.type == MESSAGE_RES) {
9D001368  8FC30034   LW V1, 52(FP)
9D00136C  24020005   ADDIU V0, ZERO, 5
9D001370  1462000C   BNE V1, V0, .LVL76
9D001374  00000000   NOP
180:                         sprintf(payload, PAYLOAD_TEMPLATE_RES, message_to_encode.param0,
9D001378  8FC30038   LW V1, 56(FP)
9D00137C  8FC2003C   LW V0, 60(FP)
9D001380  8FC40040   LW A0, 64(FP)
9D001384  AFA40010   SW A0, 16(SP)
9D001388  8FC4001C   LW A0, 28(FP)
9D00138C  3C059D00   LUI A1, -25344
9D001390  24A56730   ADDIU A1, A1, 26416
9D001394  00603021   ADDU A2, V1, ZERO
9D001398  00403821   ADDU A3, V0, ZERO
9D00139C  0F40199E   JAL _sprintf_cdnopsuxX
9D0013A0  00000000   NOP
181:                                 message_to_encode.param1, message_to_encode.param2);
182:                     }
183:                     checksum = Message_CalculateChecksum(payload);
9D0013A4  8FC4001C   LW A0, 28(FP)
9D0013A8  0F400323   JAL Message_CalculateChecksum
9D0013AC  00000000   NOP
9D0013B0  A3C20020   SB V0, 32(FP)
184:                     sprintf(message, MESSAGE_TEMPLATE, payload, checksum);
9D0013B4  93C20020   LBU V0, 32(FP)
9D0013B8  8FC40018   LW A0, 24(FP)
9D0013BC  3C039D00   LUI V1, -25344
9D0013C0  246566F8   ADDIU A1, V1, 26360
9D0013C4  8FC6001C   LW A2, 28(FP)
9D0013C8  00403821   ADDU A3, V0, ZERO
9D0013CC  0F40199E   JAL _sprintf_cdnopsuxX
9D0013D0  00000000   NOP
185:                     for (;*message != NULL; message++, message_string++){
9D0013D4  0B400501   J 0x9D001404
9D0013D8  00000000   NOP
9D0013EC  8FC20018   LW V0, 24(FP)
9D0013F0  24420001   ADDIU V0, V0, 1
9D0013F4  AFC20018   SW V0, 24(FP)
9D0013F8  8FC20030   LW V0, 48(FP)
9D0013FC  24420001   ADDIU V0, V0, 1
9D001400  AFC20030   SW V0, 48(FP)
9D001404  8FC20018   LW V0, 24(FP)
9D001408  80420000   LB V0, 0(V0)
9D00140C  1440FFF3   BNE V0, ZERO, 0x9D0013DC
9D001410  00000000   NOP
186:                         *message_string = *message;
9D0013DC  8FC20018   LW V0, 24(FP)
9D0013E0  80430000   LB V1, 0(V0)
9D0013E4  8FC20030   LW V0, 48(FP)
9D0013E8  A0430000   SB V1, 0(V0)
187:                     }
188:                     return strlen(message_string);
9D001414  8FC40030   LW A0, 48(FP)
9D001418  0F4015C5   JAL strlen
9D00141C  00000000   NOP
189:                 }
9D001420  03C0E821   ADDU SP, FP, ZERO
9D001424  8FBF002C   LW RA, 44(SP)
9D001428  8FBE0028   LW FP, 40(SP)
9D00142C  27BD0030   ADDIU SP, SP, 48
9D001430  03E00008   JR RA
9D001434  00000000   NOP
190:                 
191:                 /**
192:                  * Message_Decode reads one character at a time.  If it detects a full NMEA message,
193:                  * it translates that message into a BB_Event struct, which can be passed to other 
194:                  * services.
195:                  * 
196:                  * @param char_in - The next character in the NMEA0183 message to be decoded.
197:                  * @param decoded_message - a pointer to a message struct, used to "return" a message
198:                  *                          if char_in is the last character of a valid message, 
199:                  *                              then decoded_message
200:                  *                              should have the appropriate message type.
201:                  *                              otherwise, it should have type NO_EVENT.
202:                  * @return SUCCESS if no error was detected
203:                  *         STANDARD_ERROR if an error was detected
204:                  * 
205:                  * note that ANY call to Message_Decode may modify decoded_message.
206:                  */
207:                 int Message_Decode(unsigned char char_in, BB_Event * decoded_message_event)
208:                 {
9D001438  27BDFFE0   ADDIU SP, SP, -32
9D00143C  AFBF001C   SW RA, 28(SP)
9D001440  AFBE0018   SW FP, 24(SP)
9D001444  03A0F021   ADDU FP, SP, ZERO
9D001448  00801021   ADDU V0, A0, ZERO
9D00144C  AFC50024   SW A1, 36(FP)
9D001450  A3C20020   SB V0, 32(FP)
209:                     int resultofparse;
210:                     switch (state) {
9D001454  8F828020   LW V0, -32736(GP)
9D001458  24030001   ADDIU V1, ZERO, 1
9D00145C  10430018   BEQ V0, V1, 0x9D0014C0
9D001460  00000000   NOP
9D001464  2C430001   SLTIU V1, V0, 1
9D001468  14600006   BNE V1, ZERO, 0x9D001484
9D00146C  00000000   NOP
9D001470  24030002   ADDIU V1, ZERO, 2
9D001474  1043004C   BEQ V0, V1, 0x9D0015A8
9D001478  00000000   NOP
9D00147C  0B4005B2   J 0x9D0016C8
9D001480  00000000   NOP
211:                     case WAITING_FOR_START_DELIMITER:
212:                         if (char_in == '$') {
9D001484  93C30020   LBU V1, 32(FP)
9D001488  24020024   ADDIU V0, ZERO, 36
9D00148C  1462000C   BNE V1, V0, 0x9D0014C0
9D001490  00000000   NOP
213:                             state = RECORDING_PAYLOAD;
9D001494  24020001   ADDIU V0, ZERO, 1
9D001498  AF828020   SW V0, -32736(GP)
214:                             payloadmax++;
9D00149C  93828018   LBU V0, -32744(GP)
9D0014A0  24420001   ADDIU V0, V0, 1
9D0014A4  304200FF   ANDI V0, V0, 255
9D0014A8  A3828018   SB V0, -32744(GP)
215:                             decoded_message_event->type = BB_EVENT_NO_EVENT;
9D0014AC  8FC20024   LW V0, 36(FP)
9D0014B0  AC400000   SW ZERO, 0(V0)
216:                             return SUCCESS;
9D0014B4  24020001   ADDIU V0, ZERO, 1
9D0014B8  0B4005B2   J 0x9D0016C8
9D0014BC  00000000   NOP
217:                         }
218:                     case RECORDING_PAYLOAD:
219:                         if (payloadmax > MESSAGE_MAX_PAYLOAD_LEN) {
9D0014C0  93828018   LBU V0, -32744(GP)
9D0014C4  2C42004E   SLTIU V0, V0, 78
9D0014C8  14400005   BNE V0, ZERO, 0x9D0014E0
9D0014CC  00000000   NOP
220:                             state = WAITING_FOR_START_DELIMITER;
9D0014D0  AF808020   SW ZERO, -32736(GP)
221:                             return STANDARD_ERROR;
9D0014D4  00001021   ADDU V0, ZERO, ZERO
9D0014D8  0B4005B2   J 0x9D0016C8
9D0014DC  00000000   NOP
222:                         } else if (char_in == '$' || char_in == '\n') {
9D0014E0  93C30020   LBU V1, 32(FP)
9D0014E4  24020024   ADDIU V0, ZERO, 36
9D0014E8  10620005   BEQ V1, V0, 0x9D001500
9D0014EC  00000000   NOP
9D0014F0  93C30020   LBU V1, 32(FP)
9D0014F4  2402000A   ADDIU V0, ZERO, 10
9D0014F8  14620005   BNE V1, V0, 0x9D001510
9D0014FC  00000000   NOP
223:                             state = WAITING_FOR_START_DELIMITER;
9D001500  AF808020   SW ZERO, -32736(GP)
224:                             return STANDARD_ERROR;
9D001504  00001021   ADDU V0, ZERO, ZERO
9D001508  0B4005B2   J 0x9D0016C8
9D00150C  00000000   NOP
225:                         } else if (char_in == '*') {
9D001510  93C30020   LBU V1, 32(FP)
9D001514  2402002A   ADDIU V0, ZERO, 42
9D001518  14620013   BNE V1, V0, 0x9D001568
9D00151C  00000000   NOP
226:                             load[msg1index] = char_in;
9D001520  9382801E   LBU V0, -32738(GP)
9D001524  00402021   ADDU A0, V0, ZERO
9D001528  83C30020   LB V1, 32(FP)
9D00152C  3C02A000   LUI V0, -24576
9D001530  24420CE4   ADDIU V0, V0, 3300
9D001534  00821021   ADDU V0, A0, V0
9D001538  A0430000   SB V1, 0(V0)
227:                             msg1index++;
9D00153C  9382801E   LBU V0, -32738(GP)
9D001540  24420001   ADDIU V0, V0, 1
9D001544  304200FF   ANDI V0, V0, 255
9D001548  A382801E   SB V0, -32738(GP)
228:                             state = RECORDING_CHECKSUM;
9D00154C  24020002   ADDIU V0, ZERO, 2
9D001550  AF828020   SW V0, -32736(GP)
229:                             decoded_message_event->type = BB_EVENT_NO_EVENT;
9D001554  8FC20024   LW V0, 36(FP)
9D001558  AC400000   SW ZERO, 0(V0)
230:                             return SUCCESS;
9D00155C  24020001   ADDIU V0, ZERO, 1
9D001560  0B4005B2   J 0x9D0016C8
9D001564  00000000   NOP
231:                         } else {
232:                             load[msg1index] = char_in;
9D001568  9382801E   LBU V0, -32738(GP)
9D00156C  00402021   ADDU A0, V0, ZERO
9D001570  83C30020   LB V1, 32(FP)
9D001574  3C02A000   LUI V0, -24576
9D001578  24420CE4   ADDIU V0, V0, 3300
9D00157C  00821021   ADDU V0, A0, V0
9D001580  A0430000   SB V1, 0(V0)
233:                             msg1index++;
9D001584  9382801E   LBU V0, -32738(GP)
9D001588  24420001   ADDIU V0, V0, 1
9D00158C  304200FF   ANDI V0, V0, 255
9D001590  A382801E   SB V0, -32738(GP)
234:                             decoded_message_event->type = BB_EVENT_NO_EVENT;
9D001594  8FC20024   LW V0, 36(FP)
9D001598  AC400000   SW ZERO, 0(V0)
235:                             return SUCCESS;
9D00159C  24020001   ADDIU V0, ZERO, 1
9D0015A0  0B4005B2   J 0x9D0016C8
9D0015A4  00000000   NOP
236:                         }
237:                     case RECORDING_CHECKSUM:
238:                         if (checksumlen > CHECKSUM_MAX_LEN) {
9D0015A8  9382801F   LBU V0, -32737(GP)
9D0015AC  2C420003   SLTIU V0, V0, 3
9D0015B0  14400005   BNE V0, ZERO, 0x9D0015C8
9D0015B4  00000000   NOP
239:                             state = WAITING_FOR_START_DELIMITER;
9D0015B8  AF808020   SW ZERO, -32736(GP)
240:                             return STANDARD_ERROR;
9D0015BC  00001021   ADDU V0, ZERO, ZERO
9D0015C0  0B4005B2   J 0x9D0016C8
9D0015C4  00000000   NOP
241:                         } else if (char_in == '\n' && checksumlen < CHECKSUM_MAX_LEN) {
9D0015C8  93C30020   LBU V1, 32(FP)
9D0015CC  2402000A   ADDIU V0, ZERO, 10
9D0015D0  14620009   BNE V1, V0, 0x9D0015F8
9D0015D4  00000000   NOP
9D0015D8  9382801F   LBU V0, -32737(GP)
9D0015DC  2C420002   SLTIU V0, V0, 2
9D0015E0  10400005   BEQ V0, ZERO, 0x9D0015F8
9D0015E4  00000000   NOP
242:                             state = WAITING_FOR_START_DELIMITER;
9D0015E8  AF808020   SW ZERO, -32736(GP)
243:                             return STANDARD_ERROR;
9D0015EC  00001021   ADDU V0, ZERO, ZERO
9D0015F0  0B4005B2   J 0x9D0016C8
9D0015F4  00000000   NOP
244:                         } else if ((char_in >= 48 && char_in <= 57) || (char_in >= 65 && char_in <= 70)) {
9D0015F8  93C20020   LBU V0, 32(FP)
9D0015FC  2C420030   SLTIU V0, V0, 48
9D001600  14400005   BNE V0, ZERO, 0x9D001618
9D001604  00000000   NOP
9D001608  93C20020   LBU V0, 32(FP)
9D00160C  2C42003A   SLTIU V0, V0, 58
9D001610  14400009   BNE V0, ZERO, 0x9D001638
9D001614  00000000   NOP
9D001618  93C20020   LBU V0, 32(FP)
9D00161C  2C420041   SLTIU V0, V0, 65
9D001620  14400012   BNE V0, ZERO, 0x9D00166C
9D001624  00000000   NOP
9D001628  93C20020   LBU V0, 32(FP)
9D00162C  2C420047   SLTIU V0, V0, 71
9D001630  1040000E   BEQ V0, ZERO, 0x9D00166C
9D001634  00000000   NOP
245:                             chksum[checksumlen] = char_in;
9D001638  9382801F   LBU V0, -32737(GP)
9D00163C  00402021   ADDU A0, V0, ZERO
9D001640  83C30020   LB V1, 32(FP)
9D001644  2782801C   ADDIU V0, GP, -32740
9D001648  00821021   ADDU V0, A0, V0
9D00164C  A0430000   SB V1, 0(V0)
246:                             checksumlen++;
9D001650  9382801F   LBU V0, -32737(GP)
9D001654  24420001   ADDIU V0, V0, 1
9D001658  304200FF   ANDI V0, V0, 255
9D00165C  A382801F   SB V0, -32737(GP)
247:                             return SUCCESS;
9D001660  24020001   ADDIU V0, ZERO, 1
9D001664  0B4005B2   J 0x9D0016C8
9D001668  00000000   NOP
248:                         }
249:                         if (char_in == '\n') {
9D00166C  93C30020   LBU V1, 32(FP)
9D001670  2402000A   ADDIU V0, ZERO, 10
9D001674  14620014   BNE V1, V0, 0x9D0016C8
9D001678  00000000   NOP
250:                             resultofparse = Message_ParseMessage(load, chksum, decoded_message_event);
9D00167C  3C02A000   LUI V0, -24576
9D001680  24440CE4   ADDIU A0, V0, 3300
9D001684  2785801C   ADDIU A1, GP, -32740
9D001688  8FC60024   LW A2, 36(FP)
9D00168C  0F400345   JAL Message_ParseMessage
9D001690  00000000   NOP
9D001694  AFC20010   SW V0, 16(FP)
251:                             if (resultofparse == SUCCESS) {
9D001698  8FC30010   LW V1, 16(FP)
9D00169C  24020001   ADDIU V0, ZERO, 1
9D0016A0  14620005   BNE V1, V0, 0x9D0016B8
9D0016A4  00000000   NOP
252:                                 state = WAITING_FOR_START_DELIMITER;
9D0016A8  AF808020   SW ZERO, -32736(GP)
253:                                 return SUCCESS;
9D0016AC  24020001   ADDIU V0, ZERO, 1
9D0016B0  0B4005B2   J 0x9D0016C8
9D0016B4  00000000   NOP
254:                             } else {
255:                                 state = WAITING_FOR_START_DELIMITER;
9D0016B8  AF808020   SW ZERO, -32736(GP)
256:                                 return STANDARD_ERROR;
9D0016BC  00001021   ADDU V0, ZERO, ZERO
9D0016C0  0B4005B2   J 0x9D0016C8
9D0016C4  00000000   NOP
257:                             }
258:                         }
259:                     }
260:                 }
9D0016C8  03C0E821   ADDU SP, FP, ZERO
---  c:/users/kylez/cmpe13/lab09/lab9.x/fieldoled.c  ----------------------------------------------------
1:                   
2:                   
3:                   #include "Oled.h"
4:                   #include "OledDriver.h"
5:                   #include "Field.h"
6:                   #include "FieldOled.h"
7:                   #include "Ascii.h"
8:                   
9:                   #define FIELD_SYMBOL_WIDTH 3
10:                  #define FIELD_SYMBOL_HEIGHT 4
11:                  const uint8_t gridSymbols[10][FIELD_SYMBOL_WIDTH] = {
12:                      [FIELD_SQUARE_EMPTY] =
13:                      {
14:                          0b0000,
15:                          0b0000,
16:                          0b0000,
17:                      },
18:                      [FIELD_SQUARE_SMALL_BOAT] =
19:                      {
20:                          0b1001,
21:                          0b1011,
22:                          0b1111,
23:                      },
24:                      [FIELD_SQUARE_MEDIUM_BOAT] =
25:                      { // 
26:                          0b0111,
27:                          0b0100,
28:                          0b1111,
29:                      },
30:                      [FIELD_SQUARE_LARGE_BOAT] =
31:                      { // 
32:                          0b1011,
33:                          0b1011,
34:                          0b1101,
35:                      },
36:                      [FIELD_SQUARE_HUGE_BOAT] =
37:                      { // 
38:                          0b1111,
39:                          0b1101,
40:                          0b1101,
41:                      },
42:                      [FIELD_SQUARE_UNKNOWN] =
43:                      { // 
44:                          0b0000,
45:                          0b0110,
46:                          0b0000,
47:                      },
48:                      [FIELD_SQUARE_HIT] =
49:                      { // 
50:                          0b1001,
51:                          0b0110,
52:                          0b1001,
53:                      },
54:                      [FIELD_SQUARE_MISS] =
55:                      { // 
56:                          0b0000,
57:                          0b0110,
58:                          0b0000,
59:                      },
60:                  
61:                      [FIELD_SQUARE_CURSOR] =
62:                      { // 
63:                          0b1111,
64:                          0b1001,
65:                          0b1111,
66:                      },
67:                  
68:                      [FIELD_SQUARE_INVALID] =
69:                      { // 
70:                          0b1111,
71:                          0b1111,
72:                          0b1111,
73:                      }
74:                  };
75:                  
76:                  uint8_t _FieldOledDrawSymbol(int x, int y, SquareStatus s);
77:                  void _FieldOledDrawField(const Field *f, int xOffset);
78:                  
79:                  void FieldOledDrawScreen(const Field *myField, const Field *theirField,
80:                          FieldOledTurn playerTurn, uint8_t turn_number)
81:                  {
9D00283C  27BDFFE0   ADDIU SP, SP, -32
9D002840  AFBF001C   SW RA, 28(SP)
9D002844  AFBE0018   SW FP, 24(SP)
9D002848  03A0F021   ADDU FP, SP, ZERO
9D00284C  AFC40020   SW A0, 32(FP)
9D002850  AFC50024   SW A1, 36(FP)
9D002854  AFC60028   SW A2, 40(FP)
9D002858  00E01021   ADDU V0, A3, ZERO
9D00285C  A3C2002C   SB V0, 44(FP)
82:                      OledClear(OLED_COLOR_BLACK);
9D002860  00002021   ADDU A0, ZERO, ZERO
9D002864  0F4009AF   JAL OledClear
9D002868  00000000   NOP
83:                      _FieldOledDrawField(myField, 0);
9D00286C  8FC40020   LW A0, 32(FP)
9D002870  00002821   ADDU A1, ZERO, ZERO
9D002874  0F400A84   JAL _FieldOledDrawField
9D002878  00000000   NOP
84:                      if (theirField) {
9D00287C  8FC20024   LW V0, 36(FP)
9D002880  10400015   BEQ V0, ZERO, 0x9D0028D8
9D002884  00000000   NOP
85:                          _FieldOledDrawField(theirField, 76);
9D002888  8FC40024   LW A0, 36(FP)
9D00288C  2405004C   ADDIU A1, ZERO, 76
9D002890  0F400A84   JAL _FieldOledDrawField
9D002894  00000000   NOP
86:                      } else {
87:                          OledUpdate();
9D0028D8  0F400A03   JAL OledUpdate
9D0028DC  00000000   NOP
88:                          return;
9D0028E0  0B400A7E   J .LVL18
9D0028E4  00000000   NOP
89:                      }
90:                  
91:                      //draw inner artwork
92:                      OledDrawChar(53, 1, 'P');
9D002898  24040035   ADDIU A0, ZERO, 53
9D00289C  24050001   ADDIU A1, ZERO, 1
9D0028A0  24060050   ADDIU A2, ZERO, 80
9D0028A4  0F40089E   JAL OledDrawChar
9D0028A8  00000000   NOP
93:                      OledDrawChar(76 - ASCII_FONT_WIDTH - 1, 1, 'O');
9D0028AC  24040045   ADDIU A0, ZERO, 69
9D0028B0  24050001   ADDIU A1, ZERO, 1
9D0028B4  2406004F   ADDIU A2, ZERO, 79
9D0028B8  0F40089E   JAL OledDrawChar
9D0028BC  00000000   NOP
94:                      if (playerTurn == FIELD_OLED_TURN_MINE) {
9D0028C0  8FC30028   LW V1, 40(FP)
9D0028C4  24020001   ADDIU V0, ZERO, 1
9D0028C8  1462000E   BNE V1, V0, 0x9D002904
9D0028CC  00000000   NOP
9D0028D0  0B400A3A   J 0x9D0028E8
9D0028D4  00000000   NOP
95:                          OledDrawChar(53, ASCII_FONT_HEIGHT + 1, '<');
9D0028E8  24040035   ADDIU A0, ZERO, 53
9D0028EC  24050009   ADDIU A1, ZERO, 9
9D0028F0  2406003C   ADDIU A2, ZERO, 60
9D0028F4  0F40089E   JAL OledDrawChar
9D0028F8  00000000   NOP
9D0028FC  0B400A4A   J .LVL9
9D002900  00000000   NOP
96:                      } else if (playerTurn == FIELD_OLED_TURN_THEIRS) {
9D002904  8FC30028   LW V1, 40(FP)
9D002908  24020002   ADDIU V0, ZERO, 2
9D00290C  14620006   BNE V1, V0, .LVL9
9D002910  00000000   NOP
97:                          OledDrawChar(76 - ASCII_FONT_WIDTH - 1, ASCII_FONT_HEIGHT + 1, '>');
9D002914  24040045   ADDIU A0, ZERO, 69
9D002918  24050009   ADDIU A1, ZERO, 9
9D00291C  2406003E   ADDIU A2, ZERO, 62
9D002920  0F40089E   JAL OledDrawChar
9D002924  00000000   NOP
98:                      }
99:                  
100:                     //draw turn number:
101:                     int x;
102:                     x = 76 - ASCII_FONT_WIDTH * 2;
9D002928  24020040   ADDIU V0, ZERO, 64
9D00292C  AFC20010   SW V0, 16(FP)
103:                     OledDrawChar(x, ASCII_FONT_HEIGHT * 3, turn_number % 10 + '0');
9D002930  93C3002C   LBU V1, 44(FP)
9D002934  3C02CCCC   LUI V0, -13108
9D002938  3442CCCD   ORI V0, V0, -13107
9D00293C  00620019   MULTU 0, V1, V0
9D002940  00001010   MFHI V0
9D002944  000210C2   SRL V0, V0, 3
9D002948  00021040   SLL V0, V0, 1
9D00294C  00022080   SLL A0, V0, 2
9D002950  00441021   ADDU V0, V0, A0
9D002954  00621023   SUBU V0, V1, V0
9D002958  304200FF   ANDI V0, V0, 255
9D00295C  24420030   ADDIU V0, V0, 48
9D002960  304200FF   ANDI V0, V0, 255
9D002964  7C021420   SEB V0, V0
9D002968  8FC40010   LW A0, 16(FP)
9D00296C  24050018   ADDIU A1, ZERO, 24
9D002970  00403021   ADDU A2, V0, ZERO
9D002974  0F40089E   JAL OledDrawChar
9D002978  00000000   NOP
104:                     x -= ASCII_FONT_WIDTH;
9D00297C  8FC20010   LW V0, 16(FP)
9D002980  2442FFFA   ADDIU V0, V0, -6
9D002984  AFC20010   SW V0, 16(FP)
105:                     turn_number /= 10;
9D002988  93C3002C   LBU V1, 44(FP)
9D00298C  3C02CCCC   LUI V0, -13108
9D002990  3442CCCD   ORI V0, V0, -13107
9D002994  00620019   MULTU 0, V1, V0
9D002998  00001010   MFHI V0
9D00299C  000210C2   SRL V0, V0, 3
9D0029A0  A3C2002C   SB V0, 44(FP)
106:                     OledDrawChar(x, ASCII_FONT_HEIGHT * 3, turn_number % 10 + '0');
9D0029A4  93C3002C   LBU V1, 44(FP)
9D0029A8  3C02CCCC   LUI V0, -13108
9D0029AC  3442CCCD   ORI V0, V0, -13107
9D0029B0  00620019   MULTU 0, V1, V0
9D0029B4  00001010   MFHI V0
9D0029B8  000210C2   SRL V0, V0, 3
9D0029BC  00021040   SLL V0, V0, 1
9D0029C0  00022080   SLL A0, V0, 2
9D0029C4  00441021   ADDU V0, V0, A0
9D0029C8  00621023   SUBU V0, V1, V0
9D0029CC  304200FF   ANDI V0, V0, 255
9D0029D0  24420030   ADDIU V0, V0, 48
9D0029D4  304200FF   ANDI V0, V0, 255
9D0029D8  7C021420   SEB V0, V0
9D0029DC  8FC40010   LW A0, 16(FP)
9D0029E0  24050018   ADDIU A1, ZERO, 24
9D0029E4  00403021   ADDU A2, V0, ZERO
9D0029E8  0F40089E   JAL OledDrawChar
9D0029EC  00000000   NOP
107:                 
108:                     OledUpdate();
9D0029F0  0F400A03   JAL OledUpdate
9D0029F4  00000000   NOP
109:                 }
9D0029F8  03C0E821   ADDU SP, FP, ZERO
9D0029FC  8FBF001C   LW RA, 28(SP)
9D002A00  8FBE0018   LW FP, 24(SP)
9D002A04  27BD0020   ADDIU SP, SP, 32
9D002A08  03E00008   JR RA
9D002A0C  00000000   NOP
110:                 
111:                 /**
112:                  * Draw the given player's grid at the given x-coordinate.
113:                  */
114:                 void _FieldOledDrawField(const Field *f, int xOffset)
115:                 {
9D002A10  27BDFFD0   ADDIU SP, SP, -48
9D002A14  AFBF002C   SW RA, 44(SP)
9D002A18  AFBE0028   SW FP, 40(SP)
9D002A1C  03A0F021   ADDU FP, SP, ZERO
9D002A20  AFC40030   SW A0, 48(FP)
9D002A24  AFC50034   SW A1, 52(FP)
116:                     int i;
117:                     int finalCol = 10 * 5 + 2;
9D002A28  24020034   ADDIU V0, ZERO, 52
9D002A2C  AFC20018   SW V0, 24(FP)
118:                 
119:                     int finalRowOffset = (OLED_DRIVER_PIXEL_ROWS / OLED_DRIVER_BUFFER_LINE_HEIGHT - 1) *
9D002A30  24020180   ADDIU V0, ZERO, 384
9D002A34  AFC2001C   SW V0, 28(FP)
120:                             OLED_DRIVER_PIXEL_COLUMNS;
121:                 
122:                     // Draw the horizontal grid borders.
123:                     for (i = 0; i < finalCol; ++i) {
9D002A38  AFC00010   SW ZERO, 16(FP)
9D002A3C  0B400AB9   J 0x9D002AE4
9D002A40  00000000   NOP
9D002AD8  8FC20010   LW V0, 16(FP)
9D002ADC  24420001   ADDIU V0, V0, 1
9D002AE0  AFC20010   SW V0, 16(FP)
9D002AE4  8FC30010   LW V1, 16(FP)
9D002AE8  8FC20018   LW V0, 24(FP)
9D002AEC  0062102A   SLT V0, V1, V0
9D002AF0  1440FFD4   BNE V0, ZERO, 0x9D002A44
9D002AF4  00000000   NOP
124:                         rgbOledBmp[xOffset + i] |= 1;
9D002A44  8FC30034   LW V1, 52(FP)
9D002A48  8FC20010   LW V0, 16(FP)
9D002A4C  00622021   ADDU A0, V1, V0
9D002A50  8FC30034   LW V1, 52(FP)
9D002A54  8FC20010   LW V0, 16(FP)
9D002A58  00621821   ADDU V1, V1, V0
9D002A5C  3C02A000   LUI V0, -24576
9D002A60  24420220   ADDIU V0, V0, 544
9D002A64  00621021   ADDU V0, V1, V0
9D002A68  90420000   LBU V0, 0(V0)
9D002A6C  34420001   ORI V0, V0, 1
9D002A70  304300FF   ANDI V1, V0, 255
9D002A74  3C02A000   LUI V0, -24576
9D002A78  24420220   ADDIU V0, V0, 544
9D002A7C  00821021   ADDU V0, A0, V0
9D002A80  A0430000   SB V1, 0(V0)
125:                         rgbOledBmp[finalRowOffset + xOffset + i] |= 0x80;
9D002A84  8FC3001C   LW V1, 28(FP)
9D002A88  8FC20034   LW V0, 52(FP)
9D002A8C  00621821   ADDU V1, V1, V0
9D002A90  8FC20010   LW V0, 16(FP)
9D002A94  00622021   ADDU A0, V1, V0
9D002A98  8FC3001C   LW V1, 28(FP)
9D002A9C  8FC20034   LW V0, 52(FP)
9D002AA0  00621821   ADDU V1, V1, V0
9D002AA4  8FC20010   LW V0, 16(FP)
9D002AA8  00621821   ADDU V1, V1, V0
9D002AAC  3C02A000   LUI V0, -24576
9D002AB0  24420220   ADDIU V0, V0, 544
9D002AB4  00621021   ADDU V0, V1, V0
9D002AB8  90430000   LBU V1, 0(V0)
9D002ABC  2402FF80   ADDIU V0, ZERO, -128
9D002AC0  00621025   OR V0, V1, V0
9D002AC4  304300FF   ANDI V1, V0, 255
9D002AC8  3C02A000   LUI V0, -24576
9D002ACC  24420220   ADDIU V0, V0, 544
9D002AD0  00821021   ADDU V0, A0, V0
9D002AD4  A0430000   SB V1, 0(V0)
126:                     }
127:                     // Draw the vertical grid borders.
128:                     for (i = 0; i < OLED_DRIVER_PIXEL_ROWS / OLED_DRIVER_BUFFER_LINE_HEIGHT; ++i) {
9D002AF8  AFC00010   SW ZERO, 16(FP)
9D002AFC  0B400AD9   J 0x9D002B64
9D002B00  00000000   NOP
9D002B58  8FC20010   LW V0, 16(FP)
9D002B5C  24420001   ADDIU V0, V0, 1
9D002B60  AFC20010   SW V0, 16(FP)
9D002B64  8FC20010   LW V0, 16(FP)
9D002B68  28420004   SLTI V0, V0, 4
9D002B6C  1440FFE5   BNE V0, ZERO, 0x9D002B04
9D002B70  00000000   NOP
129:                         rgbOledBmp[i * OLED_DRIVER_PIXEL_COLUMNS + xOffset + 0] = 0xFF;
9D002B04  8FC20010   LW V0, 16(FP)
9D002B08  000219C0   SLL V1, V0, 7
9D002B0C  8FC20034   LW V0, 52(FP)
9D002B10  00621821   ADDU V1, V1, V0
9D002B14  3C02A000   LUI V0, -24576
9D002B18  24420220   ADDIU V0, V0, 544
9D002B1C  00621021   ADDU V0, V1, V0
9D002B20  2403FFFF   ADDIU V1, ZERO, -1
9D002B24  A0430000   SB V1, 0(V0)
130:                         rgbOledBmp[i * OLED_DRIVER_PIXEL_COLUMNS + xOffset + finalCol - 1] = 0xFF;
9D002B28  8FC20010   LW V0, 16(FP)
9D002B2C  000219C0   SLL V1, V0, 7
9D002B30  8FC20034   LW V0, 52(FP)
9D002B34  00621821   ADDU V1, V1, V0
9D002B38  8FC20018   LW V0, 24(FP)
9D002B3C  00621021   ADDU V0, V1, V0
9D002B40  2443FFFF   ADDIU V1, V0, -1
9D002B44  3C02A000   LUI V0, -24576
9D002B48  24420220   ADDIU V0, V0, 544
9D002B4C  00621021   ADDU V0, V1, V0
9D002B50  2403FFFF   ADDIU V1, ZERO, -1
9D002B54  A0430000   SB V1, 0(V0)
131:                     }
132:                 
133:                     // Draw each item in the grid.
134:                     int yOffset = 2;
9D002B74  24020002   ADDIU V0, ZERO, 2
9D002B78  AFC20020   SW V0, 32(FP)
135:                     xOffset += 1;
9D002B7C  8FC20034   LW V0, 52(FP)
9D002B80  24420001   ADDIU V0, V0, 1
9D002B84  AFC20034   SW V0, 52(FP)
136:                     for (i = 0; i < FIELD_COLS; ++i) {
9D002B88  AFC00010   SW ZERO, 16(FP)
9D002B8C  0B400B0C   J 0x9D002C30
9D002B90  00000000   NOP
9D002C24  8FC20010   LW V0, 16(FP)
9D002C28  24420001   ADDIU V0, V0, 1
9D002C2C  AFC20010   SW V0, 16(FP)
9D002C30  8FC20010   LW V0, 16(FP)
9D002C34  2842000A   SLTI V0, V0, 10
9D002C38  1440FFD6   BNE V0, ZERO, .LBB2
9D002C3C  00000000   NOP
137:                         int j;
138:                         for (j = 0; j < FIELD_ROWS; ++j) {
9D002B94  AFC00014   SW ZERO, 20(FP)
9D002B98  0B400B05   J 0x9D002C14
9D002B9C  00000000   NOP
9D002C08  8FC20014   LW V0, 20(FP)
9D002C0C  24420001   ADDIU V0, V0, 1
9D002C10  AFC20014   SW V0, 20(FP)
9D002C14  8FC20014   LW V0, 20(FP)
9D002C18  28420006   SLTI V0, V0, 6
9D002C1C  1440FFE0   BNE V0, ZERO, 0x9D002BA0
9D002C20  00000000   NOP
139:                             _FieldOledDrawSymbol(xOffset + 1 + 5 * i, yOffset + 5 * j, f->grid[j][i]);
9D002BA0  8FC20034   LW V0, 52(FP)
9D002BA4  24440001   ADDIU A0, V0, 1
9D002BA8  8FC30010   LW V1, 16(FP)
9D002BAC  00601021   ADDU V0, V1, ZERO
9D002BB0  00021080   SLL V0, V0, 2
9D002BB4  00431021   ADDU V0, V0, V1
9D002BB8  00822021   ADDU A0, A0, V0
9D002BBC  8FC30014   LW V1, 20(FP)
9D002BC0  00601021   ADDU V0, V1, ZERO
9D002BC4  00021080   SLL V0, V0, 2
9D002BC8  00431821   ADDU V1, V0, V1
9D002BCC  8FC20020   LW V0, 32(FP)
9D002BD0  00621821   ADDU V1, V1, V0
9D002BD4  8FC50030   LW A1, 48(FP)
9D002BD8  8FC20014   LW V0, 20(FP)
9D002BDC  00021040   SLL V0, V0, 1
9D002BE0  00023080   SLL A2, V0, 2
9D002BE4  00461021   ADDU V0, V0, A2
9D002BE8  8FC60010   LW A2, 16(FP)
9D002BEC  00461021   ADDU V0, V0, A2
9D002BF0  00A21021   ADDU V0, A1, V0
9D002BF4  90420000   LBU V0, 0(V0)
9D002BF8  00602821   ADDU A1, V1, ZERO
9D002BFC  00403021   ADDU A2, V0, ZERO
9D002C00  0F400B16   JAL _FieldOledDrawSymbol
9D002C04  00000000   NOP
140:                         }
141:                     }
142:                 }
9D002C40  03C0E821   ADDU SP, FP, ZERO
9D002C44  8FBF002C   LW RA, 44(SP)
9D002C48  8FBE0028   LW FP, 40(SP)
9D002C4C  27BD0030   ADDIU SP, SP, 48
9D002C50  03E00008   JR RA
9D002C54  00000000   NOP
143:                 
144:                 /**
145:                  * Draw the desired symbol at the given x/y coordinates.
146:                  */
147:                 uint8_t _FieldOledDrawSymbol(int x, int y, SquareStatus s)
148:                 {
9D002C58  27BDFFC0   ADDIU SP, SP, -64
9D002C5C  AFBE003C   SW FP, 60(SP)
9D002C60  03A0F021   ADDU FP, SP, ZERO
9D002C64  AFC40040   SW A0, 64(FP)
9D002C68  AFC50044   SW A1, 68(FP)
9D002C6C  AFC60048   SW A2, 72(FP)
149:                     if (x < OLED_DRIVER_PIXEL_COLUMNS - FIELD_SYMBOL_WIDTH && y < OLED_DRIVER_PIXEL_ROWS - FIELD_SYMBOL_HEIGHT) {
9D002C70  8FC20040   LW V0, 64(FP)
9D002C74  2842007D   SLTI V0, V0, 125
9D002C78  104000B1   BEQ V0, ZERO, .LBE6, .LBE3
9D002C7C  00000000   NOP
9D002C80  8FC20044   LW V0, 68(FP)
9D002C84  2842001C   SLTI V0, V0, 28
9D002C88  104000AD   BEQ V0, ZERO, .LBE6, .LBE3
9D002C8C  00000000   NOP
150:                         // Now first determine the columns and rows of the OLED bits that need to be modified
151:                         int rowMin, rowMax, colMin, colMax;
152:                         rowMin = y / OLED_DRIVER_BUFFER_LINE_HEIGHT;
9D002C90  8FC20044   LW V0, 68(FP)
9D002C94  24430007   ADDIU V1, V0, 7
9D002C98  28440000   SLTI A0, V0, 0
9D002C9C  0064100B   MOVN V0, V1, A0
9D002CA0  000210C3   SRA V0, V0, 3
9D002CA4  AFC20008   SW V0, 8(FP)
153:                         int rowY = y % OLED_DRIVER_BUFFER_LINE_HEIGHT;
9D002CA8  8FC30044   LW V1, 68(FP)
9D002CAC  000317C3   SRA V0, V1, 31
9D002CB0  00021742   SRL V0, V0, 29
9D002CB4  00621821   ADDU V1, V1, V0
9D002CB8  30630007   ANDI V1, V1, 7
9D002CBC  00621023   SUBU V0, V1, V0
9D002CC0  AFC2000C   SW V0, 12(FP)
154:                         rowMax = (y + FIELD_SYMBOL_HEIGHT) / OLED_DRIVER_BUFFER_LINE_HEIGHT;
9D002CC4  8FC20044   LW V0, 68(FP)
9D002CC8  24420004   ADDIU V0, V0, 4
9D002CCC  24430007   ADDIU V1, V0, 7
9D002CD0  28440000   SLTI A0, V0, 0
9D002CD4  0064100B   MOVN V0, V1, A0
9D002CD8  000210C3   SRA V0, V0, 3
9D002CDC  AFC20010   SW V0, 16(FP)
155:                         colMin = x;
9D002CE0  8FC20040   LW V0, 64(FP)
9D002CE4  AFC20014   SW V0, 20(FP)
156:                         colMax = x + FIELD_SYMBOL_WIDTH;
9D002CE8  8FC20040   LW V0, 64(FP)
9D002CEC  24420003   ADDIU V0, V0, 3
9D002CF0  AFC20018   SW V0, 24(FP)
157:                         {
158:                             // Generate a positive mask for where in the column the new symbol will be drawn.
159:                             int colMask = ((1 << FIELD_SYMBOL_HEIGHT) - 1) << rowY;
9D002CF4  2403000F   ADDIU V1, ZERO, 15
9D002CF8  8FC2000C   LW V0, 12(FP)
9D002CFC  00431004   SLLV V0, V1, V0
9D002D00  AFC2001C   SW V0, 28(FP)
160:                             int j;
161:                             for (j = 0; j < colMax - colMin; ++j) {
9D002D04  AFC00000   SW ZERO, 0(FP)
9D002D08  0B400B7A   J 0x9D002DE8
9D002D0C  00000000   NOP
9D002DDC  8FC20000   LW V0, 0(FP)
9D002DE0  24420001   ADDIU V0, V0, 1
9D002DE4  AFC20000   SW V0, 0(FP)
9D002DE8  8FC30018   LW V1, 24(FP)
9D002DEC  8FC20014   LW V0, 20(FP)
9D002DF0  00621823   SUBU V1, V1, V0
9D002DF4  8FC20000   LW V0, 0(FP)
9D002DF8  0043102A   SLT V0, V0, V1
9D002DFC  1440FFC4   BNE V0, ZERO, .LBB5
9D002E00  00000000   NOP
162:                                 int oledCol = colMin + j;
9D002D10  8FC30014   LW V1, 20(FP)
9D002D14  8FC20000   LW V0, 0(FP)
9D002D18  00621021   ADDU V0, V1, V0
9D002D1C  AFC20020   SW V0, 32(FP)
163:                                 uint8_t newCharCol = rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
9D002D20  8FC20008   LW V0, 8(FP)
9D002D24  000219C0   SLL V1, V0, 7
9D002D28  8FC20020   LW V0, 32(FP)
9D002D2C  00621821   ADDU V1, V1, V0
9D002D30  3C02A000   LUI V0, -24576
9D002D34  24420220   ADDIU V0, V0, 544
9D002D38  00621021   ADDU V0, V1, V0
9D002D3C  90420000   LBU V0, 0(V0)
9D002D40  7C021C20   SEB V1, V0
9D002D44  8FC2001C   LW V0, 28(FP)
9D002D48  7C021420   SEB V0, V0
9D002D4C  00021027   NOR V0, ZERO, V0
9D002D50  7C021420   SEB V0, V0
9D002D54  00621024   AND V0, V1, V0
9D002D58  7C021420   SEB V0, V0
9D002D5C  A3C20024   SB V0, 36(FP)
164:                                 // Make sure we always grab from the top part of the character.
165:                                 newCharCol |= (gridSymbols[(int) s][j] & (colMask >> rowY)) << rowY;
9D002D60  8FC30048   LW V1, 72(FP)
9D002D64  3C049D00   LUI A0, -25344
9D002D68  00601021   ADDU V0, V1, ZERO
9D002D6C  00021040   SLL V0, V0, 1
9D002D70  00431021   ADDU V0, V0, V1
9D002D74  8FC30000   LW V1, 0(FP)
9D002D78  00431821   ADDU V1, V0, V1
9D002D7C  2482697C   ADDIU V0, A0, 27004
9D002D80  00621021   ADDU V0, V1, V0
9D002D84  90420000   LBU V0, 0(V0)
9D002D88  00401821   ADDU V1, V0, ZERO
9D002D8C  8FC4001C   LW A0, 28(FP)
9D002D90  8FC2000C   LW V0, 12(FP)
9D002D94  00441007   SRAV V0, A0, V0
9D002D98  00621824   AND V1, V1, V0
9D002D9C  8FC2000C   LW V0, 12(FP)
9D002DA0  00431004   SLLV V0, V1, V0
9D002DA4  7C021C20   SEB V1, V0
9D002DA8  83C20024   LB V0, 36(FP)
9D002DAC  00621025   OR V0, V1, V0
9D002DB0  7C021420   SEB V0, V0
9D002DB4  A3C20024   SB V0, 36(FP)
166:                                 rgbOledBmp[rowMin * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
9D002DB8  8FC20008   LW V0, 8(FP)
9D002DBC  000219C0   SLL V1, V0, 7
9D002DC0  8FC20020   LW V0, 32(FP)
9D002DC4  00621821   ADDU V1, V1, V0
9D002DC8  3C02A000   LUI V0, -24576
9D002DCC  24420220   ADDIU V0, V0, 544
9D002DD0  00621021   ADDU V0, V1, V0
9D002DD4  93C30024   LBU V1, 36(FP)
9D002DD8  A0430000   SB V1, 0(V0)
167:                             }
168:                         }
169:                         if (rowMax > rowMin) {
9D002E04  8FC30010   LW V1, 16(FP)
9D002E08  8FC20008   LW V0, 8(FP)
9D002E0C  0043102A   SLT V0, V0, V1
9D002E10  1040004B   BEQ V0, ZERO, .LBE6, .LBE3
9D002E14  00000000   NOP
170:                             // Generate a positive mask for where in the column the new symbol will be drawn.
171:                             // Since we need the lower portion of the symbol, we recalculate its height.
172:                             int colMask = ((1 << FIELD_SYMBOL_HEIGHT) - 1) >> (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
9D002E18  24030008   ADDIU V1, ZERO, 8
9D002E1C  8FC2000C   LW V0, 12(FP)
9D002E20  00621023   SUBU V0, V1, V0
9D002E24  2403000F   ADDIU V1, ZERO, 15
9D002E28  00431007   SRAV V0, V1, V0
9D002E2C  AFC20028   SW V0, 40(FP)
173:                             int j;
174:                             for (j = 0; j < colMax - colMin; ++j) {
9D002E30  AFC00004   SW ZERO, 4(FP)
9D002E34  0B400BC9   J 0x9D002F24
9D002E38  00000000   NOP
9D002F18  8FC20004   LW V0, 4(FP)
9D002F1C  24420001   ADDIU V0, V0, 1
9D002F20  AFC20004   SW V0, 4(FP)
9D002F24  8FC30018   LW V1, 24(FP)
9D002F28  8FC20014   LW V0, 20(FP)
9D002F2C  00621823   SUBU V1, V1, V0
9D002F30  8FC20004   LW V0, 4(FP)
9D002F34  0043102A   SLT V0, V0, V1
9D002F38  1440FFC0   BNE V0, ZERO, .LBB7
9D002F3C  00000000   NOP
175:                                 int oledCol = colMin + j;
9D002E3C  8FC30014   LW V1, 20(FP)
9D002E40  8FC20004   LW V0, 4(FP)
9D002E44  00621021   ADDU V0, V1, V0
9D002E48  AFC2002C   SW V0, 44(FP)
176:                                 uint8_t newCharCol = rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] & ~colMask;
9D002E4C  8FC20010   LW V0, 16(FP)
9D002E50  000219C0   SLL V1, V0, 7
9D002E54  8FC2002C   LW V0, 44(FP)
9D002E58  00621821   ADDU V1, V1, V0
9D002E5C  3C02A000   LUI V0, -24576
9D002E60  24420220   ADDIU V0, V0, 544
9D002E64  00621021   ADDU V0, V1, V0
9D002E68  90420000   LBU V0, 0(V0)
9D002E6C  7C021C20   SEB V1, V0
9D002E70  8FC20028   LW V0, 40(FP)
9D002E74  7C021420   SEB V0, V0
9D002E78  00021027   NOR V0, ZERO, V0
9D002E7C  7C021420   SEB V0, V0
9D002E80  00621024   AND V0, V1, V0
9D002E84  7C021420   SEB V0, V0
9D002E88  A3C20030   SB V0, 48(FP)
177:                                 // Make sure we grab the proper part of the character from the font.
178:                                 newCharCol |= (gridSymbols[(int) s][j] & (colMask << (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY))) >>
9D002E8C  8FC30048   LW V1, 72(FP)
9D002E90  3C049D00   LUI A0, -25344
9D002E94  00601021   ADDU V0, V1, ZERO
9D002E98  00021040   SLL V0, V0, 1
9D002E9C  00431021   ADDU V0, V0, V1
9D002EA0  8FC30004   LW V1, 4(FP)
9D002EA4  00431821   ADDU V1, V0, V1
9D002EA8  2482697C   ADDIU V0, A0, 27004
9D002EAC  00621021   ADDU V0, V1, V0
9D002EB0  90420000   LBU V0, 0(V0)
9D002EB4  00401821   ADDU V1, V0, ZERO
9D002EB8  24040008   ADDIU A0, ZERO, 8
9D002EBC  8FC2000C   LW V0, 12(FP)
9D002EC0  00821023   SUBU V0, A0, V0
9D002EC4  8FC40028   LW A0, 40(FP)
9D002EC8  00441004   SLLV V0, A0, V0
9D002ECC  00621824   AND V1, V1, V0
9D002EDC  00431007   SRAV V0, V1, V0
9D002EE0  7C021C20   SEB V1, V0
9D002EE4  83C20030   LB V0, 48(FP)
9D002EE8  00621025   OR V0, V1, V0
9D002EEC  7C021420   SEB V0, V0
9D002EF0  A3C20030   SB V0, 48(FP)
179:                                         (OLED_DRIVER_BUFFER_LINE_HEIGHT - rowY);
9D002ED0  24040008   ADDIU A0, ZERO, 8
9D002ED4  8FC2000C   LW V0, 12(FP)
9D002ED8  00821023   SUBU V0, A0, V0
180:                                 rgbOledBmp[rowMax * OLED_DRIVER_PIXEL_COLUMNS + oledCol] = newCharCol;
9D002EF4  8FC20010   LW V0, 16(FP)
9D002EF8  000219C0   SLL V1, V0, 7
9D002EFC  8FC2002C   LW V0, 44(FP)
9D002F00  00621821   ADDU V1, V1, V0
9D002F04  3C02A000   LUI V0, -24576
9D002F08  24420220   ADDIU V0, V0, 544
9D002F0C  00621021   ADDU V0, V1, V0
9D002F10  93C30030   LBU V1, 48(FP)
9D002F14  A0430000   SB V1, 0(V0)
181:                             }
182:                         }
183:                     }
184:                 
185:                     return FALSE;
9D002F40  00001021   ADDU V0, ZERO, ZERO
186:                 }
9D002F44  03C0E821   ADDU SP, FP, ZERO
---  c:/users/kylez/cmpe13/lab09/lab9.x/circularbuffer.c  -----------------------------------------------
1:                   /*
2:                    * Copyright Bar Smith, Bryant Mairs 2012
3:                    *
4:                    * This program is free software: you can redistribute it and/or modify
5:                    * it under the terms of the GNU General Public License as published by
6:                    * the Free Software Foundation, either version 3 of the License, or
7:                    * (at your option) any later version.
8:                    *
9:                    * This program is distributed in the hope that it will be useful,
10:                   * but WITHOUT ANY WARRANTY; without even the implied warranty of
11:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
12:                   * GNU General Public License for more details.
13:                   *
14:                   * You should have received a copy of the GNU General Public License
15:                   * along with this program.  If not, see <http://www.gnu.org/licenses.
16:                   */
17:                   
18:                  /**
19:                   * @file   CircularBuffer.c
20:                   * @author Bar Smith
21:                   * @author Bryant Mairs
22:                   * @date   August, 2012
23:                   * @brief  Provides a circular buffer implementation for bytes and non-primitive datatypes.
24:                   *
25:                   * This circular buffer provides a single buffer interface for almost any situation necessary. It
26:                   * has been written for use with the dsPIC33f, but has been tested on x86.
27:                   *
28:                   * Unit testing has been completed on x86 by compiling with the UNIT_TEST_CIRCULAR_BUFFER macro.
29:                   * With gcc: `gcc CircularBuffer.c -DUNIT_TEST_CIRCULAR_BUFFER -Wall -g`
30:                   */
31:                  #include "CircularBuffer.h"
32:                  #include "BOARD.h"
33:                  
34:                  #include <stddef.h>
35:                  #include <stdint.h>
36:                  #include <stdlib.h>
37:                  #include <stdio.h>
38:                  
39:                  
40:                  int CB_Init(CircularBuffer *b, uint8_t *buffer, const uint16_t size)
41:                  {
9D0016E0  27BDFFF0   ADDIU SP, SP, -16
9D0016E4  AFBE000C   SW FP, 12(SP)
9D0016E8  03A0F021   ADDU FP, SP, ZERO
9D0016EC  AFC40010   SW A0, 16(FP)
9D0016F0  AFC50014   SW A1, 20(FP)
9D0016F4  00C01021   ADDU V0, A2, ZERO
9D0016F8  A7C20018   SH V0, 24(FP)
42:                  	// Check the validity of pointers.
43:                  	if (!buffer || !b) {
9D0016FC  8FC20014   LW V0, 20(FP)
9D001700  10400004   BEQ V0, ZERO, 0x9D001714
9D001704  00000000   NOP
9D001708  8FC20010   LW V0, 16(FP)
9D00170C  14400004   BNE V0, ZERO, 0x9D001720
9D001710  00000000   NOP
44:                  		return FALSE;
9D001714  00001021   ADDU V0, ZERO, ZERO
9D001718  0B4005EE   J 0x9D0017B8
9D00171C  00000000   NOP
45:                  	}
46:                  
47:                  	// Checks that the size is valid.
48:                  	if (size <= 1) {
9D001720  97C20018   LHU V0, 24(FP)
9D001724  2C420002   SLTIU V0, V0, 2
9D001728  10400004   BEQ V0, ZERO, 0x9D00173C
9D00172C  00000000   NOP
49:                  		return FALSE;
9D001730  00001021   ADDU V0, ZERO, ZERO
9D001734  0B4005EE   J 0x9D0017B8
9D001738  00000000   NOP
50:                  	}
51:                  
52:                  	// Store the buffer pointer and initialize it all to zero.
53:                  	// This is not necessary, but makes debugging easier.
54:                  	b->data = buffer;
9D00173C  8FC20010   LW V0, 16(FP)
9D001740  8FC30014   LW V1, 20(FP)
9D001744  AC43000C   SW V1, 12(V0)
55:                  	uint16_t i;
56:                  	for (i = 0; i < size; ++i) {
9D001748  A7C00000   SH ZERO, 0(FP)
9D00174C  0B4005DD   J 0x9D001774
9D001750  00000000   NOP
9D001768  97C20000   LHU V0, 0(FP)
9D00176C  24420001   ADDIU V0, V0, 1
9D001770  A7C20000   SH V0, 0(FP)
9D001774  97C30000   LHU V1, 0(FP)
9D001778  97C20018   LHU V0, 24(FP)
9D00177C  0062102B   SLTU V0, V1, V0
9D001780  1440FFF4   BNE V0, ZERO, 0x9D001754
9D001784  00000000   NOP
57:                  		b->data[i] = 0;
9D001754  8FC20010   LW V0, 16(FP)
9D001758  8C43000C   LW V1, 12(V0)
9D00175C  97C20000   LHU V0, 0(FP)
9D001760  00621021   ADDU V0, V1, V0
9D001764  A0400000   SB ZERO, 0(V0)
58:                  	}
59:                  
60:                  	// Initialize all variables. The only one of note is `empty`, which is initialized to TRUE.
61:                  	b->readIndex = 0;
9D001788  8FC20010   LW V0, 16(FP)
9D00178C  A4400000   SH ZERO, 0(V0)
62:                  	b->writeIndex = 0;
9D001790  8FC20010   LW V0, 16(FP)
9D001794  A4400002   SH ZERO, 2(V0)
63:                  	b->staticSize = size;
9D001798  8FC20010   LW V0, 16(FP)
9D00179C  97C30018   LHU V1, 24(FP)
9D0017A0  A4430004   SH V1, 4(V0)
64:                  	b->dataSize = 0;
9D0017A4  8FC20010   LW V0, 16(FP)
9D0017A8  A4400006   SH ZERO, 6(V0)
65:                  	b->overflowCount = 0;
9D0017AC  8FC20010   LW V0, 16(FP)
9D0017B0  A0400008   SB ZERO, 8(V0)
66:                  
67:                  	return TRUE;
9D0017B4  24020001   ADDIU V0, ZERO, 1
68:                  }
9D0017B8  03C0E821   ADDU SP, FP, ZERO
9D0017BC  8FBE000C   LW FP, 12(SP)
9D0017C0  27BD0010   ADDIU SP, SP, 16
9D0017C4  03E00008   JR RA
9D0017C8  00000000   NOP
69:                  
70:                  int CB_ReadByte(CircularBuffer *b, uint8_t *outData)
71:                  {
9D0017CC  27BDFFF8   ADDIU SP, SP, -8
9D0017D0  AFBE0004   SW FP, 4(SP)
9D0017D4  03A0F021   ADDU FP, SP, ZERO
9D0017D8  AFC40008   SW A0, 8(FP)
9D0017DC  AFC5000C   SW A1, 12(FP)
72:                  	if (b) {
9D0017E0  8FC20008   LW V0, 8(FP)
9D0017E4  10400041   BEQ V0, ZERO, 0x9D0018EC
9D0017E8  00000000   NOP
73:                  		if (b->dataSize) {
9D0017EC  8FC20008   LW V0, 8(FP)
9D0017F0  94420006   LHU V0, 6(V0)
9D0017F4  1040003D   BEQ V0, ZERO, 0x9D0018EC
9D0017F8  00000000   NOP
74:                  			//copys the last element from the buffer to data
75:                  			*outData = b->data[b->readIndex];
9D0017FC  8FC20008   LW V0, 8(FP)
9D001800  8C43000C   LW V1, 12(V0)
9D001804  8FC20008   LW V0, 8(FP)
9D001808  94420000   LHU V0, 0(V0)
9D00180C  00621021   ADDU V0, V1, V0
9D001810  90430000   LBU V1, 0(V0)
9D001814  8FC2000C   LW V0, 12(FP)
9D001818  A0430000   SB V1, 0(V0)
76:                  			//sets the buffer empty if there was only one element in it
77:                  			if (b->dataSize == 1) {
9D00181C  8FC20008   LW V0, 8(FP)
9D001820  94430006   LHU V1, 6(V0)
9D001824  24020001   ADDIU V0, ZERO, 1
9D001828  14620015   BNE V1, V0, 0x9D001880
9D00182C  00000000   NOP
78:                  				//checks for wrap around
79:                  				b->readIndex = b->readIndex < (b->staticSize - 1)?b->readIndex + 1:0;
9D001830  8FC20008   LW V0, 8(FP)
9D001834  94420000   LHU V0, 0(V0)
9D001838  00401821   ADDU V1, V0, ZERO
9D00183C  8FC20008   LW V0, 8(FP)
9D001840  94420004   LHU V0, 4(V0)
9D001844  2442FFFF   ADDIU V0, V0, -1
9D001848  0062102A   SLT V0, V1, V0
9D00184C  10400007   BEQ V0, ZERO, 0x9D00186C
9D001850  00000000   NOP
9D001854  8FC20008   LW V0, 8(FP)
9D001858  94420000   LHU V0, 0(V0)
9D00185C  24420001   ADDIU V0, V0, 1
9D001860  3042FFFF   ANDI V0, V0, -1
9D001864  0B40061C   J 0x9D001870
9D001868  00000000   NOP
9D00186C  00001021   ADDU V0, ZERO, ZERO
9D001870  8FC30008   LW V1, 8(FP)
9D001874  A4620000   SH V0, 0(V1)
9D001878  0B400632   J 0x9D0018C8
9D00187C  00000000   NOP
80:                  			} else {
81:                  				//checks for wrap around and moves indicies
82:                  				b->readIndex = b->readIndex < (b->staticSize - 1)?b->readIndex + 1:0;
9D001880  8FC20008   LW V0, 8(FP)
9D001884  94420000   LHU V0, 0(V0)
9D001888  00401821   ADDU V1, V0, ZERO
9D00188C  8FC20008   LW V0, 8(FP)
9D001890  94420004   LHU V0, 4(V0)
9D001894  2442FFFF   ADDIU V0, V0, -1
9D001898  0062102A   SLT V0, V1, V0
9D00189C  10400007   BEQ V0, ZERO, 0x9D0018BC
9D0018A0  00000000   NOP
9D0018A4  8FC20008   LW V0, 8(FP)
9D0018A8  94420000   LHU V0, 0(V0)
9D0018AC  24420001   ADDIU V0, V0, 1
9D0018B0  3042FFFF   ANDI V0, V0, -1
9D0018B4  0B400630   J 0x9D0018C0
9D0018B8  00000000   NOP
9D0018BC  00001021   ADDU V0, ZERO, ZERO
9D0018C0  8FC30008   LW V1, 8(FP)
9D0018C4  A4620000   SH V0, 0(V1)
83:                  			}
84:                  			--b->dataSize;
9D0018C8  8FC20008   LW V0, 8(FP)
9D0018CC  94420006   LHU V0, 6(V0)
9D0018D0  2442FFFF   ADDIU V0, V0, -1
9D0018D4  3043FFFF   ANDI V1, V0, -1
9D0018D8  8FC20008   LW V0, 8(FP)
9D0018DC  A4430006   SH V1, 6(V0)
85:                  			return TRUE;
9D0018E0  24020001   ADDIU V0, ZERO, 1
9D0018E4  0B40063C   J 0x9D0018F0
9D0018E8  00000000   NOP
86:                  		}
87:                  	}
88:                  	return FALSE;
9D0018EC  00001021   ADDU V0, ZERO, ZERO
89:                  }
9D0018F0  03C0E821   ADDU SP, FP, ZERO
9D0018F4  8FBE0004   LW FP, 4(SP)
9D0018F8  27BD0008   ADDIU SP, SP, 8
9D0018FC  03E00008   JR RA
9D001900  00000000   NOP
90:                  
91:                  int CB_ReadMany(CircularBuffer *b, void *outData, uint16_t size)
92:                  {
9D001904  27BDFFF0   ADDIU SP, SP, -16
9D001908  AFBE000C   SW FP, 12(SP)
9D00190C  03A0F021   ADDU FP, SP, ZERO
9D001910  AFC40010   SW A0, 16(FP)
9D001914  AFC50014   SW A1, 20(FP)
9D001918  00C01021   ADDU V0, A2, ZERO
9D00191C  A7C20018   SH V0, 24(FP)
93:                  	int16_t i;
94:                  	if (b && outData) {
9D001920  8FC20010   LW V0, 16(FP)
9D001924  1040003E   BEQ V0, ZERO, .LBE2
9D001928  00000000   NOP
9D00192C  8FC20014   LW V0, 20(FP)
9D001930  1040003B   BEQ V0, ZERO, .LBE2
9D001934  00000000   NOP
95:                  		//cast data so that it can be used to ready bytes
96:                  		uint8_t *data_u = (uint8_t*)outData;
9D001938  8FC20014   LW V0, 20(FP)
9D00193C  AFC20004   SW V0, 4(FP)
97:                  		//check if there are enough items in the buffer to read
98:                  		if (b->dataSize >= size) {
9D001940  8FC20010   LW V0, 16(FP)
9D001944  94420006   LHU V0, 6(V0)
9D001948  97C30018   LHU V1, 24(FP)
9D00194C  0043102B   SLTU V0, V0, V1
9D001950  14400033   BNE V0, ZERO, .LBE2
9D001954  00000000   NOP
99:                  
100:                 			// And read the data.
101:                 			for (i = 0; i < size; ++i) {
9D001958  A7C00000   SH ZERO, 0(FP)
9D00195C  0B400679   J 0x9D0019E4
9D001960  00000000   NOP
9D0019D8  97C20000   LHU V0, 0(FP)
9D0019DC  24420001   ADDIU V0, V0, 1
9D0019E0  A7C20000   SH V0, 0(FP)
9D0019E4  87C30000   LH V1, 0(FP)
9D0019E8  97C20018   LHU V0, 24(FP)
9D0019EC  0062102A   SLT V0, V1, V0
9D0019F0  1440FFDC   BNE V0, ZERO, 0x9D001964
9D0019F4  00000000   NOP
102:                 				data_u[i] = b->data[b->readIndex];
9D001964  87C20000   LH V0, 0(FP)
9D001968  8FC30004   LW V1, 4(FP)
9D00196C  00621021   ADDU V0, V1, V0
9D001970  8FC30010   LW V1, 16(FP)
9D001974  8C64000C   LW A0, 12(V1)
9D001978  8FC30010   LW V1, 16(FP)
9D00197C  94630000   LHU V1, 0(V1)
9D001980  00831821   ADDU V1, A0, V1
9D001984  90630000   LBU V1, 0(V1)
9D001988  A0430000   SB V1, 0(V0)
103:                 
104:                 				// Update the readIndex taking into account wrap-around.
105:                 				if (b->readIndex < b->staticSize - 1) {
9D00198C  8FC20010   LW V0, 16(FP)
9D001990  94420000   LHU V0, 0(V0)
9D001994  00401821   ADDU V1, V0, ZERO
9D001998  8FC20010   LW V0, 16(FP)
9D00199C  94420004   LHU V0, 4(V0)
9D0019A0  2442FFFF   ADDIU V0, V0, -1
9D0019A4  0062102A   SLT V0, V1, V0
9D0019A8  10400009   BEQ V0, ZERO, 0x9D0019D0
9D0019AC  00000000   NOP
106:                 					++b->readIndex;
9D0019B0  8FC20010   LW V0, 16(FP)
9D0019B4  94420000   LHU V0, 0(V0)
9D0019B8  24420001   ADDIU V0, V0, 1
9D0019BC  3043FFFF   ANDI V1, V0, -1
9D0019C0  8FC20010   LW V0, 16(FP)
9D0019C4  A4430000   SH V1, 0(V0)
9D0019C8  0B400676   J 0x9D0019D8
9D0019CC  00000000   NOP
107:                 				} else {
108:                 					b->readIndex = 0;
9D0019D0  8FC20010   LW V0, 16(FP)
9D0019D4  A4400000   SH ZERO, 0(V0)
109:                 				}
110:                 			}
111:                 			b->dataSize -= size;
9D0019F8  8FC20010   LW V0, 16(FP)
9D0019FC  94430006   LHU V1, 6(V0)
9D001A00  97C20018   LHU V0, 24(FP)
9D001A04  00621023   SUBU V0, V1, V0
9D001A08  3043FFFF   ANDI V1, V0, -1
9D001A0C  8FC20010   LW V0, 16(FP)
9D001A10  A4430006   SH V1, 6(V0)
112:                 			return TRUE;
9D001A14  24020001   ADDIU V0, ZERO, 1
9D001A18  0B400689   J 0x9D001A24
9D001A1C  00000000   NOP
113:                 		}
114:                 	}
115:                 	return FALSE;
9D001A20  00001021   ADDU V0, ZERO, ZERO
116:                 }
9D001A24  03C0E821   ADDU SP, FP, ZERO
9D001A28  8FBE000C   LW FP, 12(SP)
9D001A2C  27BD0010   ADDIU SP, SP, 16
9D001A30  03E00008   JR RA
9D001A34  00000000   NOP
117:                 
118:                 int CB_WriteByte(CircularBuffer *b, uint8_t inData)
119:                 {
9D001A38  27BDFFF8   ADDIU SP, SP, -8
9D001A3C  AFBE0004   SW FP, 4(SP)
9D001A40  03A0F021   ADDU FP, SP, ZERO
9D001A44  AFC40008   SW A0, 8(FP)
9D001A48  00A01021   ADDU V0, A1, ZERO
9D001A4C  A3C2000C   SB V0, 12(FP)
120:                 	if (b) {
9D001A50  8FC20008   LW V0, 8(FP)
9D001A54  10400032   BEQ V0, ZERO, 0x9D001B20
9D001A58  00000000   NOP
121:                 		// If the buffer is full the overflow count is incremented and no data is written.
122:                 		if (b->dataSize == b->staticSize) {
9D001A5C  8FC20008   LW V0, 8(FP)
9D001A60  94430006   LHU V1, 6(V0)
9D001A64  8FC20008   LW V0, 8(FP)
9D001A68  94420004   LHU V0, 4(V0)
9D001A6C  1462000A   BNE V1, V0, 0x9D001A98
9D001A70  00000000   NOP
123:                 			++b->overflowCount;
9D001A74  8FC20008   LW V0, 8(FP)
9D001A78  90420008   LBU V0, 8(V0)
9D001A7C  24420001   ADDIU V0, V0, 1
9D001A80  304300FF   ANDI V1, V0, 255
9D001A84  8FC20008   LW V0, 8(FP)
9D001A88  A0430008   SB V1, 8(V0)
124:                 			return FALSE;
9D001A8C  00001021   ADDU V0, ZERO, ZERO
9D001A90  0B4006C9   J 0x9D001B24
9D001A94  00000000   NOP
125:                 		} else {
126:                 			b->data[b->writeIndex] = inData;
9D001A98  8FC20008   LW V0, 8(FP)
9D001A9C  8C43000C   LW V1, 12(V0)
9D001AA0  8FC20008   LW V0, 8(FP)
9D001AA4  94420002   LHU V0, 2(V0)
9D001AA8  00621021   ADDU V0, V1, V0
9D001AAC  93C3000C   LBU V1, 12(FP)
9D001AB0  A0430000   SB V1, 0(V0)
127:                 			// Now update the writeIndex taking into account wrap-around.
128:                 			b->writeIndex = b->writeIndex < (b->staticSize - 1) ? b->writeIndex + 1: 0;
9D001AB4  8FC20008   LW V0, 8(FP)
9D001AB8  94420002   LHU V0, 2(V0)
9D001ABC  00401821   ADDU V1, V0, ZERO
9D001AC0  8FC20008   LW V0, 8(FP)
9D001AC4  94420004   LHU V0, 4(V0)
9D001AC8  2442FFFF   ADDIU V0, V0, -1
9D001ACC  0062102A   SLT V0, V1, V0
9D001AD0  10400007   BEQ V0, ZERO, 0x9D001AF0
9D001AD4  00000000   NOP
9D001AD8  8FC20008   LW V0, 8(FP)
9D001ADC  94420002   LHU V0, 2(V0)
9D001AE0  24420001   ADDIU V0, V0, 1
9D001AE4  3042FFFF   ANDI V0, V0, -1
9D001AE8  0B4006BD   J 0x9D001AF4
9D001AEC  00000000   NOP
9D001AF0  00001021   ADDU V0, ZERO, ZERO
9D001AF4  8FC30008   LW V1, 8(FP)
9D001AF8  A4620002   SH V0, 2(V1)
129:                 			++b->dataSize;
9D001AFC  8FC20008   LW V0, 8(FP)
9D001B00  94420006   LHU V0, 6(V0)
9D001B04  24420001   ADDIU V0, V0, 1
9D001B08  3043FFFF   ANDI V1, V0, -1
9D001B0C  8FC20008   LW V0, 8(FP)
9D001B10  A4430006   SH V1, 6(V0)
130:                 			return TRUE;
9D001B14  24020001   ADDIU V0, ZERO, 1
9D001B18  0B4006C9   J 0x9D001B24
9D001B1C  00000000   NOP
131:                 		}
132:                 	}
133:                 	return FALSE;
9D001B20  00001021   ADDU V0, ZERO, ZERO
134:                 }
9D001B24  03C0E821   ADDU SP, FP, ZERO
9D001B28  8FBE0004   LW FP, 4(SP)
9D001B2C  27BD0008   ADDIU SP, SP, 8
9D001B30  03E00008   JR RA
9D001B34  00000000   NOP
135:                 
136:                 int CB_WriteMany(CircularBuffer *b, const void *inData, uint16_t size, uint8_t failEarly)
137:                 {
9D001B38  27BDFFE8   ADDIU SP, SP, -24
9D001B3C  AFBE0014   SW FP, 20(SP)
9D001B40  03A0F021   ADDU FP, SP, ZERO
9D001B44  AFC40018   SW A0, 24(FP)
9D001B48  AFC5001C   SW A1, 28(FP)
9D001B4C  00C01821   ADDU V1, A2, ZERO
9D001B50  00E01021   ADDU V0, A3, ZERO
9D001B54  A7C30020   SH V1, 32(FP)
9D001B58  A3C20024   SB V0, 36(FP)
138:                 	if (b && inData) {
9D001B5C  8FC20018   LW V0, 24(FP)
9D001B60  1040008D   BEQ V0, ZERO, .LBE5, .LBE3
9D001B64  00000000   NOP
9D001B68  8FC2001C   LW V0, 28(FP)
9D001B6C  1040008A   BEQ V0, ZERO, .LBE5, .LBE3
9D001B70  00000000   NOP
139:                 		uint8_t *data_u = (uint8_t*)inData;
9D001B74  8FC2001C   LW V0, 28(FP)
9D001B78  AFC20008   SW V0, 8(FP)
140:                 		//if the fail early value is set
141:                 		if (failEarly) {
9D001B7C  93C20024   LBU V0, 36(FP)
9D001B80  10400040   BEQ V0, ZERO, .LBE4, .LBB5
9D001B84  00000000   NOP
142:                 			//Checks to make sure there is enough space
143:                 			if (b->staticSize - b->dataSize < size) {
9D001B88  8FC20018   LW V0, 24(FP)
9D001B8C  94420004   LHU V0, 4(V0)
9D001B90  00401821   ADDU V1, V0, ZERO
9D001B94  8FC20018   LW V0, 24(FP)
9D001B98  94420006   LHU V0, 6(V0)
9D001B9C  00621823   SUBU V1, V1, V0
9D001BA0  97C20020   LHU V0, 32(FP)
9D001BA4  0062102A   SLT V0, V1, V0
9D001BA8  10400004   BEQ V0, ZERO, .LBB4
9D001BAC  00000000   NOP
144:                 				return FALSE;
9D001BB0  00001021   ADDU V0, ZERO, ZERO
9D001BB4  0B400767   J 0x9D001D9C
9D001BB8  00000000   NOP
145:                 			} else {
146:                 				int i = 0;
9D001BBC  AFC00000   SW ZERO, 0(FP)
147:                 				//runs size times
148:                 				while (i < size) {
9D001BC0  0B400711   J 0x9D001C44
9D001BC4  00000000   NOP
9D001C44  97C30020   LHU V1, 32(FP)
9D001C48  8FC20000   LW V0, 0(FP)
9D001C4C  0043102A   SLT V0, V0, V1
9D001C50  1440FFDD   BNE V0, ZERO, 0x9D001BC8
9D001C54  00000000   NOP
149:                 					//writes to the buffer
150:                 					b->data[b->writeIndex] = data_u[i];
9D001BC8  8FC20018   LW V0, 24(FP)
9D001BCC  8C43000C   LW V1, 12(V0)
9D001BD0  8FC20018   LW V0, 24(FP)
9D001BD4  94420002   LHU V0, 2(V0)
9D001BD8  00621021   ADDU V0, V1, V0
9D001BDC  8FC30000   LW V1, 0(FP)
9D001BE0  8FC40008   LW A0, 8(FP)
9D001BE4  00831821   ADDU V1, A0, V1
9D001BE8  90630000   LBU V1, 0(V1)
9D001BEC  A0430000   SB V1, 0(V0)
151:                 					++i;
9D001BF0  8FC20000   LW V0, 0(FP)
9D001BF4  24420001   ADDIU V0, V0, 1
9D001BF8  AFC20000   SW V0, 0(FP)
152:                 					//checks for wrap around and moves the indicies
153:                 					b->writeIndex = b->writeIndex < (b->staticSize - 1) ? b->writeIndex + 1: 0;
9D001BFC  8FC20018   LW V0, 24(FP)
9D001C00  94420002   LHU V0, 2(V0)
9D001C04  00401821   ADDU V1, V0, ZERO
9D001C08  8FC20018   LW V0, 24(FP)
9D001C0C  94420004   LHU V0, 4(V0)
9D001C10  2442FFFF   ADDIU V0, V0, -1
9D001C14  0062102A   SLT V0, V1, V0
9D001C18  10400007   BEQ V0, ZERO, 0x9D001C38
9D001C1C  00000000   NOP
9D001C20  8FC20018   LW V0, 24(FP)
9D001C24  94420002   LHU V0, 2(V0)
9D001C28  24420001   ADDIU V0, V0, 1
9D001C2C  3042FFFF   ANDI V0, V0, -1
9D001C30  0B40070F   J 0x9D001C3C
9D001C34  00000000   NOP
9D001C38  00001021   ADDU V0, ZERO, ZERO
9D001C3C  8FC30018   LW V1, 24(FP)
9D001C40  A4620002   SH V0, 2(V1)
154:                 				}
155:                 				b->dataSize += i;
9D001C58  8FC20018   LW V0, 24(FP)
9D001C5C  94430006   LHU V1, 6(V0)
9D001C60  8FC20000   LW V0, 0(FP)
9D001C64  3042FFFF   ANDI V0, V0, -1
9D001C68  00621021   ADDU V0, V1, V0
9D001C6C  3043FFFF   ANDI V1, V0, -1
9D001C70  8FC20018   LW V0, 24(FP)
9D001C74  A4430006   SH V1, 6(V0)
156:                 				return TRUE;
9D001C78  24020001   ADDIU V0, ZERO, 1
9D001C7C  0B400767   J 0x9D001D9C
9D001C80  00000000   NOP
157:                 			}
158:                 		}
159:                 		// Otherwise we try and write as much data as we can.
160:                 		else {
161:                 			int i = 0;
9D001C84  AFC00004   SW ZERO, 4(FP)
162:                 			while (i < size) {
9D001C88  0B40075E   J 0x9D001D78
9D001C8C  00000000   NOP
9D001D78  97C30020   LHU V1, 32(FP)
9D001D7C  8FC20004   LW V0, 4(FP)
9D001D80  0043102A   SLT V0, V0, V1
9D001D84  1440FFC2   BNE V0, ZERO, 0x9D001C90
9D001D88  00000000   NOP
163:                 				//if the buffer is full the overflow count is increased and FALSE is returned
164:                 				if (b->dataSize == b->staticSize) {
9D001C90  8FC20018   LW V0, 24(FP)
9D001C94  94430006   LHU V1, 6(V0)
9D001C98  8FC20018   LW V0, 24(FP)
9D001C9C  94420004   LHU V0, 4(V0)
9D001CA0  14620010   BNE V1, V0, 0x9D001CE4
9D001CA4  00000000   NOP
165:                 					b->overflowCount += (size - i);
9D001CA8  8FC20018   LW V0, 24(FP)
9D001CAC  90430008   LBU V1, 8(V0)
9D001CB0  97C20020   LHU V0, 32(FP)
9D001CB4  304400FF   ANDI A0, V0, 255
9D001CB8  8FC20004   LW V0, 4(FP)
9D001CBC  304200FF   ANDI V0, V0, 255
9D001CC0  00821023   SUBU V0, A0, V0
9D001CC4  304200FF   ANDI V0, V0, 255
9D001CC8  00621021   ADDU V0, V1, V0
9D001CCC  304300FF   ANDI V1, V0, 255
9D001CD0  8FC20018   LW V0, 24(FP)
9D001CD4  A0430008   SB V1, 8(V0)
166:                 					return FALSE;
9D001CD8  00001021   ADDU V0, ZERO, ZERO
9D001CDC  0B400767   J 0x9D001D9C
9D001CE0  00000000   NOP
167:                 				}
168:                 				//reads an element from the buffer to data
169:                 				b->data[b->writeIndex] = data_u[i];
9D001CE4  8FC20018   LW V0, 24(FP)
9D001CE8  8C43000C   LW V1, 12(V0)
9D001CEC  8FC20018   LW V0, 24(FP)
9D001CF0  94420002   LHU V0, 2(V0)
9D001CF4  00621021   ADDU V0, V1, V0
9D001CF8  8FC30004   LW V1, 4(FP)
9D001CFC  8FC40008   LW A0, 8(FP)
9D001D00  00831821   ADDU V1, A0, V1
9D001D04  90630000   LBU V1, 0(V1)
9D001D08  A0430000   SB V1, 0(V0)
170:                 				++i;
9D001D0C  8FC20004   LW V0, 4(FP)
9D001D10  24420001   ADDIU V0, V0, 1
9D001D14  AFC20004   SW V0, 4(FP)
171:                 				++b->dataSize;
9D001D18  8FC20018   LW V0, 24(FP)
9D001D1C  94420006   LHU V0, 6(V0)
9D001D20  24420001   ADDIU V0, V0, 1
9D001D24  3043FFFF   ANDI V1, V0, -1
9D001D28  8FC20018   LW V0, 24(FP)
9D001D2C  A4430006   SH V1, 6(V0)
172:                 				//move the indicies and check for wrap around
173:                 				b->writeIndex = (b->writeIndex < (b->staticSize - 1)) ? b->writeIndex + 1: 0;
9D001D30  8FC20018   LW V0, 24(FP)
9D001D34  94420002   LHU V0, 2(V0)
9D001D38  00401821   ADDU V1, V0, ZERO
9D001D3C  8FC20018   LW V0, 24(FP)
9D001D40  94420004   LHU V0, 4(V0)
9D001D44  2442FFFF   ADDIU V0, V0, -1
9D001D48  0062102A   SLT V0, V1, V0
9D001D4C  10400007   BEQ V0, ZERO, 0x9D001D6C
9D001D50  00000000   NOP
9D001D54  8FC20018   LW V0, 24(FP)
9D001D58  94420002   LHU V0, 2(V0)
9D001D5C  24420001   ADDIU V0, V0, 1
9D001D60  3042FFFF   ANDI V0, V0, -1
9D001D64  0B40075C   J 0x9D001D70
9D001D68  00000000   NOP
9D001D6C  00001021   ADDU V0, ZERO, ZERO
9D001D70  8FC30018   LW V1, 24(FP)
9D001D74  A4620002   SH V0, 2(V1)
174:                 			}
175:                 			return TRUE;
9D001D8C  24020001   ADDIU V0, ZERO, 1
9D001D90  0B400767   J 0x9D001D9C
9D001D94  00000000   NOP
176:                 		}
177:                 	}
178:                 	return FALSE;
9D001D98  00001021   ADDU V0, ZERO, ZERO
179:                 }
9D001D9C  03C0E821   ADDU SP, FP, ZERO
9D001DA0  8FBE0014   LW FP, 20(SP)
9D001DA4  27BD0018   ADDIU SP, SP, 24
9D001DA8  03E00008   JR RA
9D001DAC  00000000   NOP
180:                 
181:                 int CB_Peek(const CircularBuffer *b, uint8_t *outData)
182:                 {
9D001DB0  27BDFFF8   ADDIU SP, SP, -8
9D001DB4  AFBE0004   SW FP, 4(SP)
9D001DB8  03A0F021   ADDU FP, SP, ZERO
9D001DBC  AFC40008   SW A0, 8(FP)
9D001DC0  AFC5000C   SW A1, 12(FP)
183:                 	if (b) {
9D001DC4  8FC20008   LW V0, 8(FP)
9D001DC8  10400010   BEQ V0, ZERO, 0x9D001E0C
9D001DCC  00000000   NOP
184:                 		if (b->dataSize > 0) {
9D001DD0  8FC20008   LW V0, 8(FP)
9D001DD4  94420006   LHU V0, 6(V0)
9D001DD8  1040000C   BEQ V0, ZERO, 0x9D001E0C
9D001DDC  00000000   NOP
185:                 			*outData = b->data[b->readIndex];
9D001DE0  8FC20008   LW V0, 8(FP)
9D001DE4  8C43000C   LW V1, 12(V0)
9D001DE8  8FC20008   LW V0, 8(FP)
9D001DEC  94420000   LHU V0, 0(V0)
9D001DF0  00621021   ADDU V0, V1, V0
9D001DF4  90430000   LBU V1, 0(V0)
9D001DF8  8FC2000C   LW V0, 12(FP)
9D001DFC  A0430000   SB V1, 0(V0)
186:                 			return TRUE;
9D001E00  24020001   ADDIU V0, ZERO, 1
9D001E04  0B400784   J 0x9D001E10
9D001E08  00000000   NOP
187:                 		}
188:                 	}
189:                 	return FALSE;
9D001E0C  00001021   ADDU V0, ZERO, ZERO
190:                 }
9D001E10  03C0E821   ADDU SP, FP, ZERO
9D001E14  8FBE0004   LW FP, 4(SP)
9D001E18  27BD0008   ADDIU SP, SP, 8
9D001E1C  03E00008   JR RA
9D001E20  00000000   NOP
191:                 
192:                 int CB_PeekMany (const CircularBuffer *b, void *outData, uint16_t size)
193:                 {
9D001E24  27BDFFE8   ADDIU SP, SP, -24
9D001E28  AFBE0014   SW FP, 20(SP)
9D001E2C  03A0F021   ADDU FP, SP, ZERO
9D001E30  AFC40018   SW A0, 24(FP)
9D001E34  AFC5001C   SW A1, 28(FP)
9D001E38  00C01021   ADDU V0, A2, ZERO
9D001E3C  A7C20020   SH V0, 32(FP)
194:                 	uint16_t i;
195:                 	int tmpHead;
196:                 
197:                 	if (b) {
9D001E40  8FC20018   LW V0, 24(FP)
9D001E44  10400030   BEQ V0, ZERO, .LBE6
9D001E48  00000000   NOP
198:                 		uint8_t *data_u = (uint8_t*)outData;
9D001E4C  8FC2001C   LW V0, 28(FP)
9D001E50  AFC20008   SW V0, 8(FP)
199:                 		// Make sure there's enough data to read off and read them off one-by-one.
200:                 		if (b->dataSize >= size) {
9D001E54  8FC20018   LW V0, 24(FP)
9D001E58  94420006   LHU V0, 6(V0)
9D001E5C  97C30020   LHU V1, 32(FP)
9D001E60  0043102B   SLTU V0, V0, V1
9D001E64  14400028   BNE V0, ZERO, .LBE6
9D001E68  00000000   NOP
201:                 			tmpHead = b->readIndex;
9D001E6C  8FC20018   LW V0, 24(FP)
9D001E70  94420000   LHU V0, 0(V0)
9D001E74  AFC20004   SW V0, 4(FP)
202:                 			for (i = 0; i < size; ++i) {
9D001E78  A7C00000   SH ZERO, 0(FP)
9D001E7C  0B4007BA   J 0x9D001EE8
9D001E80  00000000   NOP
9D001EDC  97C20000   LHU V0, 0(FP)
9D001EE0  24420001   ADDIU V0, V0, 1
9D001EE4  A7C20000   SH V0, 0(FP)
9D001EE8  97C30000   LHU V1, 0(FP)
9D001EEC  97C20020   LHU V0, 32(FP)
9D001EF0  0062102B   SLTU V0, V1, V0
9D001EF4  1440FFE3   BNE V0, ZERO, 0x9D001E84
9D001EF8  00000000   NOP
203:                 				data_u[i] = b->data[tmpHead];
9D001E84  97C20000   LHU V0, 0(FP)
9D001E88  8FC30008   LW V1, 8(FP)
9D001E8C  00621021   ADDU V0, V1, V0
9D001E90  8FC30018   LW V1, 24(FP)
9D001E94  8C64000C   LW A0, 12(V1)
9D001E98  8FC30004   LW V1, 4(FP)
9D001E9C  00831821   ADDU V1, A0, V1
9D001EA0  90630000   LBU V1, 0(V1)
9D001EA4  A0430000   SB V1, 0(V0)
204:                 
205:                 				// Handle wrapping around the buffer.
206:                 				if (tmpHead < b->staticSize - 1) {
9D001EA8  8FC20018   LW V0, 24(FP)
9D001EAC  94420004   LHU V0, 4(V0)
9D001EB0  2443FFFF   ADDIU V1, V0, -1
9D001EB4  8FC20004   LW V0, 4(FP)
9D001EB8  0043102A   SLT V0, V0, V1
9D001EBC  10400006   BEQ V0, ZERO, 0x9D001ED8
9D001EC0  00000000   NOP
207:                 					++tmpHead;
9D001EC4  8FC20004   LW V0, 4(FP)
9D001EC8  24420001   ADDIU V0, V0, 1
9D001ECC  AFC20004   SW V0, 4(FP)
9D001ED0  0B4007B7   J 0x9D001EDC
9D001ED4  00000000   NOP
208:                 				} else {
209:                 					tmpHead = 0;
9D001ED8  AFC00004   SW ZERO, 4(FP)
210:                 				}
211:                 			}
212:                 			return TRUE;
9D001EFC  24020001   ADDIU V0, ZERO, 1
9D001F00  0B4007C3   J 0x9D001F0C
9D001F04  00000000   NOP
213:                 		}
214:                 	}
215:                 	return FALSE;
9D001F08  00001021   ADDU V0, ZERO, ZERO
216:                 }
9D001F0C  03C0E821   ADDU SP, FP, ZERO
9D001F10  8FBE0014   LW FP, 20(SP)
9D001F14  27BD0018   ADDIU SP, SP, 24
9D001F18  03E00008   JR RA
9D001F1C  00000000   NOP
217:                 
218:                 int CB_Remove(CircularBuffer *b, uint16_t size){
9D001F20  27BDFFF8   ADDIU SP, SP, -8
9D001F24  AFBE0004   SW FP, 4(SP)
9D001F28  03A0F021   ADDU FP, SP, ZERO
9D001F2C  AFC40008   SW A0, 8(FP)
9D001F30  00A01021   ADDU V0, A1, ZERO
9D001F34  A7C2000C   SH V0, 12(FP)
219:                 	// If there are more elements in the buffer.
220:                 	if (b->dataSize > size) {
9D001F38  8FC20008   LW V0, 8(FP)
9D001F3C  94420006   LHU V0, 6(V0)
9D001F40  97C3000C   LHU V1, 12(FP)
9D001F44  0062102B   SLTU V0, V1, V0
9D001F48  10400029   BEQ V0, ZERO, 0x9D001FF0
9D001F4C  00000000   NOP
221:                 		// Checks to see if the buffer will wrap around.
222:                 		if ((b->staticSize - b->readIndex) < size) {
9D001F50  8FC20008   LW V0, 8(FP)
9D001F54  94420004   LHU V0, 4(V0)
9D001F58  00401821   ADDU V1, V0, ZERO
9D001F5C  8FC20008   LW V0, 8(FP)
9D001F60  94420000   LHU V0, 0(V0)
9D001F64  00621823   SUBU V1, V1, V0
9D001F68  97C2000C   LHU V0, 12(FP)
9D001F6C  0062102A   SLT V0, V1, V0
9D001F70  1040000E   BEQ V0, ZERO, 0x9D001FAC
9D001F74  00000000   NOP
223:                 			b-> readIndex = size - (b->staticSize - b->readIndex);
9D001F78  8FC20008   LW V0, 8(FP)
9D001F7C  94430000   LHU V1, 0(V0)
9D001F80  8FC20008   LW V0, 8(FP)
9D001F84  94420004   LHU V0, 4(V0)
9D001F88  00621023   SUBU V0, V1, V0
9D001F8C  3043FFFF   ANDI V1, V0, -1
9D001F90  97C2000C   LHU V0, 12(FP)
9D001F94  00621021   ADDU V0, V1, V0
9D001F98  3043FFFF   ANDI V1, V0, -1
9D001F9C  8FC20008   LW V0, 8(FP)
9D001FA0  A4430000   SH V1, 0(V0)
9D001FA4  0B4007F2   J 0x9D001FC8
9D001FA8  00000000   NOP
224:                 		} else {
225:                 			// If the buffer will not wrap around size is added to read index.
226:                 			b->readIndex = b->readIndex + size;
9D001FAC  8FC20008   LW V0, 8(FP)
9D001FB0  94430000   LHU V1, 0(V0)
9D001FB4  97C2000C   LHU V0, 12(FP)
9D001FB8  00621021   ADDU V0, V1, V0
9D001FBC  3043FFFF   ANDI V1, V0, -1
9D001FC0  8FC20008   LW V0, 8(FP)
9D001FC4  A4430000   SH V1, 0(V0)
227:                 		}
228:                 		b->dataSize -= size;
9D001FC8  8FC20008   LW V0, 8(FP)
9D001FCC  94430006   LHU V1, 6(V0)
9D001FD0  97C2000C   LHU V0, 12(FP)
9D001FD4  00621023   SUBU V0, V1, V0
9D001FD8  3043FFFF   ANDI V1, V0, -1
9D001FDC  8FC20008   LW V0, 8(FP)
9D001FE0  A4430006   SH V1, 6(V0)
229:                 		return TRUE;
9D001FE4  24020001   ADDIU V0, ZERO, 1
9D001FE8  0B400803   J 0x9D00200C
9D001FEC  00000000   NOP
230:                 	}
231:                 	// If one is trying to remove more elements than are in the buffer, the buffer is made empty.
232:                 	else {
233:                 		b->readIndex = b->writeIndex;
9D001FF0  8FC20008   LW V0, 8(FP)
9D001FF4  94430002   LHU V1, 2(V0)
9D001FF8  8FC20008   LW V0, 8(FP)
9D001FFC  A4430000   SH V1, 0(V0)
234:                 		b->dataSize = 0;
9D002000  8FC20008   LW V0, 8(FP)
9D002004  A4400006   SH ZERO, 6(V0)
235:                 		return TRUE;
9D002008  24020001   ADDIU V0, ZERO, 1
236:                 	}
237:                 }
9D00200C  03C0E821   ADDU SP, FP, ZERO
238:                 
239:                 /**
240:                  * This begins the unit testing code. Directions for compilation are at the top of the header file.
241:                  */
242:                 #ifdef UNIT_TEST_CIRCULAR_BUFFER
243:                 
244:                 #include <string.h>
245:                 #include <stdio.h>
246:                 #include <assert.h>
247:                 
248:                 /**
249:                  * @brief A struct used for testing.
250:                  */
251:                 typedef struct {
252:                 	uint8_t hey;
253:                 	int foo;
254:                 	float bar;
255:                 } TestStruct;
256:                 
257:                 /**
258:                  * @brief Returns whether two circular buffers are equal in their metadata.
259:                  *
260:                  * This does not do an exact comparison of their data arrays, just their metadata.
261:                  */
262:                 int TestStructEqual(const TestStruct *a, const TestStruct *b)
263:                 {
264:                 	return (a->hey == b->hey &&
265:                 	        a->foo == b->foo &&
266:                 	        a->bar == b->bar);
267:                 }
268:                 
269:                 /**
270:                  * @brief Run various unit tests confirming proper operation of the CircularBuffer.
271:                  *
272:                  * To run (assuming all files in the same directory and that's your current directory):
273:                  * ```
274:                  * $ gcc CircularBuffer.c -DUNIT_TEST_CIRCULAR_BUFFER -Wall -g
275:                  * $ a.out
276:                  * Running unit tests.
277:                  * All tests passed.
278:                  * $
279:                  */
280:                 int main()
281:                 {
282:                 	printf("Running unit tests.\n");
283:                 
284:                 	// These tests check the ability of the circular buffer to write a single item and
285:                 	// then read it back.
286:                 	{
287:                 		// Create a new circular buffer.
288:                 		CircularBuffer b;
289:                 		uint16_t size = 256;
290:                 		uint8_t *buffer = (uint8_t*)malloc(256*sizeof(uint8_t));
291:                 		CB_Init(&b, buffer, size);
292:                 		assert(!b.dataSize);
293:                 
294:                 		// Add a single item and check.
295:                 		CB_WriteByte(&b, 0x56);
296:                 		assert(b.dataSize == 1);
297:                 		uint8_t peekval;
298:                 		assert(CB_Peek(&b, &peekval));
299:                 		assert(peekval == 0x56);
300:                 
301:                 
302:                 		// Remove that item and check.
303:                 		uint8_t d;
304:                 		assert(CB_ReadByte(&b, &d) && d == 0x56);
305:                 		assert(b.dataSize == 0);
306:                 		assert(CB_Peek(&b, &peekval) == 0);
307:                 
308:                 		free(buffer);
309:                 	}
310:                 
311:                 	/* This tests the ability of the buffer to read and write many items. This code also tests
312:                 	writing two and reading from a buffer which has been wrapped around. Deeppeek is tested.
313:                 	*/
314:                 	{
315:                 		// Create a new circular buffer.
316:                 		CircularBuffer b;
317:                 		uint16_t size = 256;
318:                 		uint8_t *buffer = (uint8_t*)malloc(256*sizeof(uint8_t));
319:                 		CB_Init(&b, buffer, size);
320:                 		assert(!b.dataSize);
321:                 
322:                 		// Here we make a 1016 int8_t long string for testing. Testing with the library with BUFFER_SIZE
323:                 		// set to larger than 1016 will produce errors.
324:                 		int8_t testString[] = "Copyright (C) <year> <copyright holders> Permission is hereby granted, free of int8_tge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.";
325:                 		// Fill the buffer to SIZE+1 and check.
326:                 		uint16_t i;
327:                 		for (i = 0; i < b.staticSize; ++i) {
328:                 			assert(b.dataSize == i);
329:                 			assert(CB_WriteByte(&b, testString[i]));
330:                 			assert(b.dataSize == i + 1);
331:                 		}
332:                 		assert(!CB_WriteByte(&b, 0x89));
333:                 		assert(b.overflowCount == 1);
334:                 
335:                 
336:                 		// Run a deepPeek on the now-full buffer.
337:                 		uint8_t tmpString[b.staticSize];
338:                 		assert(CB_PeekMany(&b, tmpString, b.staticSize));
339:                 		assert(b.dataSize == b.staticSize);
340:                 
341:                 
342:                 		i = 0;
343:                 		while(i < 256){
344:                 			++i;
345:                 		}
346:                 		assert(memcmp(testString, tmpString, b.staticSize) == 0);
347:                 		assert(b.dataSize);
348:                 
349:                 		// Verify reading of an entire circular-buffer
350:                 		uint8_t d;
351:                 		i = b.dataSize;
352:                 		while (i > 0) {
353:                 			assert(CB_ReadByte(&b, &d));
354:                 			assert(d == testString[b.staticSize - i]);
355:                 			i--;
356:                 		}
357:                 		assert(b.dataSize == 0);
358:                 		d = 0x77;
359:                 		int8_t d2 = d;
360:                 		assert(!CB_ReadByte(&b, &d));
361:                 		assert(d == d2); //nothing has been read
362:                 
363:                 		// Test element insertion when the buffer wraps around.
364:                 		uint8_t peekval;
365:                 		assert(CB_WriteByte(&b, 91));
366:                 		assert(b.overflowCount == 1); // Overflow is triggered on an earlier test
367:                 		assert(b.dataSize == 1);
368:                 		CB_Peek(&b, &peekval);
369:                 		assert(peekval == 91);
370:                 		assert(CB_WriteByte(&b, 92));
371:                 		assert(b.dataSize == 2);
372:                 		assert(CB_WriteByte(&b, 93));
373:                 		assert(b.dataSize == 3);
374:                 		assert(CB_WriteByte(&b, 94));
375:                 		assert(b.dataSize == 4);
376:                 
377:                 		// Test DeepPeek on wrapped-around buffers
378:                 		uint8_t peekData[4];
379:                 		assert(CB_PeekMany(&b, peekData, 4));
380:                 		assert(peekData[0] == 91);
381:                 		assert(peekData[1] == 92);
382:                 		assert(peekData[2] == 93);
383:                 		assert(peekData[3] == 94);
384:                 
385:                 		// Test reading now.
386:                 		assert(CB_ReadByte(&b, &d) && d == 91);
387:                 		assert(CB_ReadByte(&b, &d) && d == 92);
388:                 		assert(CB_ReadByte(&b, &d) && d == 93);
389:                 		assert(CB_ReadByte(&b, &d) && d == 94);
390:                 		assert(!CB_ReadByte(&b, &d) && d == 94);
391:                 
392:                 		free(buffer);
393:                 	}
394:                 
395:                 	/* This section of test code checks that CB_Init will not initialize a buffer if its
396:                 	arguments are not valid.
397:                 	*/
398:                 	{
399:                 
400:                 		//Test initialization with invalid arguments
401:                 		CircularBuffer b;
402:                 		uint8_t *buffer = (uint8_t*)malloc(256*sizeof(uint8_t));
403:                 		assert(CB_Init(&b, buffer, 0) == FALSE); //checks the invalid argument size = 0
404:                 		assert(CB_Init(&b, buffer, 1) == FALSE); //checks the invalid argument size = 1
405:                 		assert(CB_Init(&b, buffer, 128) == TRUE); //checks that the function returns TRUE upon TRUE
406:                 		buffer = NULL;
407:                 		assert(CB_Init(&b, buffer, 16) == FALSE); //tests the invalid argument where buffer is a null pointer
408:                 
409:                 		free(buffer);
410:                 	}
411:                 
412:                 	/* This code tests the buffer at the edge case size is two.
413:                 	*/
414:                 	{
415:                 		//Test functionality at edge case size is 2
416:                 		uint8_t CBtestbuf[2];
417:                 		CircularBuffer b;
418:                 		CB_Init(&b, CBtestbuf, 2);  //creates a new buffer of length two
419:                 		assert(!b.dataSize);
420:                 
421:                 		// Add a single item and check.
422:                 		uint8_t peekval;
423:                 		CB_WriteByte(&b, 0x56);
424:                 		assert(b.dataSize == 1);
425:                 		CB_Peek(&b, &peekval);
426:                 		assert(peekval == 0x56);
427:                 
428:                 		// Remove that item and check.
429:                 		uint8_t e;
430:                 		assert(CB_ReadByte(&b, &e) && e == 0x56);
431:                 		assert(b.dataSize == 0);
432:                 		assert(CB_Peek(&b, &peekval) == 0);
433:                 
434:                 		//Now write two characters to the buffer
435:                 		assert(CB_WriteByte(&b, 0x56));
436:                 		assert(CB_WriteByte(&b, 0x58));
437:                 		assert(b.dataSize == 2); //Check to see if the length is correct
438:                 		CB_WriteByte(&b, 0x59);  //Write a third element to the two bit buffer
439:                 		assert(b.overflowCount == 1); //Check that overflow has occurred
440:                 		assert(CB_ReadByte(&b, &e) && e == 0x56); //Check Reading an element
441:                 		assert(b.dataSize == 1); //Check the length of the buffer
442:                 		assert(CB_ReadByte(&b, &e) && e == 0x58); //Check Reading an element
443:                 		assert(b.dataSize == 0); //Check that the buffer is now empty
444:                 		assert(CB_ReadByte(&b, &e) == FALSE); //checks that the empty buffer cannot be read from
445:                 	}
446:                 
447:                 	/* This code tests the edge case where the buffer is at the maximum size.  The size
448:                 	is limited by the maximum value which can be held in a uint16_t.
449:                 	*/
450:                 	{
451:                 		//Test functionality at edge case size is UINT16_MAX
452:                 		CircularBuffer b;
453:                 		uint8_t *buffertwo = (uint8_t*)malloc(UINT16_MAX*sizeof(uint8_t));
454:                 
455:                 		CB_Init(&b, buffertwo, UINT16_MAX);
456:                 		assert(!b.dataSize);
457:                 		assert(b.staticSize == UINT16_MAX);
458:                 
459:                 
460:                 		// Here we use the same UINT16_MAX int8_character long string for testing. Testing with the library with BUFFER_SIZE
461:                 		// set to larger than UINT16_MAX will produce errors.
462:                 		uint8_t testStringtwo[b.staticSize+1];
463:                 
464:                 		int i;
465:                 		for (i = 0; i < b.staticSize; ++i) {
466:                 			testStringtwo[i] = i;
467:                 		}
468:                 
469:                 		// Fill the buffer to SIZE+1 and check
470:                 		for (i = 0; i < b.staticSize; ++i) {
471:                 			assert(b.dataSize == i);
472:                 			assert(CB_WriteByte(&b, i));
473:                 			assert(b.dataSize == i + 1);
474:                 		}
475:                 		assert(!CB_WriteByte(&b, 0x89));
476:                 		assert(b.overflowCount == 1);
477:                 
478:                 		// Run a deepPeek on the now-full buffer.
479:                 		uint8_t tmpStringtwo[b.staticSize];
480:                 		assert(CB_PeekMany(&b, tmpStringtwo, b.staticSize));
481:                 		assert(b.dataSize == b.staticSize);
482:                 		assert(memcmp(testStringtwo, tmpStringtwo, b.staticSize) == 0);
483:                 
484:                 		// Verify reading of an entire circular-buffer
485:                 		uint8_t d;
486:                 		for (i = b.dataSize; i > 0; --i) {
487:                 			assert(CB_ReadByte(&b, &d));
488:                 			assert(d == testStringtwo[b.staticSize - i]);
489:                 		}
490:                 		assert(b.dataSize == 0);
491:                 		d = 0x77;
492:                 		int8_t d3 = d;
493:                 		assert(!CB_ReadByte(&b, &d));
494:                 		assert(d == d3);
495:                 		assert(!b.dataSize);
496:                 
497:                 		// Test element insertion when the buffer wraps around.
498:                 		uint8_t peekval;
499:                 		assert(CB_WriteByte(&b, 91));
500:                 		assert(b.overflowCount == 1); // Overflow is triggered on an earlier test
501:                 		assert(b.dataSize == 1);
502:                 		CB_Peek(&b, &peekval);
503:                 		assert(peekval == 91);
504:                 		assert(CB_WriteByte(&b, 92));
505:                 		assert(b.dataSize == 2);
506:                 		assert(CB_WriteByte(&b, 93));
507:                 		assert(b.dataSize == 3);
508:                 		assert(CB_WriteByte(&b, 94));
509:                 		assert(b.dataSize == 4);
510:                 
511:                 		// Test DeepPeek on wrapped-around buffers
512:                 		uint8_t peekDatatwo[4];
513:                 		assert(CB_PeekMany(&b, peekDatatwo, 4));
514:                 		assert(peekDatatwo[0] == 91);
515:                 		assert(peekDatatwo[1] == 92);
516:                 		assert(peekDatatwo[2] == 93);
517:                 		assert(peekDatatwo[3] == 94);
518:                 
519:                 		// Test reading now.
520:                 		assert(CB_ReadByte(&b, &d) && d == 91);
521:                 		assert(CB_ReadByte(&b, &d) && d == 92);
522:                 		assert(CB_ReadByte(&b, &d) && d == 93);
523:                 		assert(CB_ReadByte(&b, &d) && d == 94);
524:                 		assert(!CB_ReadByte(&b, &d) && d == 94);
525:                 
526:                 		free(buffertwo);
527:                 	}
528:                 
529:                 	/* This tests the remove function
530:                 	*/
531:                 	{
532:                 		/**Test Remove Function*/
533:                 		CircularBuffer b;
534:                 		uint8_t CBtestbuften[10];
535:                 		CB_Init(&b, CBtestbuften, 10);  //creates a new buffer of length ten
536:                 		assert(!b.dataSize);
537:                 
538:                 		int i;
539:                 		i = 0;
540:                 		while(i < 9){
541:                 			CB_WriteByte(&b, i);
542:                 			++i;
543:                 		}
544:                 		//Test removing a valid number of items
545:                 		assert(b.dataSize == 9);
546:                 		assert(CB_Remove(&b, 4));
547:                 		assert(b.dataSize == 5);
548:                 		uint8_t d;
549:                 		CB_ReadByte(&b, &d);
550:                 		assert(d == 4);
551:                 
552:                 		//Test removing more items than are in the buffer
553:                 		assert(b.dataSize == 4);
554:                 		CB_Remove(&b, 10);
555:                 		assert(b.dataSize == 0); //The buffer is now empty
556:                 	}
557:                 
558:                 	/* This tests using the CB_ReadMany function to read a buffer.
559:                 	*/
560:                 	{
561:                 		/**Test reading multiple values from the buffer using CB_ReadMany */
562:                 		CircularBuffer b;
563:                 		uint8_t CBtestbufthirty[30];
564:                 		CB_Init(&b, CBtestbufthirty, 30);  //creates a new buffer of length thirty
565:                 		assert(!b.dataSize);
566:                 
567:                 		int i = 0;
568:                 		while(i < 30){
569:                 			CB_WriteByte(&b, i);
570:                 			++i;
571:                 		}
572:                 		assert(b.dataSize == 30);
573:                 
574:                 		uint8_t readresults[30];
575:                 		assert(CB_ReadMany(&b,readresults, 15));
576:                 		i = 0;
577:                 		while(i < 15){
578:                 			assert(readresults[i] == i);
579:                 			++i;
580:                 		}
581:                 		assert(b.dataSize == 15);
582:                 		assert(CB_ReadMany(&b,readresults, 15));
583:                 		assert(b.dataSize == 0); //Checks that buffer is now empty
584:                 		assert(b.readIndex == b.writeIndex); //checks that the pointers are equal
585:                 	}
586:                 
587:                 
588:                 	/* This tests using CB_WriteMany to write to a buffer.
589:                 	*/
590:                 	{
591:                 		/**Testing the WriteMany function*/
592:                 		CircularBuffer b;
593:                 		uint8_t CBtestbufthirty[30];
594:                 		CB_Init(&b, CBtestbufthirty, 30);  //re-initializes buffer of length thirty
595:                 		assert(!b.dataSize);
596:                 
597:                 		uint8_t readresults[100];
598:                 		int i = 0;
599:                 		while (i < 100) {
600:                 			readresults[i] = i;
601:                 			++i;
602:                 		}
603:                 		assert(CB_WriteMany(&b, readresults, 22, TRUE)); //write 22 values from readresults to the buffer
604:                 		assert(b.dataSize == 22);
605:                 
606:                 		uint8_t d;
607:                 		i = 0;
608:                 		while (i < 22) {
609:                 			CB_ReadByte(&b, &d);
610:                 			assert(d == i);
611:                 			++i;
612:                 		}
613:                 
614:                 		CB_Init(&b, CBtestbufthirty, 30);  //re-initializes buffer of length thirty
615:                 		assert(!b.dataSize);
616:                 		assert(b.readIndex == b.writeIndex);
617:                 		i = 0;
618:                 		while (i < 30) {
619:                 			readresults[i] = i;
620:                 			++i;
621:                 		}
622:                 		CB_WriteMany(&b, readresults, 22, FALSE); //write 22 values from readresults to the buffer
623:                 		assert(b.dataSize == 22);
624:                 		i = 0;
625:                 		while (i < 22) {
626:                 			CB_ReadByte(&b, &d);
627:                 			assert(d == i);
628:                 			++i;
629:                 		}
630:                 
631:                 		/**Now test the failure criteria specified in failEarly*/
632:                 		CB_Init(&b, CBtestbufthirty, 30);  //re-initializes buffer of length thirty
633:                 		CB_WriteMany(&b, readresults, 18, TRUE);
634:                 		assert(b.dataSize == 18);
635:                 		assert(CB_WriteMany(&b, readresults, 50, TRUE) == FALSE); //Writing more than the buffer can hold returns an error
636:                 		assert(b.dataSize == 18); // Checks that nothing was written
637:                 		assert(!CB_WriteMany(&b, readresults, 100, FALSE)); // Now without the size check
638:                 		assert(b.dataSize == 30); //Checks that buffer is now full
639:                 		assert(b.overflowCount == 88); //100-(30-18) = 88 elements have overflowed
640:                 
641:                 		i = 0;
642:                 		while (i < 18) {
643:                 			CB_ReadByte(&b, &d);
644:                 			assert(i == d);
645:                 			++i;
646:                 		}
647:                 		while (i < 12) {
648:                 			CB_ReadByte(&b, &d);
649:                 			assert(i == d);
650:                 			++i;
651:                 		}
652:                 	}
653:                 
654:                 	/* This code tests using the CB_WriteMany and CB_ReadMany functions to read and write
655:                 	structures to a buffer.  CB_PeekMany is also tested.
656:                 	*/
657:                 	{
658:                 		// The test circular buffer
659:                 		CircularBuffer c;
660:                 
661:                 		//Testing writing of a structure to the buffer and reading it back
662:                 		// Create a new circular buffer.
663:                 		TestStruct t1 = {6, 42, 1.5};
664:                 
665:                 		uint16_t sizetwo = 256*sizeof(TestStruct);
666:                 		uint8_t structbuff[sizetwo];
667:                 		assert(CB_Init(&c, structbuff, sizetwo)); //Creates a buffer to hold 256 TestStruct structures
668:                 		assert(!c.dataSize);
669:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
670:                 		assert(c.dataSize == sizeof(TestStruct));
671:                 
672:                 		TestStruct f;
673:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the structure back from the buffer
674:                 		assert(!c.dataSize); //the buffer is now empty
675:                 		assert(TestStructEqual(&f, &t1));
676:                 
677:                 		TestStruct t2 = {56, 700, 5.75}; //filled with arbitrary values
678:                 
679:                 		//Write a single structure to the buffer and then read it back
680:                 		assert(c.dataSize == 0);
681:                 		assert(CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE));
682:                 		assert(c.dataSize == sizeof(TestStruct));
683:                 
684:                 		assert(CB_ReadMany(&c, &f, sizeof(TestStruct))); //read the structure back from the buffer
685:                 		assert(TestStructEqual(&f, &t2));
686:                 
687:                 		//Write two structures to the buffer and then read them back
688:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
689:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
690:                 
691:                 		assert(c.dataSize == 2*sizeof(TestStruct));
692:                 
693:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
694:                 		assert(TestStructEqual(&f, &t1));
695:                 
696:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
697:                 		assert(TestStructEqual(&f, &t2));
698:                 
699:                 		assert(c.readIndex == c.writeIndex); //The buffer is now empty.
700:                 
701:                 		// Write four structures to the buffer using a loop and read them back.
702:                 
703:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
704:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
705:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
706:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
707:                 
708:                 		assert(c.dataSize == 4*sizeof(TestStruct));
709:                 
710:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
711:                 		assert(TestStructEqual(&f, &t1));
712:                 
713:                 		assert(c.dataSize == 3*sizeof(TestStruct));
714:                 
715:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
716:                 		assert(TestStructEqual(&f, &t2));
717:                 
718:                 		assert(c.dataSize == 2*sizeof(TestStruct));
719:                 
720:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read third the structure back from the buffer
721:                 		assert(TestStructEqual(&f, &t1));
722:                 
723:                 		assert(c.dataSize == 1*sizeof(TestStruct));
724:                 
725:                 		CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the fourth structure back from the buffer
726:                 		assert(TestStructEqual(&f, &t2));
727:                 
728:                 		assert(c.dataSize == 0); //the buffer is now empty
729:                 
730:                 		// Now write six structures and then read them off using a loop.
731:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
732:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
733:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
734:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
735:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
736:                 		CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
737:                 
738:                 		int i = 0;
739:                 		while (i < 3) {
740:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
741:                 			assert(TestStructEqual(&f, &t1));
742:                 
743:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
744:                 			assert(TestStructEqual(&f, &t2));
745:                 
746:                 			++i;
747:                 		}
748:                 
749:                 		//Now write from a loop and read from a loop
750:                 		i = 0;
751:                 		while (i < 3) {
752:                 			CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
753:                 			CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
754:                 			++i;
755:                 		}
756:                 
757:                 		i = 0;
758:                 		while (i < 3) {
759:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
760:                 			assert(TestStructEqual(&f, &t1));
761:                 
762:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
763:                 			assert(TestStructEqual(&f, &t2));
764:                 
765:                 			++i;
766:                 		}
767:                 
768:                 		assert(c.readIndex == c.writeIndex); //the buffer is empty
769:                 
770:                 		//Now write 40 elements from a loop and read 40 elements from a loop
771:                 		i = 0;
772:                 		while (i < 20) {
773:                 			CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
774:                 			CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
775:                 			++i;
776:                 		}
777:                 
778:                 		i = 0;
779:                 		while (i < 20) {
780:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
781:                 			assert(TestStructEqual(&f, &t1));
782:                 
783:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
784:                 			assert(TestStructEqual(&f, &t2));
785:                 
786:                 			++i;
787:                 		}
788:                 
789:                 		//Now try to overfill a buffer and then read the structures back
790:                 		//C is length 256*sizeof(TestStruct) so we will try to write 260 structures
791:                 		assert(c.readIndex == c.writeIndex); //the buffer is empty
792:                 		assert(c.dataSize == 0);
793:                 
794:                 		i = 0;
795:                 		while (i < 130) { //writes 260 structures to the buffer
796:                 			CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
797:                 			CB_WriteMany(&c, &t2, sizeof(TestStruct), TRUE);
798:                 			++i;
799:                 		}
800:                 
801:                 		i = 0;
802:                 		while (i < 128) {
803:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read first the structure back from the buffer
804:                 			assert(TestStructEqual(&f, &t1));
805:                 
806:                 			CB_ReadMany(&c, &f, sizeof(TestStruct)); //read the second structure back from the buffer
807:                 			assert(TestStructEqual(&f, &t2));
808:                 
809:                 			++i;
810:                 		}
811:                 
812:                 		assert(c.readIndex == c.writeIndex); //the buffer is empty
813:                 		assert(c.dataSize == 0);
814:                 
815:                 		//Testing CB_PeekMany on structures
816:                 		TestStruct peekTest;
817:                 
818:                 		CB_WriteMany(&c, &t1, sizeof(TestStruct), TRUE);
819:                 		CB_PeekMany(&c, (uint8_t*)&peekTest, sizeof(TestStruct));
820:                 		assert(TestStructEqual(&t1, &peekTest));
821:                 	}
822:                         {
823:                             // Test writing and reading from the circular buffer. Showed a failure mode of the CircularBuffer with regards to its read index.
824:                             CircularBuffer circBuf;
825:                             unsigned char data[20];
826:                             unsigned char testIn[20] = "Hey There This Test";
827:                             unsigned char testOut[20];
828:                 
829:                             // Initialize the circular buffer
830:                             assert(CB_Init(&circBuf, data, 20));
831:                             assert(circBuf.readIndex == circBuf.writeIndex);
832:                             assert(circBuf.readIndex == 0);
833:                             assert(circBuf.writeIndex == 0);
834:                 
835:                             // Write and read to the buffer multiple times
836:                             CB_WriteMany(&circBuf, testIn, 20, TRUE);
837:                             assert(circBuf.readIndex == circBuf.writeIndex);
838:                             assert(circBuf.readIndex == 0);
839:                             assert(circBuf.writeIndex == 0);
840:                 
841:                             CB_PeekMany(&circBuf, testOut, 20);
842:                             assert(circBuf.readIndex == circBuf.writeIndex);
843:                             assert(circBuf.readIndex == 0);
844:                             assert(circBuf.writeIndex == 0);
845:                 
846:                             CB_Remove(&circBuf, 20);
847:                             assert(circBuf.readIndex == circBuf.writeIndex);
848:                             assert(circBuf.readIndex == 0);
849:                             assert(circBuf.writeIndex == 0);
850:                 
851:                             assert(!memcmp(testIn, testOut, 20));
852:                 
853:                             
854:                             CB_WriteMany(&circBuf, testIn, 20, TRUE);
855:                             assert(circBuf.readIndex == circBuf.writeIndex);
856:                             assert(circBuf.readIndex == 0);
857:                             assert(circBuf.writeIndex == 0);
858:                 
859:                             CB_PeekMany(&circBuf, testOut, 20);
860:                             assert(circBuf.readIndex == circBuf.writeIndex);
861:                             assert(circBuf.readIndex == 0);
862:                             assert(circBuf.writeIndex == 0);
863:                 
864:                             CB_Remove(&circBuf, 20);
865:                             assert(circBuf.readIndex == circBuf.writeIndex);
866:                             assert(circBuf.readIndex == 0);
867:                             assert(circBuf.writeIndex == 0);
868:                 
869:                             assert(!memcmp(testIn, testOut, 20));
870:                 
871:                             //Test uneven data
872:                             CB_WriteMany(&circBuf, testIn, 7, TRUE);
873:                             assert(circBuf.readIndex == 0);
874:                             assert(circBuf.writeIndex == 7);
875:                 
876:                             CB_PeekMany(&circBuf, testOut, 7);
877:                             assert(circBuf.readIndex == 0);
878:                             assert(circBuf.writeIndex == 7);
879:                 
880:                             CB_Remove(&circBuf, 7);
881:                             assert(circBuf.readIndex == circBuf.writeIndex);
882:                             assert(circBuf.readIndex == 7);
883:                             assert(circBuf.writeIndex == 7);
884:                 
885:                             //Test the full data again
886:                             CB_WriteMany(&circBuf, testIn, 20, TRUE);
887:                             assert(circBuf.readIndex == circBuf.writeIndex);
888:                             assert(circBuf.readIndex == 7);
889:                             assert(circBuf.writeIndex == 7);
890:                 
891:                             CB_PeekMany(&circBuf, testOut, 20);
892:                             assert(circBuf.readIndex == circBuf.writeIndex);
893:                             assert(circBuf.readIndex == 7);
894:                             assert(circBuf.writeIndex == 7);
895:                 
896:                             CB_Remove(&circBuf, 20);
897:                             assert(circBuf.readIndex == circBuf.writeIndex);
898:                             assert(circBuf.readIndex == 7);
899:                             assert(circBuf.writeIndex == 7);
900:                 
901:                             assert(!memcmp(testIn, testOut, 20));
902:                 
903:                 
904:                             CB_WriteMany(&circBuf, testIn, 20, TRUE);
905:                             assert(circBuf.readIndex == circBuf.writeIndex);
906:                             assert(circBuf.readIndex == 7);
907:                             assert(circBuf.writeIndex == 7);
908:                 
909:                             CB_PeekMany(&circBuf, testOut, 20);
910:                             assert(circBuf.readIndex == circBuf.writeIndex);
911:                             assert(circBuf.readIndex == 7);
912:                             assert(circBuf.writeIndex == 7);
913:                 
914:                             CB_Remove(&circBuf, 20);
915:                             assert(circBuf.readIndex == circBuf.writeIndex);
916:                             assert(circBuf.readIndex == 7);
917:                             assert(circBuf.writeIndex == 7);
918:                 
919:                             assert(!memcmp(testIn, testOut, 20));
920:                         }
921:                 
922:                 	printf("All tests passed.\n");
923:                 
924:                 	return 0;
925:                 
926:                 }
927:                 #endif // UNIT_TEST_CIRCULAR_BUFFER
---  c:/users/kylez/cmpe13/lab09/lab9.x/board.c  --------------------------------------------------------
1:                   /*
2:                    * File:   BOARD.h
3:                    * Author: Max Dunne
4:                    *
5:                    * Created on December 19, 2012, 2:08 PM
6:                    * 
7:                    * Much of the odder code come directly from the microchip peripheral library as reinventing the wheel seemed
8:                    * not necessary
9:                    */
10:                  
11:                  #include "BOARD.h"
12:                  
13:                  // Microchip Libraries
14:                  #include <xc.h>
15:                  #include <stdint.h>
16:                  #include <stdio.h>
17:                  
18:                  // no legacy libc
19:                  #ifdef __C32_LEGACY_LIBC__
20:                  #error CMPE013 Can not be done with legacy libc. Ensure project properties -> XC32 (Global Options) -> Use legacy libc is UN checked. 
21:                  #endif
22:                  
23:                  /*******************************************************************************
24:                   * PRAGMAS                                                                     *
25:                   ******************************************************************************/
26:                  // Configuration Bits
27:                  // SYSCLK = 80MHz
28:                  // PBCLK  = 20MHz
29:                  // using POSC w/ PLL, XT mode
30:                  #pragma config FPBDIV     = DIV_4
31:                  #pragma config FPLLIDIV   = DIV_2     // Set the PLL input divider to 2, seems to
32:                  #pragma config IESO       = OFF       // Internal/External Switch
33:                  #pragma config POSCMOD    = XT        // Primary Oscillator Configuration for XT osc mode
34:                  #pragma config OSCIOFNC   = OFF       // Disable clock signal output
35:                  #pragma config FCKSM      = CSECMD    // Clock Switching and Monitor Selection
36:                  #pragma config WDTPS      = PS1       // Specify the watchdog timer interval (unused)
37:                  #pragma config FWDTEN     = OFF       // Disable the watchdog timer
38:                  #pragma config ICESEL     = ICS_PGx2  // Allow for debugging with the Uno32
39:                  #pragma config PWP        = OFF       // Keep the program flash writeable
40:                  #pragma config BWP        = OFF       // Keep the boot flash writeable
41:                  #pragma config CP         = OFF       // Disable code protect
42:                  #pragma config FNOSC 		= PRIPLL	//Oscillator Selection Bits
43:                  #pragma config FSOSCEN 		= OFF		//Secondary Oscillator Enable
44:                  #pragma config FPLLMUL 		= MUL_20	//PLL Multiplier
45:                  #pragma config FPLLODIV 	= DIV_1 	//System PLL Output Clock Divid
46:                  
47:                  /*******************************************************************************
48:                   * PRIVATE #DEFINES                                                            *
49:                   ******************************************************************************/
50:                  #define SYSTEM_CLOCK 80000000L
51:                  #define PB_CLOCK (SYSTEM_CLOCK / 4)
52:                  #define QUEUESIZE 512
53:                  //#define TurnOffAndClearInterrupt(Name) INTEnable(Name,INT_DISABLED); INTClearFlag(Name)
54:                  #define TurnPortToInput(Tris) Tris=0xFFFF
55:                  
56:                  
57:                  //#define LAB10_READ_OVERWRITE
58:                  /*******************************************************************************
59:                   * PRIVATE DATATYPES                                                           *
60:                   ******************************************************************************/
61:                  
62:                  
63:                  
64:                  /*******************************************************************************
65:                   * PRIVATE FUNCTION PROTOTYPES                                                 *
66:                   ******************************************************************************/
67:                  void SERIAL_Init(void);
68:                  
69:                  /*******************************************************************************
70:                   * PRIVATE VARIABLES                                                           *
71:                   ******************************************************************************/
72:                  
73:                  
74:                  /*******************************************************************************
75:                   * PUBLIC FUNCTIONS                                                            *
76:                   ******************************************************************************/
77:                  
78:                  /**
79:                   * Function: BOARD_Init(void)
80:                   * @param None
81:                   * @return None
82:                   * @brief Initializes the board for 80MHz SYSCLK and 20MHz PBCLK.
83:                   */
84:                  void BOARD_Init() {
9D00490C  27BDFFD0   ADDIU SP, SP, -48
9D004910  AFBF002C   SW RA, 44(SP)
9D004914  AFBE0028   SW FP, 40(SP)
9D004918  03A0F021   ADDU FP, SP, ZERO
85:                      //seeds the random number generator with the time
86:                      char seed1[] = __TIME__;
9D00491C  3C029D00   LUI V0, -25344
9D004920  8C446A78   LW A0, 27256(V0)
9D004924  24436A78   ADDIU V1, V0, 27256
9D004928  8C630004   LW V1, 4(V1)
9D00492C  AFC4001C   SW A0, 28(FP)
9D004930  AFC30020   SW V1, 32(FP)
9D004934  24426A78   ADDIU V0, V0, 27256
9D004938  90420008   LBU V0, 8(V0)
9D00493C  A3C20024   SB V0, 36(FP)
87:                      unsigned int seed2 = (((unsigned int) (seed1[7] ^ seed1[2])) << 8) | ((unsigned int) (seed1[4] ^ seed1[6]));
9D004940  83C30023   LB V1, 35(FP)
9D004944  83C2001E   LB V0, 30(FP)
9D004948  00621026   XOR V0, V1, V0
9D00494C  7C021420   SEB V0, V0
9D004950  00021A00   SLL V1, V0, 8
9D004954  83C40020   LB A0, 32(FP)
9D004958  83C20022   LB V0, 34(FP)
9D00495C  00821026   XOR V0, A0, V0
9D004960  7C021420   SEB V0, V0
9D004964  00621025   OR V0, V1, V0
9D004968  AFC20010   SW V0, 16(FP)
88:                      srand(seed2);
9D00496C  0F401A6E   JAL .LFB0, srand
9D004970  8FC40010   LW A0, 16(FP)
89:                  
90:                      //enables the interrupt system in the new style
91:                      
92:                      //INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR); 
93:                      unsigned int val;
94:                  
95:                      // set the CP0 cause IV bit high
96:                      asm volatile("mfc0   %0,$13" : "=r"(val));
9D004974  40026800   MFC0 V0, Cause
9D004978  AFC20014   SW V0, 20(FP)
97:                      val |= 0x00800000;
9D00497C  8FC30014   LW V1, 20(FP)
9D004980  3C020080   LUI V0, 128
9D004984  00621025   OR V0, V1, V0
9D004988  AFC20014   SW V0, 20(FP)
98:                      asm volatile("mtc0   %0,$13" : "+r"(val));
9D00498C  8FC20014   LW V0, 20(FP)
9D004990  40826800   MTC0 V0, Cause
9D004994  AFC20014   SW V0, 20(FP)
99:                      INTCONSET = _INTCON_MVEC_MASK;
9D004998  3C02BF88   LUI V0, -16504
9D00499C  24031000   ADDIU V1, ZERO, 4096
9D0049A0  AC431008   SW V1, 4104(V0)
100:                     
101:                     //INTEnableInterrupts();
102:                     int status;
103:                     asm volatile("ei    %0" : "=r"(status));
9D0049A4  41626020   EI V0
9D0049A8  AFC20018   SW V0, 24(FP)
104:                     // Initialize for serial
105:                     SERIAL_Init();
9D0049AC  0F4012DC   JAL SERIAL_Init
9D0049B0  00000000   NOP
106:                 }
9D0049B4  03C0E821   ADDU SP, FP, ZERO
9D0049B8  8FBF002C   LW RA, 44(SP)
9D0049BC  8FBE0028   LW FP, 40(SP)
9D0049C0  03E00008   JR RA
9D0049C4  27BD0030   ADDIU SP, SP, 48
107:                 
108:                 /**
109:                  * Function: BOARD_End(void)
110:                  * @param None
111:                  * @return None
112:                  * @brief shuts down all peripherals except for serial and A/D. Turns all pins
113:                  * into input
114:                  * @author Max Dunne, 2013.09.20  */
115:                 void BOARD_End() {
9D0049C8  27BDFFF8   ADDIU SP, SP, -8
9D0049CC  AFBE0004   SW FP, 4(SP)
9D0049D0  03A0F021   ADDU FP, SP, ZERO
116:                 
117:                     // set all interrupt enable flags to zero
118:                     IEC0 = 0;
9D0049D4  3C02BF88   LUI V0, -16504
9D0049D8  AC401060   SW ZERO, 4192(V0)
119:                     IEC1 = 0;
9D0049DC  3C02BF88   LUI V0, -16504
9D0049E0  AC401070   SW ZERO, 4208(V0)
120:                 
121:                     //set all flags to zero
122:                     IFS0 = 0;
9D0049E4  3C02BF88   LUI V0, -16504
9D0049E8  AC401030   SW ZERO, 4144(V0)
123:                     IFS1 = 0;
9D0049EC  3C02BF88   LUI V0, -16504
9D0049F0  AC401040   SW ZERO, 4160(V0)
124:                 
125:                     // disable timer interrupts, clear flags and turn off module
126:                     T1CON = 0;
9D0049F4  3C02BF80   LUI V0, -16512
9D0049F8  AC400600   SW ZERO, 1536(V0)
127:                     T2CON = 0;
9D0049FC  3C02BF80   LUI V0, -16512
9D004A00  AC400800   SW ZERO, 2048(V0)
128:                     T3CON = 0;
9D004A04  3C02BF80   LUI V0, -16512
9D004A08  AC400A00   SW ZERO, 2560(V0)
129:                     T4CON = 0;
9D004A0C  3C02BF80   LUI V0, -16512
9D004A10  AC400C00   SW ZERO, 3072(V0)
130:                     T5CON = 0;
9D004A14  3C02BF80   LUI V0, -16512
9D004A18  AC400E00   SW ZERO, 3584(V0)
131:                 
132:                 
133:                     // disable input capture interrupts, clear flags and turn off module
134:                     IC1CONCLR = _IC1CON_ICM_MASK;
9D004A1C  3C02BF80   LUI V0, -16512
9D004A20  24030007   ADDIU V1, ZERO, 7
9D004A24  AC432004   SW V1, 8196(V0)
135:                     IC2CONCLR = _IC2CON_ICM_MASK;
9D004A28  3C02BF80   LUI V0, -16512
9D004A2C  24030007   ADDIU V1, ZERO, 7
9D004A30  AC432204   SW V1, 8708(V0)
136:                     IC3CONCLR = _IC3CON_ICM_MASK;
9D004A34  3C02BF80   LUI V0, -16512
9D004A38  24030007   ADDIU V1, ZERO, 7
9D004A3C  AC432404   SW V1, 9220(V0)
137:                     IC4CONCLR = _IC4CON_ICM_MASK;
9D004A40  3C02BF80   LUI V0, -16512
9D004A44  24030007   ADDIU V1, ZERO, 7
9D004A48  AC432604   SW V1, 9732(V0)
138:                     IC5CONCLR = _IC5CON_ICM_MASK;
9D004A4C  3C02BF80   LUI V0, -16512
9D004A50  24030007   ADDIU V1, ZERO, 7
9D004A54  AC432804   SW V1, 10244(V0)
139:                 
140:                     // disable output compare interrupts, clear flags and turn off module
141:                     OC1CONCLR = _OC1CON_ON_MASK;
9D004A58  3C02BF80   LUI V0, -16512
9D004A5C  34038000   ORI V1, ZERO, -32768
9D004A60  AC433004   SW V1, 12292(V0)
142:                     OC2CONCLR = _OC2CON_ON_MASK;
9D004A64  3C02BF80   LUI V0, -16512
9D004A68  34038000   ORI V1, ZERO, -32768
9D004A6C  AC433204   SW V1, 12804(V0)
143:                     OC3CONCLR = _OC3CON_ON_MASK;
9D004A70  3C02BF80   LUI V0, -16512
9D004A74  34038000   ORI V1, ZERO, -32768
9D004A78  AC433404   SW V1, 13316(V0)
144:                     OC4CONCLR = _OC4CON_ON_MASK;
9D004A7C  3C02BF80   LUI V0, -16512
9D004A80  34038000   ORI V1, ZERO, -32768
9D004A84  AC433604   SW V1, 13828(V0)
145:                     OC5CONCLR = _OC5CON_ON_MASK;
9D004A88  3C02BF80   LUI V0, -16512
9D004A8C  34038000   ORI V1, ZERO, -32768
9D004A90  AC433804   SW V1, 14340(V0)
146:                 
147:                     // disable I2C interrupts, clear flags and turn off module
148:                     I2C1CONCLR = _I2C1CON_ON_MASK;
9D004A94  3C02BF80   LUI V0, -16512
9D004A98  34038000   ORI V1, ZERO, -32768
9D004A9C  AC435004   SW V1, 20484(V0)
149:                     I2C2CONCLR = _I2C2CON_ON_MASK;
9D004AA0  3C02BF80   LUI V0, -16512
9D004AA4  34038000   ORI V1, ZERO, -32768
9D004AA8  AC435204   SW V1, 20996(V0)
150:                 
151:                     //disable spi interrupts, clear flags and turn off module
152:                     SPI1CONCLR = _SPI1CON_ON_MASK;
9D004AAC  3C02BF80   LUI V0, -16512
9D004AB0  34038000   ORI V1, ZERO, -32768
9D004AB4  AC435804   SW V1, 22532(V0)
153:                     SPI2CONCLR = _SPI2CON_ON_MASK;
9D004AB8  3C02BF80   LUI V0, -16512
9D004ABC  34038000   ORI V1, ZERO, -32768
9D004AC0  AC435A04   SW V1, 23044(V0)
154:                 
155:                     // disable external interrupts, clear flags and turn off module
156:                 
157:                     // set all ports to be digital inputs
158:                     TurnPortToInput(TRISB);
9D004AC4  3C02BF88   LUI V0, -16504
9D004AC8  3403FFFF   ORI V1, ZERO, -1
9D004ACC  AC436040   SW V1, 24640(V0)
159:                     TurnPortToInput(TRISC);
9D004AD0  3C02BF88   LUI V0, -16504
9D004AD4  3403FFFF   ORI V1, ZERO, -1
9D004AD8  AC436080   SW V1, 24704(V0)
160:                     TurnPortToInput(TRISD);
9D004ADC  3C02BF88   LUI V0, -16504
9D004AE0  3403FFFF   ORI V1, ZERO, -1
9D004AE4  AC4360C0   SW V1, 24768(V0)
161:                     TurnPortToInput(TRISE);
9D004AE8  3C02BF88   LUI V0, -16504
9D004AEC  3403FFFF   ORI V1, ZERO, -1
9D004AF0  AC436100   SW V1, 24832(V0)
162:                     TurnPortToInput(TRISF);
9D004AF4  3C02BF88   LUI V0, -16504
9D004AF8  3403FFFF   ORI V1, ZERO, -1
9D004AFC  AC436140   SW V1, 24896(V0)
163:                     TurnPortToInput(TRISG);
9D004B00  3C02BF88   LUI V0, -16504
9D004B04  3403FFFF   ORI V1, ZERO, -1
9D004B08  AC436180   SW V1, 24960(V0)
164:                 
165:                     //Serial and A/D are left on for output and battery monitoring respectively
166:                 }
9D004B0C  03C0E821   ADDU SP, FP, ZERO
9D004B10  8FBE0004   LW FP, 4(SP)
9D004B14  27BD0008   ADDIU SP, SP, 8
9D004B18  03E00008   JR RA
9D004B1C  00000000   NOP
167:                 
168:                 /**
169:                  * Function: BOARD_GetPBClock(void)
170:                  * @param None
171:                  * @return
172:                  */
173:                 unsigned int BOARD_GetPBClock() {
9D004B20  27BDFFF8   ADDIU SP, SP, -8
9D004B24  AFBE0004   SW FP, 4(SP)
9D004B28  03A0F021   ADDU FP, SP, ZERO
174:                     return PB_CLOCK;
9D004B2C  3C020131   LUI V0, 305
9D004B30  34422D00   ORI V0, V0, 11520
175:                 }
9D004B34  03C0E821   ADDU SP, FP, ZERO
9D004B38  8FBE0004   LW FP, 4(SP)
9D004B3C  27BD0008   ADDIU SP, SP, 8
9D004B40  03E00008   JR RA
9D004B44  00000000   NOP
176:                 
177:                 /**
178:                  * Function: BOARD_GetSysClock(void)
179:                  * @param None
180:                  * @return
181:                  */
182:                 unsigned int BOARD_GetSysClock() {
9D004B48  27BDFFF8   ADDIU SP, SP, -8
9D004B4C  AFBE0004   SW FP, 4(SP)
9D004B50  03A0F021   ADDU FP, SP, ZERO
183:                     return SYSTEM_CLOCK;
9D004B54  3C0204C4   LUI V0, 1220
9D004B58  3442B400   ORI V0, V0, -19456
184:                 }
9D004B5C  03C0E821   ADDU SP, FP, ZERO
9D004B60  8FBE0004   LW FP, 4(SP)
9D004B64  27BD0008   ADDIU SP, SP, 8
9D004B68  03E00008   JR RA
9D004B6C  00000000   NOP
185:                 
186:                 /*******************************************************************************
187:                  * PRIVATE FUNCTIONS                                                           *
188:                  ******************************************************************************/
189:                 
190:                 /**
191:                  * @Function SERIAL_Init(void)
192:                  * @param none
193:                  * @return none
194:                  * @brief  Initializes the UART subsystem to 115200 and sets up the circular buffer
195:                  * @author Max Dunne, 2011.11.10 */
196:                 
197:                 void SERIAL_Init(void) {
9D004B70  27BDFFE0   ADDIU SP, SP, -32
9D004B74  AFBF001C   SW RA, 28(SP)
9D004B78  AFBE0018   SW FP, 24(SP)
9D004B7C  03A0F021   ADDU FP, SP, ZERO
198:                 
199:                     // we first clear the Configs Register to ensure a blank state and peripheral is off.
200:                     U1MODE = 0;
9D004B80  3C02BF80   LUI V0, -16512
9D004B84  AC406000   SW ZERO, 24576(V0)
201:                     U1STA = 0;
9D004B88  3C02BF80   LUI V0, -16512
9D004B8C  AC406010   SW ZERO, 24592(V0)
202:                     //UARTConfigure(UART1, 0x00);
203:                 
204:                     //we then calculate the required frequency, note that this comes from plib source to avoid rounding errors
205:                     int sourceClock = BOARD_GetPBClock() >> 3;
9D004B90  0F4012C8   JAL BOARD_GetPBClock
9D004B94  00000000   NOP
9D004B98  000210C2   SRL V0, V0, 3
9D004B9C  AFC20010   SW V0, 16(FP)
206:                     int brg = sourceClock / 115200;
9D004BA0  8FC20010   LW V0, 16(FP)
9D004BA4  3C0391A2   LUI V1, -28254
9D004BA8  3463B3C5   ORI V1, V1, -19515
9D004BAC  00430018   MULT 0, V0, V1
9D004BB0  00001810   MFHI V1
9D004BB4  00621821   ADDU V1, V1, V0
9D004BB8  00031C03   SRA V1, V1, 16
9D004BBC  000217C3   SRA V0, V0, 31
9D004BC0  00621023   SUBU V0, V1, V0
9D004BC4  AFC20014   SW V0, 20(FP)
207:                     brg++;
9D004BC8  8FC20014   LW V0, 20(FP)
9D004BCC  24420001   ADDIU V0, V0, 1
9D004BD0  AFC20014   SW V0, 20(FP)
208:                     brg >>= 1;
9D004BD4  8FC20014   LW V0, 20(FP)
9D004BD8  00021043   SRA V0, V0, 1
9D004BDC  AFC20014   SW V0, 20(FP)
209:                     brg--;
9D004BE0  8FC20014   LW V0, 20(FP)
9D004BE4  2442FFFF   ADDIU V0, V0, -1
9D004BE8  AFC20014   SW V0, 20(FP)
210:                     U1BRG = brg;
9D004BEC  8FC30014   LW V1, 20(FP)
9D004BF0  3C02BF80   LUI V0, -16512
9D004BF4  AC436040   SW V1, 24640(V0)
211:                     //UARTSetDataRate(UART1, PB_CLOCK, 115200);
212:                     //UARTSetFifoMode(UART1, UART_INTERRUPT_ON_RX_NOT_EMPTY | UART_INTERRUPT_ON_RX_NOT_EMPTY);
213:                 
214:                     //we now enable the device
215:                 
216:                     U1STAbits.UTXEN = 1;
9D004BF8  3C03BF80   LUI V1, -16512
9D004BFC  8C626010   LW V0, 24592(V1)
9D004C00  24040001   ADDIU A0, ZERO, 1
9D004C04  7C825284   INS V0, A0, 10, 1
9D004C08  AC626010   SW V0, 24592(V1)
217:                     U1STAbits.URXEN = 1;
9D004C0C  3C03BF80   LUI V1, -16512
9D004C10  8C626010   LW V0, 24592(V1)
9D004C14  24040001   ADDIU A0, ZERO, 1
9D004C18  7C826304   INS V0, A0, 12, 1
9D004C1C  AC626010   SW V0, 24592(V1)
218:                     U1MODEbits.UARTEN = 1;
9D004C20  3C03BF80   LUI V1, -16512
9D004C24  94626000   LHU V0, 24576(V1)
9D004C28  24040001   ADDIU A0, ZERO, 1
9D004C2C  7C827BC4   INS V0, A0, 15, 1
9D004C30  A4626000   SH V0, 24576(V1)
219:                 
220:                     //UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_TX | UART_RX));
221:                     __XC_UART = 1;
9D004C34  24020001   ADDIU V0, ZERO, 1
9D004C38  AF828014   SW V0, -32748(GP)
222:                     //printf("\r\n%d\t%d",U1BRG,brg);
223:                 
224:                 }
9D004C3C  03C0E821   ADDU SP, FP, ZERO
9D004C40  8FBF001C   LW RA, 28(SP)
9D004C44  8FBE0018   LW FP, 24(SP)
9D004C48  27BD0020   ADDIU SP, SP, 32
9D004C4C  03E00008   JR RA
9D004C50  00000000   NOP
225:                 
226:                 
227:                 
228:                 /*******************************************************************************
229:                  * OVERRIDE FUNCTIONS                                                          *
230:                  ******************************************************************************/
231:                 
232:                 /**
233:                  * @Function read(int handle, void *buffer, unsigned int len)
234:                  * @param handle
235:                  * @param buffer
236:                  * @param len
237:                  * @return Returns the number of characters read into buffer
238:                  * @brief Overrides the built-in function called for scanf() to ensure proper functionality
239:                  */
240:                 
241:                 #ifndef LAB10_READ_OVERWRITE
242:                 
243:                 int read(int handle, char *buffer, unsigned int len) {
9D004C54  27BDFFF0   ADDIU SP, SP, -16
9D004C58  AFBE000C   SW FP, 12(SP)
9D004C5C  03A0F021   ADDU FP, SP, ZERO
9D004C60  AFC40010   SW A0, 16(FP)
9D004C64  AFC50014   SW A1, 20(FP)
9D004C68  AFC60018   SW A2, 24(FP)
244:                     int i;
245:                     if (handle == 0) {
9D004C6C  8FC20010   LW V0, 16(FP)
9D004C70  14400033   BNE V0, ZERO, 0x9D004D40
9D004C74  00000000   NOP
246:                         while (!U1STAbits.URXDA) {
9D004C78  0B40132C   J 0x9D004CB0
9D004C7C  00000000   NOP
9D004CB0  3C02BF80   LUI V0, -16512
9D004CB4  8C426010   LW V0, 24592(V0)
9D004CB8  30420001   ANDI V0, V0, 1
9D004CBC  1040FFF0   BEQ V0, ZERO, 0x9D004C80
9D004CC0  00000000   NOP
247:                             if (U1STAbits.OERR) {
9D004C80  3C02BF80   LUI V0, -16512
9D004C84  8C426010   LW V0, 24592(V0)
9D004C88  30420002   ANDI V0, V0, 2
9D004C8C  10400007   BEQ V0, ZERO, 0x9D004CAC
9D004C90  00000000   NOP
248:                                 U1STAbits.OERR = 0;
9D004C94  3C03BF80   LUI V1, -16512
9D004C98  8C626010   LW V0, 24592(V1)
9D004C9C  7C020844   INS V0, ZERO, 1, 1
9D004CA0  AC626010   SW V0, 24592(V1)
249:                             }
250:                             continue;
9D004CA4  0B40132B   J 0x9D004CAC
9D004CA8  00000000   NOP
9D004CAC  00000000   NOP
251:                         }
252:                         i = 0;
9D004CC4  AFC00000   SW ZERO, 0(FP)
253:                         while (U1STAbits.URXDA) {
9D004CC8  0B401348   J .LBE2
9D004CCC  00000000   NOP
9D004D20  3C02BF80   LUI V0, -16512
9D004D24  8C426010   LW V0, 24592(V0)
9D004D28  30420001   ANDI V0, V0, 1
9D004D2C  1440FFE8   BNE V0, ZERO, .LBB2
9D004D30  00000000   NOP
254:                             char tmp = U1RXREG;
9D004CD0  3C02BF80   LUI V0, -16512
9D004CD4  8C426030   LW V0, 24624(V0)
9D004CD8  A3C20004   SB V0, 4(FP)
255:                             if (tmp == '\r') {
9D004CDC  83C30004   LB V1, 4(FP)
9D004CE0  2402000D   ADDIU V0, ZERO, 13
9D004CE4  14620003   BNE V1, V0, 0x9D004CF4
9D004CE8  00000000   NOP
256:                                 tmp = '\n';
9D004CEC  2402000A   ADDIU V0, ZERO, 10
9D004CF0  A3C20004   SB V0, 4(FP)
257:                             }
258:                             *(char*) buffer++ = tmp;
9D004CF4  8FC20014   LW V0, 20(FP)
9D004CF8  24430001   ADDIU V1, V0, 1
9D004CFC  AFC30014   SW V1, 20(FP)
9D004D00  93C30004   LBU V1, 4(FP)
9D004D04  A0430000   SB V1, 0(V0)
259:                             //WriteUART1(tmp);
260:                             U1TXREG = tmp;
9D004D08  83C30004   LB V1, 4(FP)
9D004D0C  3C02BF80   LUI V0, -16512
9D004D10  AC436020   SW V1, 24608(V0)
261:                             i++;
9D004D14  8FC20000   LW V0, 0(FP)
9D004D18  24420001   ADDIU V0, V0, 1
9D004D1C  AFC20000   SW V0, 0(FP)
262:                         }
263:                         return i;
9D004D34  8FC20000   LW V0, 0(FP)
9D004D38  0B401351   J 0x9D004D44
9D004D3C  00000000   NOP
264:                     }
265:                     return 0;
9D004D40  00001021   ADDU V0, ZERO, ZERO
266:                 }
9D004D44  03C0E821   ADDU SP, FP, ZERO
267:                 #endif
268:                 
269:                 
270:                 
271:                 #ifdef BOARD_TEST
272:                 
273:                 int main(void) {
274:                     BOARD_Init();
275:                     printf("\r\nThis stub tests SERIAL Functionality with scanf");
276:                     printf("\r\nIt will intake integers and divide by 2");
277:                     printf("\r\n Peripheral Clock: %d", BOARD_GetPBClock());
278:                     printf("\r\n Peripheral Clock: %d\r\n", BOARD_GetSysClock());
279:                     char trash;
280:                     int input;
281:                     while (1) {
282:                         scanf("%d%c", &input, &trash);
283:                         printf("\r\nEntered: %d\t/2: %d\r\n", input, input / 2);
284:                     }
285:                     while (1);
286:                     return 0;
287:                 }
288:                 #endif
---  c:/users/autonomoussystemslab/dropbox/ce13/cmpe013/common/oled.c  ----------------------------------
9D002020  27BDFFE8   ADDIU SP, SP, -24
9D002024  AFBF0014   SW RA, 20(SP)
9D002028  AFBE0010   SW FP, 16(SP)
9D00202C  03A0F021   ADDU FP, SP, ZERO
9D002030  0F400D56   JAL OledHostInit
9D002034  00000000   NOP
9D002038  0F400D9B   JAL OledDriverInitDisplay
9D00203C  00000000   NOP
9D002040  00002021   ADDU A0, ZERO, ZERO
9D002044  0F4009AF   JAL OledClear
9D002048  00000000   NOP
9D00204C  0F400A03   JAL OledUpdate
9D002050  00000000   NOP
9D002054  03C0E821   ADDU SP, FP, ZERO
9D002058  8FBF0014   LW RA, 20(SP)
9D00205C  8FBE0010   LW FP, 16(SP)
9D002060  27BD0018   ADDIU SP, SP, 24
9D002064  03E00008   JR RA
9D002068  00000000   NOP
9D00206C  27BDFFF0   ADDIU SP, SP, -16
9D002070  AFBE000C   SW FP, 12(SP)
9D002074  03A0F021   ADDU FP, SP, ZERO
9D002078  AFC40010   SW A0, 16(FP)
9D00207C  AFC50014   SW A1, 20(FP)
9D002080  AFC60018   SW A2, 24(FP)
9D002084  8FC20010   LW V0, 16(FP)
9D002088  28420080   SLTI V0, V0, 128
9D00208C  1040000B   BEQ V0, ZERO, 0x9D0020BC
9D002090  00000000   NOP
9D002094  8FC20014   LW V0, 20(FP)
9D002098  28420020   SLTI V0, V0, 32
9D00209C  10400007   BEQ V0, ZERO, 0x9D0020BC
9D0020A0  00000000   NOP
9D0020A4  8FC20010   LW V0, 16(FP)
9D0020A8  04400004   BLTZ V0, 0x9D0020BC
9D0020AC  00000000   NOP
9D0020B0  8FC20014   LW V0, 20(FP)
9D0020B4  04410003   BGEZ V0, 0x9D0020C4
9D0020B8  00000000   NOP
9D0020BC  0B40086C   J 0x9D0021B0
9D0020C0  00000000   NOP
9D0020C4  8FC20014   LW V0, 20(FP)
9D0020C8  3042FFF8   ANDI V0, V0, -8
9D0020CC  00021900   SLL V1, V0, 4
9D0020D0  8FC20010   LW V0, 16(FP)
9D0020D4  00621021   ADDU V0, V1, V0
9D0020D8  AFC20000   SW V0, 0(FP)
9D0020DC  8FC20014   LW V0, 20(FP)
9D0020E0  30420007   ANDI V0, V0, 7
9D0020E4  AFC20004   SW V0, 4(FP)
9D0020E8  8FC30018   LW V1, 24(FP)
9D0020EC  24020001   ADDIU V0, ZERO, 1
9D0020F0  14620015   BNE V1, V0, 0x9D002148
9D0020F4  00000000   NOP
9D0020F8  3C02A000   LUI V0, -24576
9D0020FC  24430220   ADDIU V1, V0, 544
9D002100  8FC20000   LW V0, 0(FP)
9D002104  00621021   ADDU V0, V1, V0
9D002108  90420000   LBU V0, 0(V0)
9D00210C  7C021C20   SEB V1, V0
9D002110  8FC20004   LW V0, 4(FP)
9D002114  24040001   ADDIU A0, ZERO, 1
9D002118  00441004   SLLV V0, A0, V0
9D00211C  7C021420   SEB V0, V0
9D002120  00621025   OR V0, V1, V0
9D002124  7C021420   SEB V0, V0
9D002128  304300FF   ANDI V1, V0, 255
9D00212C  3C02A000   LUI V0, -24576
9D002130  24440220   ADDIU A0, V0, 544
9D002134  8FC20000   LW V0, 0(FP)
9D002138  00821021   ADDU V0, A0, V0
9D00213C  A0430000   SB V1, 0(V0)
9D002140  0B40086C   J 0x9D0021B0
9D002144  00000000   NOP
9D002148  8FC20018   LW V0, 24(FP)
9D00214C  14400017   BNE V0, ZERO, 0x9D0021AC
9D002150  00000000   NOP
9D002154  3C02A000   LUI V0, -24576
9D002158  24430220   ADDIU V1, V0, 544
9D00215C  8FC20000   LW V0, 0(FP)
9D002160  00621021   ADDU V0, V1, V0
9D002164  90420000   LBU V0, 0(V0)
9D002168  7C021C20   SEB V1, V0
9D00216C  8FC20004   LW V0, 4(FP)
9D002170  24040001   ADDIU A0, ZERO, 1
9D002174  00441004   SLLV V0, A0, V0
9D002178  7C021420   SEB V0, V0
9D00217C  00021027   NOR V0, ZERO, V0
9D002180  7C021420   SEB V0, V0
9D002184  00621024   AND V0, V1, V0
9D002188  7C021420   SEB V0, V0
9D00218C  304300FF   ANDI V1, V0, 255
9D002190  3C02A000   LUI V0, -24576
9D002194  24440220   ADDIU A0, V0, 544
9D002198  8FC20000   LW V0, 0(FP)
9D00219C  00821021   ADDU V0, A0, V0
9D0021A0  A0430000   SB V1, 0(V0)
9D0021A4  0B40086C   J 0x9D0021B0
9D0021A8  00000000   NOP
9D0021AC  00000000   NOP
9D0021B0  03C0E821   ADDU SP, FP, ZERO
9D0021B4  8FBE000C   LW FP, 12(SP)
9D0021B8  27BD0010   ADDIU SP, SP, 16
9D0021BC  03E00008   JR RA
9D0021C0  00000000   NOP
9D0021C4  27BDFFF0   ADDIU SP, SP, -16
9D0021C8  AFBE000C   SW FP, 12(SP)
9D0021CC  03A0F021   ADDU FP, SP, ZERO
9D0021D0  AFC40010   SW A0, 16(FP)
9D0021D4  AFC50014   SW A1, 20(FP)
9D0021D8  8FC20010   LW V0, 16(FP)
9D0021DC  28420080   SLTI V0, V0, 128
9D0021E0  1040000B   BEQ V0, ZERO, 0x9D002210
9D0021E4  00000000   NOP
9D0021E8  8FC20014   LW V0, 20(FP)
9D0021EC  28420020   SLTI V0, V0, 32
9D0021F0  10400007   BEQ V0, ZERO, 0x9D002210
9D0021F4  00000000   NOP
9D0021F8  8FC20010   LW V0, 16(FP)
9D0021FC  04400004   BLTZ V0, 0x9D002210
9D002200  00000000   NOP
9D002204  8FC20014   LW V0, 20(FP)
9D002208  04410004   BGEZ V0, 0x9D00221C
9D00220C  00000000   NOP
9D002210  00001021   ADDU V0, ZERO, ZERO
9D002214  0B400899   J 0x9D002264
9D002218  00000000   NOP
9D00221C  8FC20014   LW V0, 20(FP)
9D002220  3042FFF8   ANDI V0, V0, -8
9D002224  00021900   SLL V1, V0, 4
9D002228  8FC20010   LW V0, 16(FP)
9D00222C  00621021   ADDU V0, V1, V0
9D002230  AFC20000   SW V0, 0(FP)
9D002234  8FC20014   LW V0, 20(FP)
9D002238  30420007   ANDI V0, V0, 7
9D00223C  AFC20004   SW V0, 4(FP)
9D002240  3C02A000   LUI V0, -24576
9D002244  24430220   ADDIU V1, V0, 544
9D002248  8FC20000   LW V0, 0(FP)
9D00224C  00621021   ADDU V0, V1, V0
9D002250  90420000   LBU V0, 0(V0)
9D002254  00401821   ADDU V1, V0, ZERO
9D002258  8FC20004   LW V0, 4(FP)
9D00225C  00431007   SRAV V0, V1, V0
9D002260  30420001   ANDI V0, V0, 1
9D002264  03C0E821   ADDU SP, FP, ZERO
9D002268  8FBE000C   LW FP, 12(SP)
9D00226C  27BD0010   ADDIU SP, SP, 16
9D002270  03E00008   JR RA
9D002274  00000000   NOP
9D002278  27BDFFC0   ADDIU SP, SP, -64
9D00227C  AFBE003C   SW FP, 60(SP)
9D002280  03A0F021   ADDU FP, SP, ZERO
9D002284  AFC40040   SW A0, 64(FP)
9D002288  AFC50044   SW A1, 68(FP)
9D00228C  00C01021   ADDU V0, A2, ZERO
9D002290  A3C20048   SB V0, 72(FP)
9D002294  8FC20040   LW V0, 64(FP)
9D002298  2842007B   SLTI V0, V0, 123
9D00229C  104000B3   BEQ V0, ZERO, .LBE5, .LBE2
9D0022A0  00000000   NOP
9D0022A4  8FC20044   LW V0, 68(FP)
9D0022A8  28420019   SLTI V0, V0, 25
9D0022AC  104000AF   BEQ V0, ZERO, .LBE5, .LBE2
9D0022B0  00000000   NOP
9D0022B4  93C20048   LBU V0, 72(FP)
9D0022B8  AFC20008   SW V0, 8(FP)
9D0022BC  8FC20044   LW V0, 68(FP)
9D0022C0  24430007   ADDIU V1, V0, 7
9D0022C4  28440000   SLTI A0, V0, 0
9D0022C8  0064100B   MOVN V0, V1, A0
9D0022CC  000210C3   SRA V0, V0, 3
9D0022D0  AFC2000C   SW V0, 12(FP)
9D0022D4  8FC30044   LW V1, 68(FP)
9D0022D8  000317C3   SRA V0, V1, 31
9D0022DC  00021742   SRL V0, V0, 29
9D0022E0  00621821   ADDU V1, V1, V0
9D0022E4  30630007   ANDI V1, V1, 7
9D0022E8  00621023   SUBU V0, V1, V0
9D0022EC  AFC20010   SW V0, 16(FP)
9D0022F0  8FC20044   LW V0, 68(FP)
9D0022F4  24420008   ADDIU V0, V0, 8
9D0022F8  24430007   ADDIU V1, V0, 7
9D0022FC  28440000   SLTI A0, V0, 0
9D002300  0064100B   MOVN V0, V1, A0
9D002304  000210C3   SRA V0, V0, 3
9D002308  AFC20014   SW V0, 20(FP)
9D00230C  8FC20040   LW V0, 64(FP)
9D002310  AFC20018   SW V0, 24(FP)
9D002314  8FC20040   LW V0, 64(FP)
9D002318  24420006   ADDIU V0, V0, 6
9D00231C  AFC2001C   SW V0, 28(FP)
9D002320  240300FF   ADDIU V1, ZERO, 255
9D002324  8FC20010   LW V0, 16(FP)
9D002328  00431004   SLLV V0, V1, V0
9D00232C  AFC20020   SW V0, 32(FP)
9D002330  AFC00000   SW ZERO, 0(FP)
9D002334  0B400905   J 0x9D002414
9D002338  00000000   NOP
9D002408  8FC20000   LW V0, 0(FP)
9D00240C  24420001   ADDIU V0, V0, 1
9D002410  AFC20000   SW V0, 0(FP)
9D002414  8FC3001C   LW V1, 28(FP)
9D002418  8FC20018   LW V0, 24(FP)
9D00241C  00621823   SUBU V1, V1, V0
9D002420  8FC20000   LW V0, 0(FP)
9D002424  0043102A   SLT V0, V0, V1
9D002428  1440FFC4   BNE V0, ZERO, .LBB4
9D00242C  00000000   NOP
9D00233C  8FC30018   LW V1, 24(FP)
9D002340  8FC20000   LW V0, 0(FP)
9D002344  00621021   ADDU V0, V1, V0
9D002348  AFC20024   SW V0, 36(FP)
9D00234C  8FC2000C   LW V0, 12(FP)
9D002350  000219C0   SLL V1, V0, 7
9D002354  8FC20024   LW V0, 36(FP)
9D002358  00621821   ADDU V1, V1, V0
9D00235C  3C02A000   LUI V0, -24576
9D002360  24420220   ADDIU V0, V0, 544
9D002364  00621021   ADDU V0, V1, V0
9D002368  90420000   LBU V0, 0(V0)
9D00236C  7C021C20   SEB V1, V0
9D002370  8FC20020   LW V0, 32(FP)
9D002374  7C021420   SEB V0, V0
9D002378  00021027   NOR V0, ZERO, V0
9D00237C  7C021420   SEB V0, V0
9D002380  00621024   AND V0, V1, V0
9D002384  7C021420   SEB V0, V0
9D002388  A3C20028   SB V0, 40(FP)
9D00238C  3C049D00   LUI A0, -25344
9D002390  8FC20008   LW V0, 8(FP)
9D002394  00021040   SLL V0, V0, 1
9D002398  00021880   SLL V1, V0, 2
9D00239C  00621823   SUBU V1, V1, V0
9D0023A0  8FC20000   LW V0, 0(FP)
9D0023A4  00621821   ADDU V1, V1, V0
9D0023A8  24822F58   ADDIU V0, A0, 12120
9D0023AC  00621021   ADDU V0, V1, V0
9D0023B0  90420000   LBU V0, 0(V0)
9D0023B4  00401821   ADDU V1, V0, ZERO
9D0023B8  8FC40020   LW A0, 32(FP)
9D0023BC  8FC20010   LW V0, 16(FP)
9D0023C0  00441007   SRAV V0, A0, V0
9D0023C4  00621824   AND V1, V1, V0
9D0023C8  8FC20010   LW V0, 16(FP)
9D0023CC  00431004   SLLV V0, V1, V0
9D0023D0  7C021C20   SEB V1, V0
9D0023D4  83C20028   LB V0, 40(FP)
9D0023D8  00621025   OR V0, V1, V0
9D0023DC  7C021420   SEB V0, V0
9D0023E0  A3C20028   SB V0, 40(FP)
9D0023E4  8FC2000C   LW V0, 12(FP)
9D0023E8  000219C0   SLL V1, V0, 7
9D0023EC  8FC20024   LW V0, 36(FP)
9D0023F0  00621821   ADDU V1, V1, V0
9D0023F4  3C02A000   LUI V0, -24576
9D0023F8  24420220   ADDIU V0, V0, 544
9D0023FC  00621021   ADDU V0, V1, V0
9D002400  93C30028   LBU V1, 40(FP)
9D002404  A0430000   SB V1, 0(V0)
9D002430  8FC30014   LW V1, 20(FP)
9D002434  8FC2000C   LW V0, 12(FP)
9D002438  0043102A   SLT V0, V0, V1
9D00243C  1040004B   BEQ V0, ZERO, .LBE5, .LBE2
9D002440  00000000   NOP
9D002444  24030008   ADDIU V1, ZERO, 8
9D002448  8FC20010   LW V0, 16(FP)
9D00244C  00621023   SUBU V0, V1, V0
9D002450  240300FF   ADDIU V1, ZERO, 255
9D002454  00431007   SRAV V0, V1, V0
9D002458  AFC2002C   SW V0, 44(FP)
9D00245C  AFC00004   SW ZERO, 4(FP)
9D002460  0B400954   J 0x9D002550
9D002464  00000000   NOP
9D002544  8FC20004   LW V0, 4(FP)
9D002548  24420001   ADDIU V0, V0, 1
9D00254C  AFC20004   SW V0, 4(FP)
9D002550  8FC3001C   LW V1, 28(FP)
9D002554  8FC20018   LW V0, 24(FP)
9D002558  00621823   SUBU V1, V1, V0
9D00255C  8FC20004   LW V0, 4(FP)
9D002560  0043102A   SLT V0, V0, V1
9D002564  1440FFC0   BNE V0, ZERO, .LBB6
9D002568  00000000   NOP
9D002468  8FC30018   LW V1, 24(FP)
9D00246C  8FC20004   LW V0, 4(FP)
9D002470  00621021   ADDU V0, V1, V0
9D002474  AFC20030   SW V0, 48(FP)
9D002478  8FC20014   LW V0, 20(FP)
9D00247C  000219C0   SLL V1, V0, 7
9D002480  8FC20030   LW V0, 48(FP)
9D002484  00621821   ADDU V1, V1, V0
9D002488  3C02A000   LUI V0, -24576
9D00248C  24420220   ADDIU V0, V0, 544
9D002490  00621021   ADDU V0, V1, V0
9D002494  90420000   LBU V0, 0(V0)
9D002498  7C021C20   SEB V1, V0
9D00249C  8FC2002C   LW V0, 44(FP)
9D0024A0  7C021420   SEB V0, V0
9D0024A4  00021027   NOR V0, ZERO, V0
9D0024A8  7C021420   SEB V0, V0
9D0024AC  00621024   AND V0, V1, V0
9D0024B0  7C021420   SEB V0, V0
9D0024B4  A3C20034   SB V0, 52(FP)
9D0024B8  3C049D00   LUI A0, -25344
9D0024BC  8FC20008   LW V0, 8(FP)
9D0024C0  00021040   SLL V0, V0, 1
9D0024C4  00021880   SLL V1, V0, 2
9D0024C8  00621823   SUBU V1, V1, V0
9D0024CC  8FC20004   LW V0, 4(FP)
9D0024D0  00621821   ADDU V1, V1, V0
9D0024D4  24822F58   ADDIU V0, A0, 12120
9D0024D8  00621021   ADDU V0, V1, V0
9D0024DC  90420000   LBU V0, 0(V0)
9D0024E0  00401821   ADDU V1, V0, ZERO
9D0024E4  24040008   ADDIU A0, ZERO, 8
9D0024E8  8FC20010   LW V0, 16(FP)
9D0024EC  00821023   SUBU V0, A0, V0
9D0024F0  8FC4002C   LW A0, 44(FP)
9D0024F4  00441004   SLLV V0, A0, V0
9D0024F8  00621824   AND V1, V1, V0
9D002508  00431007   SRAV V0, V1, V0
9D00250C  7C021C20   SEB V1, V0
9D002510  83C20034   LB V0, 52(FP)
9D002514  00621025   OR V0, V1, V0
9D002518  7C021420   SEB V0, V0
9D00251C  A3C20034   SB V0, 52(FP)
9D0024FC  24040008   ADDIU A0, ZERO, 8
9D002500  8FC20010   LW V0, 16(FP)
9D002504  00821023   SUBU V0, A0, V0
9D002520  8FC20014   LW V0, 20(FP)
9D002524  000219C0   SLL V1, V0, 7
9D002528  8FC20030   LW V0, 48(FP)
9D00252C  00621821   ADDU V1, V1, V0
9D002530  3C02A000   LUI V0, -24576
9D002534  24420220   ADDIU V0, V0, 544
9D002538  00621021   ADDU V0, V1, V0
9D00253C  93C30034   LBU V1, 52(FP)
9D002540  A0430000   SB V1, 0(V0)
9D00256C  00001021   ADDU V0, ZERO, ZERO
9D002570  03C0E821   ADDU SP, FP, ZERO
9D002574  8FBE003C   LW FP, 60(SP)
9D002578  27BD0040   ADDIU SP, SP, 64
9D00257C  03E00008   JR RA
9D002580  00000000   NOP
9D002584  27BDFFD8   ADDIU SP, SP, -40
9D002588  AFBF0024   SW RA, 36(SP)
9D00258C  AFBE0020   SW FP, 32(SP)
9D002590  03A0F021   ADDU FP, SP, ZERO
9D002594  AFC40028   SW A0, 40(FP)
9D002598  8FC20028   LW V0, 40(FP)
9D00259C  14400003   BNE V0, ZERO, 0x9D0025AC
9D0025A0  00000000   NOP
9D0025A4  0B4009A9   J 0x9D0026A4
9D0025A8  00000000   NOP
9D0025AC  AFC00010   SW ZERO, 16(FP)
9D0025B0  AFC00014   SW ZERO, 20(FP)
9D0025B4  AFC00018   SW ZERO, 24(FP)
9D0025B8  0B40099F   J 0x9D00267C
9D0025BC  00000000   NOP
9D002670  8FC20018   LW V0, 24(FP)
9D002674  24420001   ADDIU V0, V0, 1
9D002678  AFC20018   SW V0, 24(FP)
9D00267C  8FC20018   LW V0, 24(FP)
9D002680  8FC30028   LW V1, 40(FP)
9D002684  00621021   ADDU V0, V1, V0
9D002688  80420000   LB V0, 0(V0)
9D00268C  10400005   BEQ V0, ZERO, 0x9D0026A4
9D002690  00000000   NOP
9D002694  8FC20018   LW V0, 24(FP)
9D002698  28420057   SLTI V0, V0, 87
9D00269C  1440FFC8   BNE V0, ZERO, 0x9D0025C0
9D0026A0  00000000   NOP
9D0025C0  8FC20018   LW V0, 24(FP)
9D0025C4  8FC30028   LW V1, 40(FP)
9D0025C8  00621021   ADDU V0, V1, V0
9D0025CC  80430000   LB V1, 0(V0)
9D0025D0  2402000A   ADDIU V0, ZERO, 10
9D0025D4  14620007   BNE V1, V0, 0x9D0025F4
9D0025D8  00000000   NOP
9D0025DC  8FC20010   LW V0, 16(FP)
9D0025E0  24420001   ADDIU V0, V0, 1
9D0025E4  AFC20010   SW V0, 16(FP)
9D0025E8  AFC00014   SW ZERO, 20(FP)
9D0025EC  0B40099C   J 0x9D002670
9D0025F0  00000000   NOP
9D0025F4  8FC30014   LW V1, 20(FP)
9D0025F8  24020015   ADDIU V0, ZERO, 21
9D0025FC  14620005   BNE V1, V0, 0x9D002614
9D002600  00000000   NOP
9D002604  8FC20010   LW V0, 16(FP)
9D002608  24420001   ADDIU V0, V0, 1
9D00260C  AFC20010   SW V0, 16(FP)
9D002610  AFC00014   SW ZERO, 20(FP)
9D002614  8FC30010   LW V1, 16(FP)
9D002618  24020004   ADDIU V0, ZERO, 4
9D00261C  14620003   BNE V1, V0, 0x9D00262C
9D002620  00000000   NOP
9D002624  0B4009A9   J 0x9D0026A4
9D002628  00000000   NOP
9D00262C  8FC20014   LW V0, 20(FP)
9D002630  00021040   SLL V0, V0, 1
9D002634  00021880   SLL V1, V0, 2
9D002638  00622023   SUBU A0, V1, V0
9D00263C  8FC20010   LW V0, 16(FP)
9D002640  000218C0   SLL V1, V0, 3
9D002644  8FC20018   LW V0, 24(FP)
9D002648  8FC50028   LW A1, 40(FP)
9D00264C  00A21021   ADDU V0, A1, V0
9D002650  80420000   LB V0, 0(V0)
9D002654  00602821   ADDU A1, V1, ZERO
9D002658  00403021   ADDU A2, V0, ZERO
9D00265C  0F40089E   JAL OledDrawChar
9D002660  00000000   NOP
9D002664  8FC20014   LW V0, 20(FP)
9D002668  24420001   ADDIU V0, V0, 1
9D00266C  AFC20014   SW V0, 20(FP)
9D0026A4  03C0E821   ADDU SP, FP, ZERO
9D0026A8  8FBF0024   LW RA, 36(SP)
9D0026AC  8FBE0020   LW FP, 32(SP)
9D0026B0  27BD0028   ADDIU SP, SP, 40
9D0026B4  03E00008   JR RA
9D0026B8  00000000   NOP
9D0026BC  27BDFFF0   ADDIU SP, SP, -16
9D0026C0  AFBE000C   SW FP, 12(SP)
9D0026C4  03A0F021   ADDU FP, SP, ZERO
9D0026C8  AFC40010   SW A0, 16(FP)
9D0026CC  AFC00000   SW ZERO, 0(FP)
9D0026D0  0B4009CA   J 0x9D002728
9D0026D4  00000000   NOP
9D00271C  8FC20000   LW V0, 0(FP)
9D002720  24420001   ADDIU V0, V0, 1
9D002724  AFC20000   SW V0, 0(FP)
9D002728  8FC20000   LW V0, 0(FP)
9D00272C  28420200   SLTI V0, V0, 512
9D002730  1440FFE9   BNE V0, ZERO, 0x9D0026D8
9D002734  00000000   NOP
9D0026D8  8FC30010   LW V1, 16(FP)
9D0026DC  24020001   ADDIU V0, ZERO, 1
9D0026E0  14620009   BNE V1, V0, 0x9D002708
9D0026E4  00000000   NOP
9D0026E8  3C02A000   LUI V0, -24576
9D0026EC  24430220   ADDIU V1, V0, 544
9D0026F0  8FC20000   LW V0, 0(FP)
9D0026F4  00621021   ADDU V0, V1, V0
9D0026F8  2403FFFF   ADDIU V1, ZERO, -1
9D0026FC  A0430000   SB V1, 0(V0)
9D002700  0B4009C7   J 0x9D00271C
9D002704  00000000   NOP
9D002708  3C02A000   LUI V0, -24576
9D00270C  24430220   ADDIU V1, V0, 544
9D002710  8FC20000   LW V0, 0(FP)
9D002714  00621021   ADDU V0, V1, V0
9D002718  A0400000   SB ZERO, 0(V0)
9D002738  03C0E821   ADDU SP, FP, ZERO
9D00273C  8FBE000C   LW FP, 12(SP)
9D002740  27BD0010   ADDIU SP, SP, 16
9D002744  03E00008   JR RA
9D002748  00000000   NOP
9D00274C  27BDFFE8   ADDIU SP, SP, -24
9D002750  AFBF0014   SW RA, 20(SP)
9D002754  AFBE0010   SW FP, 16(SP)
9D002758  03A0F021   ADDU FP, SP, ZERO
9D00275C  0F400DE1   JAL OledDriverSetDisplayInverted
9D002760  00000000   NOP
9D002764  03C0E821   ADDU SP, FP, ZERO
9D002768  8FBF0014   LW RA, 20(SP)
9D00276C  8FBE0010   LW FP, 16(SP)
9D002770  27BD0018   ADDIU SP, SP, 24
9D002774  03E00008   JR RA
9D002778  00000000   NOP
9D00277C  27BDFFE8   ADDIU SP, SP, -24
9D002780  AFBF0014   SW RA, 20(SP)
9D002784  AFBE0010   SW FP, 16(SP)
9D002788  03A0F021   ADDU FP, SP, ZERO
9D00278C  0F400DF2   JAL OledDriverSetDisplayNormal
9D002790  00000000   NOP
9D002794  03C0E821   ADDU SP, FP, ZERO
9D002798  8FBF0014   LW RA, 20(SP)
9D00279C  8FBE0010   LW FP, 16(SP)
9D0027A0  27BD0018   ADDIU SP, SP, 24
9D0027A4  03E00008   JR RA
9D0027A8  00000000   NOP
9D0027AC  27BDFFE8   ADDIU SP, SP, -24
9D0027B0  AFBF0014   SW RA, 20(SP)
9D0027B4  AFBE0010   SW FP, 16(SP)
9D0027B8  03A0F021   ADDU FP, SP, ZERO
9D0027BC  0F400D9B   JAL OledDriverInitDisplay
9D0027C0  00000000   NOP
9D0027C4  03C0E821   ADDU SP, FP, ZERO
9D0027C8  8FBF0014   LW RA, 20(SP)
9D0027CC  8FBE0010   LW FP, 16(SP)
9D0027D0  27BD0018   ADDIU SP, SP, 24
9D0027D4  03E00008   JR RA
9D0027D8  00000000   NOP
9D0027DC  27BDFFE8   ADDIU SP, SP, -24
9D0027E0  AFBF0014   SW RA, 20(SP)
9D0027E4  AFBE0010   SW FP, 16(SP)
9D0027E8  03A0F021   ADDU FP, SP, ZERO
9D0027EC  0F400E03   JAL OledDriverDisableDisplay
9D0027F0  00000000   NOP
9D0027F4  03C0E821   ADDU SP, FP, ZERO
9D0027F8  8FBF0014   LW RA, 20(SP)
9D0027FC  8FBE0010   LW FP, 16(SP)
9D002800  27BD0018   ADDIU SP, SP, 24
9D002804  03E00008   JR RA
9D002808  00000000   NOP
9D00280C  27BDFFE8   ADDIU SP, SP, -24
9D002810  AFBF0014   SW RA, 20(SP)
9D002814  AFBE0010   SW FP, 16(SP)
9D002818  03A0F021   ADDU FP, SP, ZERO
9D00281C  0F400E23   JAL OledDriverUpdateDisplay
9D002820  00000000   NOP
9D002824  03C0E821   ADDU SP, FP, ZERO
---  c:/program files (x86)/microchip/xc32/v2.15/pic32mx/lib/crt0.S  ------------------------------------
                                                  1:     /*********************************************************************
                                                  2:      *
                                                  3:      *                  C Runtime Startup
                                                  4:      *
                                                  5:      *********************************************************************
                                                  6:      * Filename:        crt0.S
                                                  7:      *
                                                  8:      * Processor:       PIC32
                                                  9:      *
                                                  10:     * Compiler:        MPLAB XC32
                                                  11:     *                  MPLAB X IDE
                                                  12:     * Company:         Microchip Technology Inc.
                                                  13:     *
                                                  14:     * Software License Agreement
                                                  15:     *
                                                  16:     * Copyright (c) 2014, Microchip Technology Inc. and its subsidiaries ("Microchip")
                                                  17:     * All rights reserved.
                                                  18:     *
                                                  19:     * This software is developed by Microchip Technology Inc. and its
                                                  20:     * subsidiaries ("Microchip").
                                                  21:     *
                                                  22:     * Redistribution and use in source and binary forms, with or without
                                                  23:     * modification, are permitted provided that the following conditions are met:
                                                  24:     *
                                                  25:     * 1.      Redistributions of source code must retain the above copyright
                                                  26:     * notice, this list of conditions and the following disclaimer.
                                                  27:     *
                                                  28:     * 2.      Redistributions in binary form must reproduce the above copyright
                                                  29:     * notice, this list of conditions and the following disclaimer in the
                                                  30:     * documentation and/or other materials provided with the distribution.
                                                  31:     *
                                                  32:     * 3.      Microchip's name may not be used to endorse or promote products
                                                  33:     * derived from this software without specific prior written permission.
                                                  34:     *
                                                  35:     * THIS SOFTWARE IS PROVIDED BY MICROCHIP "AS IS" AND ANY EXPRESS OR IMPLIED
                                                  36:     * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
                                                  37:     * MERCHANTABILITY AND FITNESS FOR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
                                                  38:     * MICROCHIP BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
                                                  39:     * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING BUT NOT LIMITED TO
                                                  40:     * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA OR PROFITS;
                                                  41:     * OR BUSINESS INTERRUPTION) HOWSOEVER CAUSED AND ON ANY THEORY OF LIABILITY,
                                                  42:     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
                                                  43:     * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
                                                  44:     * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                                  45:     *
                                                  46:     ********************************************************************/
                                                  47:    
                                                  48:    #include "xc.h"
                                                  49:    #include <cp0defs.h>
                                                  50:    
                                                  51:    #ifdef __LIBBUILD__
                                                  52:       # Replace the standard debugging information with a simple filename. This
                                                  53:       # prevents the library build directory from showing up in MPLAB IDE. It
                                                  54:       # also effectively disables source-line debugging.
                                                  55:       .file 1 "libpic32/startup/crt0.S"
                                                  56:       .loc 1 0
                                                  57:    #endif
                                                  58:    
                                                  59:    #if (__XC32_VERSION > 1000) && !defined(CPP_INIT)
                                                  60:    #define CPP_INIT
                                                  61:    #endif
                                                  62:    
                                                  63:    #if !defined(PIC32_SRS_SET_COUNT)
                                                  64:    #  if defined(__PIC32_SRS_SET_COUNT)
                                                  65:    #    define PIC32_SRS_SET_COUNT __PIC32_SRS_SET_COUNT
                                                  66:    #  else
                                                  67:    #    warning PIC32_SRS_SET_COUNT not defined on build line
                                                  68:    #    define PIC32_SRS_SET_COUNT 2
                                                  69:    #  endif
                                                  70:    #endif
                                                  71:    
                                                  72:    #if defined(__PIC32MX) || defined(__PIC32MM) || defined(__PIC32MZ)
                                                  73:    #define INIT_DATA 1
                                                  74:    #endif
                                                  75:    
                                                  76:    /* This file contains 32-bit assembly code */
                                                  77:           .set nomips16
                                                  78:    
                                                  79:            ##################################################################
                                                  80:            # Entry point of the entire application
                                                  81:            ##################################################################
                                                  82:            .section .reset,code,keep
                                                  83:            .align 2
                                                  84:            .set noreorder
                                                  85:            .ent _reset
                                                  86:    
                                                  87:    ############################
                                                  88:    # Begin ISA switching code #
                                                  89:    ############################
                                                  90:    
                                                  91:    #if defined (__mips_micromips)
                                                  92:            .set micromips
                                                  93:    #endif
                                                  94:    
                                                  95:    #if (defined(__PIC32_HAS_MICROMIPS)) && (defined(__PIC32_HAS_MIPS32R2))
                                                  96:    _reset:
                                                  97:            .word 0x10000003     /* MIPS32:    branch forward 0x10 bytes from here  */
                                                  98:                                 /* MicroMIPS: ADDI32 $0, $0, 0x0007 (nop)          */
                                                  99:                                 /* DO NOT change the relative branch               */
                                                  100:   
                                                  101:           .word 0x00000000     /* NOP */
                                                  102:   __reset_micromips_isa:
                                                  103:           .set    micromips
                                                  104:           jal     _startup
                                                  105:           nop
                                                  106:   
                                                  107:           .align 2
                                                  108:           /* Device not in proper ISA mode */
                                                  109:           .set nomicromips
                                                  110:   __reset_switch_isa:
                                                  111:           jal _startup
                                                  112:           nop
                                                  113:   
                                                  114:   #else
                                                  115:   
                                                  116:   _reset:
BFC00000  0FF00002   JAL 0xBFC00008               117:           jal _startup
BFC00004  00000000   NOP                          118:           nop
                                                  119:   
                                                  120:   #endif  /* __PIC32_HAS_MICROMIPS */
                                                  121:   
                                                  122:           .align 2
                                                  123:           .end _reset
                                                  124:           .globl _reset
                                                  125:           .size _reset, .-_reset
                                                  126:   
                                                  127:           .section .reset.startup,code,keep
                                                  128:           .align 2
                                                  129:           .set noreorder
                                                  130:   
                                                  131:   #if defined (__mips_micromips)
                                                  132:           .set micromips
                                                  133:   #else
                                                  134:           .set nomicromips
                                                  135:   #endif
                                                  136:   
                                                  137:   ############################
                                                  138:   # End ISA switching code   #
                                                  139:   ############################
                                                  140:   
                                                  141:           ##################################################################
                                                  142:           # Startup code
                                                  143:           ##################################################################
                                                  144:           .align 2
                                                  145:           .globl _startup
                                                  146:           .set noreorder
                                                  147:           .ent _startup
                                                  148:   _startup:
                                                  149:           ##################################################################
                                                  150:           # If entered because of an NMI, jump to the NMI handler.
                                                  151:           ##################################################################
BFC00008  401A6000   MFC0 K0, Status              152:           mfc0    k0,_CP0_STATUS
BFC0000C  7F5A04C0   EXT K0, K0, 19, 1            153:           ext     k0,k0,19,1              # Extract NMI bit
BFC00010  13400005   BEQ K0, ZERO, 0xBFC00028     154:           beqz    k0,_no_nmi
BFC00014  00000000   NOP                          155:           nop
BFC00018  3C1A9D00   LUI K0, -25344               156:           la      k0,_nmi_handler
BFC00020  03400008   JR K0                        157:           jr      k0
BFC00024  00000000   NOP                          158:           nop
                                                  159:   _no_nmi:
                                                  160:   
                                                  161:           ##################################################################
                                                  162:           # Initialize Stack Pointer
                                                  163:           #   _stack is initialized by the linker script to point to the
                                                  164:           #    starting location of the stack in DRM
                                                  165:           ##################################################################
BFC00028  3C1DA000   LUI SP, -24576               166:           la      sp,_stack
                                                  167:   
                                                  168:           ##################################################################
                                                  169:           # Initialize Global Pointer
                                                  170:           #   _gp is initialized by the linker script to point to "middle"
                                                  171:           #   of the small variables region
                                                  172:           ##################################################################
BFC00030  3C1CA001   LUI GP, -24575               173:           la      gp,_gp
                                                  174:   
                                                  175:   #if (PIC32_SRS_SET_COUNT == 2)
                                                  176:           ##################################################################
                                                  177:           # Initialize Global Pointer in Shadow Set
                                                  178:           #   The SRSCtl's PSS field must be set to the shadow set in which
                                                  179:           #   to initialize the global pointer.  Since we have only a
                                                  180:           #   single shadow set (besides the normal), we will initialize
                                                  181:           #   SRSCtl<PSS> to SRSCtl<HSS>.  We then write the global pointer
                                                  182:           #   to the previous shadow set to ensure that on interrupt, the
                                                  183:           #   global pointer has been initialized.
                                                  184:           ##################################################################
BFC00038  40096002   MFC0 T1, SRSCtl              185:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
BFC0003C  01205820   ADD T3, T1, ZERO             186:           add     t3,t1,zero              # Save off current SRSCtl
BFC00040  7D2A1E80   EXT T2, T1, 26, 4            187:           ext     t2,t1,26,4              # to obtain HSS field
BFC00044  7D494984   INS T1, T2, 6, 4             188:           ins     t1,t2,6,4               # Put HSS field
BFC00048  40896002   MTC0 T1, SRSCtl              189:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
BFC0004C  000000C0   EHB                          190:           ehb                             # Clear hazard before using new SRSCTL
BFC00050  41DCE000   WRPGPR GP, GP                191:           wrpgpr  gp,gp                   # Set global pointer in PSS
BFC00054  408B6002   MTC0 T3, SRSCtl              192:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
BFC00058  000000C0   EHB                          193:           ehb
                                                  194:   
                                                  195:   #elif (PIC32_SRS_SET_COUNT > 2)
                                                  196:           ##################################################################
                                                  197:           # Initialize Global Pointer in Shadow Set(s)
                                                  198:           #   The SRSCtl PSS field must be set to the shadow set in which
                                                  199:           #   to initialize the global pointer.  We will initialize
                                                  200:           #   SRSCtl<PSS> to the number of reg sets and work down to set zero.
                                                  201:           #   We write the global pointer to the previous shadow set to
                                                  202:           #   ensure that on interrupt, the global pointer has been
                                                  203:           #   initialized.
                                                  204:           ##################################################################
                                                  205:           mfc0    t1,_CP0_SRSCTL          # Read SRSCtl register
                                                  206:           add     t3,t1,zero              # Save off current SRSCtl
                                                  207:   
                                                  208:           li      t2,(PIC32_SRS_SET_COUNT-1)
                                                  209:   
                                                  210:   1:      ins     t1,t2,6,4               # Put next shadow set field
                                                  211:           mtc0    t1,_CP0_SRSCTL          # into SRSCtl<PSS>
                                                  212:           ehb                             # Clear hazard before using new SRSCTL
                                                  213:           wrpgpr  gp,gp                   # Set global pointer in PSS
                                                  214:   
                                                  215:           addiu   t2,t2,-1                # Next lower shadow set
                                                  216:                                           # Loop for all sets
                                                  217:           bne     t2,$0,1b                # Down to zero (normal GPR set)
                                                  218:           nop
                                                  219:   
                                                  220:           mtc0    t3,_CP0_SRSCTL          # Restore SRSCtl
                                                  221:           ehb
                                                  222:   
                                                  223:   #endif /* (PIC32_SRS_SET_COUNT > 2) */
                                                  224:   
                                                  225:           ##################################################################
                                                  226:           # Call the "on reset" procedure
                                                  227:           ##################################################################
BFC0005C  3C089D00   LUI T0, -25344               228:           la      t0,_on_reset
BFC00064  0100F809   JALR T0                      229:           jalr    t0
BFC00068  00000000   NOP                          230:           nop
                                                  231:   
                                                  232:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  233:           ##################################################################
                                                  234:           # Initialize TLB for fixed mapping to EBI and SQI
                                                  235:           ##################################################################
                                                  236:           .extern __pic32_tlb_init_ebi_sqi
                                                  237:           la      t0,__pic32_tlb_init_ebi_sqi
                                                  238:           jalr    t0
                                                  239:           nop
                                                  240:   #endif
                                                  241:   
                                                  242:           ##################################################################
                                                  243:           # Clear uninitialized data sections
                                                  244:           ##################################################################
                                                  245:   _start_bss_init:
BFC0006C  3C08A000   LUI T0, -24576               246:           la      t0,_bss_begin
BFC00074  3C09A000   LUI T1, -24576               247:           la      t1,_bss_end
BFC0007C  10000006   BEQ ZERO, ZERO, 0xBFC00098   248:           b       _bss_check
BFC00080  00000000   NOP                          249:           nop
                                                  250:   
                                                  251:   _bss_init:
BFC00084  AD000000   SW ZERO, 0(T0)               252:           sw      zero,0x0(t0)
BFC00088  AD000004   SW ZERO, 4(T0)               253:           sw      zero,0x4(t0)
BFC0008C  AD000008   SW ZERO, 8(T0)               254:           sw      zero,0x8(t0)
BFC00090  AD00000C   SW ZERO, 12(T0)              255:           sw      zero,0xc(t0)
BFC00094  25080010   ADDIU T0, T0, 16             256:           addu    t0,16
                                                  257:   _bss_check:
BFC00098  0109082B   SLTU AT, T0, T1              258:           bltu    t0,t1,_bss_init
BFC000A0  00000000   NOP                          259:           nop
                                                  260:   
                                                  261:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  262:           ##################################################################
                                                  263:           # Initialize L1 cache. This must be done after bss clearing
                                                  264:           # since the _bss_end symbol may not be cache-line aligned.
                                                  265:           ##################################################################
                                                  266:           .extern   __pic32_init_cache
                                                  267:           la      t0,__pic32_init_cache
                                                  268:           jalr    t0
                                                  269:           nop
                                                  270:   #endif
                                                  271:   
                                                  272:   #if defined(INIT_DATA) || defined(__PIC32_HAS_INIT_DATA)
                                                  273:           ##################################################################
                                                  274:           # Initialize data using the linker-generated .dinit table
                                                  275:           ##################################################################
                                                  276:           .extern   __pic32_data_init
BFC000A4  3C089D00   LUI T0, -25344               277:           la      t0, __pic32_data_init
BFC000AC  0100F809   JALR T0                      278:           jalr    t0
BFC000B0  00000000   NOP                          279:           nop
                                                  280:   #endif /* INIT_DATA */
                                                  281:   
                                                  282:           ##################################################################
                                                  283:           # If there are no RAM functions, skip the next section --
                                                  284:           # initializing bus matrix registers.
                                                  285:           ##################################################################
BFC000B4  3C090000   LUI T1, 0                    286:           la      t1,_ramfunc_begin
BFC000BC  11200010   BEQ T1, ZERO, 0xBFC00100     287:           beqz    t1,_ramfunc_done
BFC000C0  00000000   NOP                          288:           nop
                                                  289:   
                                                  290:   #if defined(INIT_SSX) || defined(__PIC32_HAS_SSX)
                                                  291:     /* No initialization required */
                                                  292:   #else /* Use BMX */
                                                  293:           ##################################################################
                                                  294:           # Initialize bus matrix registers if RAM functions exist in the
                                                  295:           # application
                                                  296:           ##################################################################
BFC000C4  3C090001   LUI T1, 1                    297:           la      t1,_bmxdkpba_address
BFC000CC  3C0ABF88   LUI T2, -16504               298:           la      t2,BMXDKPBA
BFC000D4  AD490000   SW T1, 0(T2)                 299:           sw      t1,0(t2)
BFC000D8  3C090001   LUI T1, 1                    300:           la      t1,_bmxdudba_address
BFC000E0  3C0ABF88   LUI T2, -16504               301:           la      t2,BMXDUDBA
BFC000E8  AD490000   SW T1, 0(T2)                 302:           sw      t1,0(t2)
BFC000EC  3C090001   LUI T1, 1                    303:           la      t1,_bmxdupba_address
BFC000F4  3C0ABF88   LUI T2, -16504               304:           la      t2,BMXDUPBA
BFC000FC  AD490000   SW T1, 0(T2)                 305:           sw      t1,0(t2)
                                                  306:   #endif /* INIT_SSX */
                                                  307:   
                                                  308:   _ramfunc_done:
                                                  309:   
                                                  310:           ##################################################################
                                                  311:           # Initialize CP0 registers
                                                  312:           ##################################################################
                                                  313:           # Initialize Count register
                                                  314:           ##################################################################
BFC00100  40804800   MTC0 ZERO, Count             315:           mtc0    zero,_CP0_COUNT
                                                  316:   
                                                  317:           ##################################################################
                                                  318:           # Initialize Compare register
                                                  319:           ##################################################################
BFC00104  240AFFFF   ADDIU T2, ZERO, -1           320:           li      t2,-1
BFC00108  408A5800   MTC0 T2, Compare             321:           mtc0    t2,_CP0_COMPARE
                                                  322:   
                                                  323:           ##################################################################
                                                  324:           # Ensure BEV set and Initialize EBase register
                                                  325:           ##################################################################
BFC0010C  3C080040   LUI T0, 64                   326:           li      t0, (1<<22)
BFC00110  400A6000   MFC0 T2, Status              327:           mfc0    t2,_CP0_STATUS
BFC00114  010A5025   OR T2, T0, T2                328:           or      t2,t0,t2               # Set BEV bit 22
BFC00118  408A6000   MTC0 T2, Status              329:           mtc0    t2,_CP0_STATUS
                                                  330:   
BFC0011C  3C099FC0   LUI T1, -24640               331:           la      t1,_ebase_address
BFC00124  000000C0   EHB                          332:           ehb
BFC00128  40897801   MTC0 T1, EBase               333:           mtc0    t1,_CP0_EBASE
                                                  334:           
                                                  335:           ##################################################################
                                                  336:           # Initialize PRISS register to a safer default for devices that 
                                                  337:           # have it. The application should re-initialize it to an
                                                  338:           # application-specific value.
                                                  339:           #
                                                  340:           # We do NOT do this by default.
                                                  341:           ##################################################################
                                                  342:   #if defined(USE_DEFAULT_PRISS_VALUE) 
                                                  343:   #if defined(_PRISS_PRI7SS_POSITION)
                                                  344:   #if (PIC32_SRS_SET_COUNT >= 7)
                                                  345:           li	    t2, 0x76540000
                                                  346:           addiu	t2, t2, 0x3210
                                                  347:           lui	    t1, %hi(PRISS)
                                                  348:           sw	    t2, %lo(PRISS)(t1)
                                                  349:   #elif (PIC32_SRS_SET_COUNT <= 2)
                                                  350:           li	    t2, 0x10000000
                                                  351:           lui	    t1, %hi(PRISS)
                                                  352:           sw	    t2, %lo(PRISS)(t1)
                                                  353:   #endif /* PIC32_SRS_SET_COUNT */
                                                  354:   #endif /* _PRISS_PRI7SS_POSITION */
                                                  355:   #endif /* USE_DEFAULT_PRISS_VALUE */
                                                  356:           
                                                  357:           ##################################################################
                                                  358:           # Initialize IntCtl/INTCON.VS register with _vector_spacing
                                                  359:           ##################################################################
BFC0012C  3C090000   LUI T1, 0                    360:           la      t1,_vector_spacing
                                                  361:   #if defined(INIT_INTCONVS) || defined(__PIC32_HAS_INTCONVS)
                                                  362:           la      t0, INTCON
                                                  363:           lw      t2, 0(t0)
                                                  364:           li      t2, 0
                                                  365:           ins     t2, t1, 16, 7
                                                  366:   #if defined(__PIC32MM) && defined(_INTCON_MVEC_MASK)
                                                  367:           ori     t2, t2, _INTCON_MVEC_MASK
                                                  368:   #endif
                                                  369:           sw      t2, 0(t0)
                                                  370:   #endif
BFC00134  240A0000   ADDIU T2, ZERO, 0            371:           li      t2,0                    # Clear t2 and
BFC00138  7D2A4944   INS T2, T1, 5, 5             372:           ins     t2,t1,5,5               # shift value to VS field
BFC0013C  408A6001   MTC0 T2, IntCtl              373:           mtc0    t2,_CP0_INTCTL
                                                  374:   
                                                  375:           ##################################################################
                                                  376:           # Initialize CAUSE registers
                                                  377:           # - Enable counting of Count register <DC = 0>
                                                  378:           # - Use special exception vector <IV = 1>
                                                  379:           # - Clear pending software interrupts <IP1:IP0 = 0>
                                                  380:           ##################################################################
BFC00140  3C090080   LUI T1, 128                  381:           li      t1,0x00800000
BFC00144  40896800   MTC0 T1, Cause               382:           mtc0    t1,_CP0_CAUSE
                                                  383:   
                                                  384:           ##################################################################
                                                  385:           # Initialize STATUS register
                                                  386:           # - Access to Coprocessor 0 not allowed in user mode <CU0 = 0>
                                                  387:           # - User mode uses configured endianness <RE = 0>
                                                  388:           # - Preserve Bootstrap Exception vectors <BEV>
                                                  389:           # - Preserve soft reset <SR> and non-maskable interrupt <NMI>
                                                  390:           # - CorExtend enabled based on whether CorExtend User Defined
                                                  391:           #   Instructions have been implemented <CEE = Config<UDI>>
                                                  392:           # - Disable any pending interrupts <IM7..IM2 = 0, IM1..IM0 = 0>
                                                  393:           # - Disable hardware interrupts <IPL7:IPL2 = 0>
                                                  394:           # - Base mode is Kernel mode <UM = 0>
                                                  395:           # - Error level is normal <ERL = 0>
                                                  396:           # - Exception level is normal <EXL = 0>
                                                  397:           # - Interrupts are disabled <IE = 0>
                                                  398:           # - DSPr2 ASE is enabled for devices that support it <MX = 1>
                                                  399:           # - FPU64 is enabled for devices that support it <CU1=1> & <FR=1>
                                                  400:           ##################################################################
BFC00148  40088000   MFC0 T0, Config              401:           mfc0    t0,_CP0_CONFIG
BFC0014C  7D090580   EXT T1, T0, 22, 1            402:           ext     t1,t0,22,1              # Extract UDI from Config register
BFC00150  00094C40   SLL T1, T1, 17               403:           sll     t1,t1,17                # Move UDI to Status.CEE location
BFC00154  40086000   MFC0 T0, Status              404:           mfc0    t0,_CP0_STATUS
BFC00158  3C010058   LUI AT, 88                   405:           and     t0,t0,0x00580000        # Preserve SR, NMI, and BEV
                                                  406:   #if defined(INIT_DSPR2) || defined(__PIC32_HAS_DSPR2)
                                                  407:           li      t2, 0x01000000          # Set the Status.MX bit to enable DSP
                                                  408:           or      t0,t2,t0
                                                  409:   #endif
                                                  410:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  411:           li      t2, 0x24000000          # Set the Status.CU1 and Status.FR bits to
                                                  412:           or      t0,t2,t0                # enable the FPU in FR64 mode
                                                  413:   #endif
                                                  414:   
BFC00160  01284025   OR T0, T1, T0                415:           or      t0,t1,t0                # Include Status.CEE (from UDI)
BFC00164  40886000   MTC0 T0, Status              416:           mtc0    t0,_CP0_STATUS
                                                  417:           
                                                  418:   #if defined(PIC32WK) && defined(_CP0_CONFIG3) && defined (__mips_micromips)
                                                  419:           # Ensure that the ISAONEXEC bit is set for the microMIPS ISA for the PIC32WK family
                                                  420:           # _bsc0 (_CP0_CONFIG3, _CP0_CONFIG3_SELECT, ISAONEXEC_MASK)
                                                  421:           li      t1,0x10000              # ISAONEXEC bit
                                                  422:           mfc0    t0,_CP0_CONFIG3
                                                  423:           or      t1,t0,t1
                                                  424:           mtc0    t1,_CP0_CONFIG3
                                                  425:   
                                                  426:   #endif /* PIC32WK && __mips_micromips */
                                                  427:   
                                                  428:   #if defined(INIT_FPU64) || defined(__PIC32_HAS_FPU64)
                                                  429:                                           # FPU Control and Status
                                                  430:           li      t2,0x1000000            # FCSR: RM=0, FS=1, FO=0, FN=0
                                                  431:                                           # Enables: 0b00000 E=1, V=0, Z=0, O=0, U=0, I=0
                                                  432:           ctc1    t2, $31                 # High perf on denormal operands & tiny results
                                                  433:   #endif
BFC00168  000000C0   EHB                          434:           ehb
                                                  435:   
                                                  436:           ##################################################################
                                                  437:           # Call the "on bootstrap" procedure
                                                  438:           ##################################################################
BFC0016C  3C089D00   LUI T0, -25344               439:           la      t0,_on_bootstrap
BFC00174  0100F809   JALR T0                      440:           jalr    t0
BFC00178  00000000   NOP                          441:           nop
                                                  442:   
                                                  443:           ##################################################################
                                                  444:           # Initialize Status<BEV> for normal exception vectors
                                                  445:           ##################################################################
BFC0017C  40086000   MFC0 T0, Status              446:           mfc0    t0,_CP0_STATUS
BFC00180  3C01FFBF   LUI AT, -65                  447:           and     t0,t0,0xffbfffff        # Clear BEV
BFC0018C  40886000   MTC0 T0, Status              448:           mtc0    t0,_CP0_STATUS
                                                  449:   
                                                  450:           ##################################################################
                                                  451:           # Call main. We do this via a thunk in the text section so that
                                                  452:           # a normal jump and link can be used, enabling the startup code
                                                  453:           # to work properly whether main is written in MIPS16 or MIPS32
                                                  454:           # code. I.e., the linker will correctly adjust the JAL to JALX if
                                                  455:           # necessary
                                                  456:           ##################################################################
BFC00190  30840000   ANDI A0, A0, 0               457:           and     a0,a0,0
BFC00194  30A50000   ANDI A1, A1, 0               458:           and     a1,a1,0
BFC00198  3C089D00   LUI T0, -25344               459:           la      t0,_main_entry
BFC001A0  01000008   JR T0                        460:           jr      t0
BFC001A4  00000000   NOP                          461:           nop
                                                  462:   
                                                  463:           .end _startup
                                                  464:   
                                                  465:           ##################################################################
                                                  466:           # Boot Exception Vector Handler
                                                  467:           # Jumps to _bootstrap_exception_handler
                                                  468:           ##################################################################
                                                  469:           .section .bev_handler,code,keep
                                                  470:           .align 2
                                                  471:           .set noreorder
                                                  472:           .ent _bev_exception
                                                  473:   _bev_exception:
BFC00380  3C1A9D00   LUI K0, -25344               474:           la        k0,_bootstrap_exception_handler
BFC00388  03400008   JR K0                        475:           jr        k0
BFC0038C  00000000   NOP                          476:           nop
                                                  477:   
                                                  478:           .end _bev_exception
                                                  479:   
                                                  480:           ##################################################################
                                                  481:           # General Exception Vector Handler
                                                  482:           # Jumps to _general_exception_context
                                                  483:           ##################################################################
                                                  484:           .section .gen_handler,code
                                                  485:           .align 2
                                                  486:           .set noreorder
                                                  487:           .ent _gen_exception
                                                  488:   _gen_exception:
9FC01180  3C1A9D00   LUI K0, -25344               489:   0:      la      k0,_general_exception_context
9FC01188  03400008   JR K0                        490:           jr      k0
9FC0118C  00000000   NOP                          491:           nop
                                                  492:   
                                                  493:           .end _gen_exception
                                                  494:   
                                                  495:   #if defined(INIT_MMU_MZ_FIXED) || defined(__PIC32_HAS_MMU_MZ_FIXED)
                                                  496:           ##################################################################
                                                  497:           # Simple TLB-Refill Exception Vector
                                                  498:           # Jumps to _simple_tlb_refill_exception_context
                                                  499:           ##################################################################
                                                  500:           .section .simple_tlb_refill_vector,code,keep
                                                  501:           .align 2
                                                  502:           .set noreorder
                                                  503:           .ent simple_tlb_refill_vector
                                                  504:   simple_tlb_refill_vector:
                                                  505:           la      k0,_simple_tlb_refill_exception_context
                                                  506:           jr      k0
                                                  507:           nop
                                                  508:   
                                                  509:           .end simple_tlb_refill_vector
                                                  510:   #endif
                                                  511:   
                                                  512:   #if defined(INIT_L1_CACHE) || defined(__PIC32_HAS_L1CACHE)
                                                  513:           ##################################################################
                                                  514:           # Cache-Error Exception Vector Handler
                                                  515:           # Jumps to _cache_err_exception_context
                                                  516:           ##################################################################
                                                  517:           .section .cache_err_vector,code,keep
                                                  518:           .align 2
                                                  519:           .set noreorder
                                                  520:           .ent _cache_err_vector
                                                  521:   _cache_err_vector:
                                                  522:           la      k0,_cache_err_exception_context
                                                  523:           jr      k0
                                                  524:           nop
                                                  525:   
                                                  526:           .end _cache_err_vector
                                                  527:   #endif
                                                  528:   
                                                  529:           .section .text.main_entry,code,keep
                                                  530:           .align 2
                                                  531:           .ent _main_entry
                                                  532:   _main_entry:
                                                  533:   
                                                  534:   #if defined(CPP_INIT)
                                                  535:           .weak _init
                                                  536:           # call .init section to run constructors etc
9D0067A0  3C040000   LUI A0, 0                    537:           lui	a0,%hi(_init)
9D0067A4  27BDFFE8   ADDIU SP, SP, -24            538:           addiu	sp,sp,-24
9D0067A8  24840000   ADDIU A0, A0, 0              539:           addiu	a0,a0,%lo(_init)
9D0067AC  10800003   BEQ A0, ZERO, 0x9D0067BC     540:           beq	a0,$0,2f
9D0067B0  AFBF0014   SW RA, 20(SP)                541:           sw	$31,20(sp)	 #,
9D0067B4  0080F809   JALR A0                      542:           jalr	a0
9D0067B8  00000000   NOP                          543:           nop
                                                  544:   2:
                                                  545:   #endif
9D0067BC  30840000   ANDI A0, A0, 0               546:           and     a0,a0,0
9D0067C0  30A50000   ANDI A1, A1, 0               547:           and     a1,a1,0
                                                  548:   
                                                  549:           ##################################################################
                                                  550:   
                                                  551:           # Call main
                                                  552:           ##################################################################
9D0067C4  3C089D00   LUI T0, -25344               553:           la    	t0,main
9D0067CC  0100F809   JALR T0                      554:           jalr 	t0
9D0067D0  00000000   NOP                          555:           nop
                                                  556:   
                                                  557:   #if defined(CALL_EXIT)
                                                  558:           ##################################################################
                                                  559:           # Call exit()
                                                  560:           ##################################################################
                                                  561:           jal exit
                                                  562:           nop
                                                  563:   #endif
                                                  564:   
                                                  565:           ##################################################################
                                                  566:           # Just in case, go into infinite loop
                                                  567:           # Call a software breakpoint only with -mdebugger compiler option
                                                  568:           ##################################################################
                                                  569:           .weak __exception_handler_break
                                                  570:   __crt0_exit:
                                                  571:   1:
9D0067D4  3C029D00   LUI V0, -25344               572:           la      v0,__exception_handler_break
9D0067DC  10400003   BEQ V0, ZERO, 0x9D0067EC     573:           beq     v0,0,0f
9D0067E0  00000000   NOP                          574:           nop
9D0067E4  0040F809   JALR V0                      575:           jalr    v0
9D0067E8  00000000   NOP                          576:           nop
                                                  577:   
9D0067EC  1000FFF9   BEQ ZERO, ZERO, 0x9D0067D4   578:   0:      b       1b
9D0067F0  00000000   NOP                          579:           nop
                                                  580:   
                                                  581:           .globl __crt0_exit
                                                  582:           .end _main_entry
---  /data01/build/bamboo/xml-data/build-dir/XC32-BC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/libgcc2.c
9D004050  00C04021   ADDU T0, A2, ZERO
9D0044B4  00C04021   ADDU T0, A2, ZERO
9D004054  00804821   ADDU T1, A0, ZERO
9D0044B8  00801021   ADDU V0, A0, ZERO
9D004058  14E0003B   BNE A3, ZERO, 0x9D004148
9D00405C  00A01821   ADDU V1, A1, ZERO
9D0044BC  14E0003F   BNE A3, ZERO, 0x9D0045BC
9D0044C0  00A04821   ADDU T1, A1, ZERO
9D004060  00A6102B   SLTU V0, A1, A2
9D004064  10400048   BEQ V0, ZERO, 0x9D004188
9D004068  70C21020   CLZ V0, A2
9D0044C4  00A6182B   SLTU V1, A1, A2
9D0044C8  10600047   BEQ V1, ZERO, 0x9D0045E8
9D0044CC  70C31820   CLZ V1, A2
9D00406C  50400008   BEQL V0, ZERO, 0x9D004090
9D004070  00083402   SRL A2, T0, 16
9D0044D0  50600008   BEQL V1, ZERO, 0x9D0044F4
9D0044D4  00081C02   SRL V1, T0, 16
9D004080  00464004   SLLV T0, A2, V0
9D0044E4  00664004   SLLV T0, A2, V1
9D004074  00021823   SUBU V1, ZERO, V0
9D004078  00452804   SLLV A1, A1, V0
9D00407C  00641806   SRLV V1, A0, V1
9D004084  00651825   OR V1, V1, A1
9D0044D8  00034823   SUBU T1, ZERO, V1
9D0044DC  00652804   SLLV A1, A1, V1
9D0044E0  01244806   SRLV T1, A0, T1
9D0044E8  01254825   OR T1, T1, A1
9D004088  00444804   SLLV T1, A0, V0
9D0044EC  00641004   SLLV V0, A0, V1
9D00408C  00083402   SRL A2, T0, 16
9D004090  0066001B   DIVU V1, A2
9D004094  00C001F4   TEQ A2, ZERO
9D004098  00002010   MFHI A0
9D00409C  00005812   MFLO T3
9D0040A0  310CFFFF   ANDI T4, T0, -1
9D0040A4  00095402   SRL T2, T1, 16
9D0040A8  716C5802   MUL T3, T3, T4
9D0040AC  00042400   SLL A0, A0, 16
9D0040B0  008A5025   OR T2, A0, T2
9D0040B4  014B682B   SLTU T5, T2, T3
9D0040B8  0066001B   DIVU V1, A2
9D0040BC  00C001F4   TEQ A2, ZERO
9D0040C0  51A00009   BEQL T5, ZERO, 0x9D0040E8
9D0040C4  014B5023   SUBU T2, T2, T3
9D0040C8  01485021   ADDU T2, T2, T0
9D0040CC  0148182B   SLTU V1, T2, T0
9D0040D0  54600005   BNEL V1, ZERO, 0x9D0040E8
9D0040D4  014B5023   SUBU T2, T2, T3
9D0040D8  014B202B   SLTU A0, T2, T3
9D0040DC  01481821   ADDU V1, T2, T0
9D0040E0  0064500B   MOVN T2, V1, A0
9D0040E4  014B5023   SUBU T2, T2, T3
9D0040E8  3123FFFF   ANDI V1, T1, -1
9D0040EC  0146001B   DIVU T2, A2
9D0040F0  00C001F4   TEQ A2, ZERO
9D0040F4  00004810   MFHI T1
9D0040F8  00002012   MFLO A0
9D0040FC  708C2002   MUL A0, A0, T4
9D004100  00094C00   SLL T1, T1, 16
9D004104  01234825   OR T1, T1, V1
9D004108  0124182B   SLTU V1, T1, A0
9D00410C  0146001B   DIVU T2, A2
9D004110  00C001F4   TEQ A2, ZERO
9D004114  50600009   BEQL V1, ZERO, .LBE15
9D004118  01244823   SUBU T1, T1, A0
9D00411C  01284821   ADDU T1, T1, T0
9D004120  0128182B   SLTU V1, T1, T0
9D004124  54600005   BNEL V1, ZERO, .LBE15
9D004128  01244823   SUBU T1, T1, A0
9D00412C  0124182B   SLTU V1, T1, A0
9D004130  01284021   ADDU T0, T1, T0
9D004134  0103480B   MOVN T1, T0, V1
9D004138  01244823   SUBU T1, T1, A0
9D0044F0  00081C02   SRL V1, T0, 16
9D0044F4  0123001B   DIVU T1, V1
9D0044F8  006001F4   TEQ V1, ZERO
9D0044FC  00006010   MFHI T4
9D004500  00005812   MFLO T3
9D004504  310AFFFF   ANDI T2, T0, -1
9D004508  00022402   SRL A0, V0, 16
9D00450C  00003012   MFLO A2
9D004510  716A3802   MUL A3, T3, T2
9D004514  000C6400   SLL T4, T4, 16
9D004518  01842025   OR A0, T4, A0
9D00451C  0087602B   SLTU T4, A0, A3
9D004520  0123001B   DIVU T1, V1
9D004524  006001F4   TEQ V1, ZERO
9D004528  1180000B   BEQ T4, ZERO, 0x9D004558
9D00452C  00872823   SUBU A1, A0, A3
9D004530  00882021   ADDU A0, A0, T0
9D004534  0088282B   SLTU A1, A0, T0
9D004538  14A00006   BNE A1, ZERO, 0x9D004554
9D00453C  2566FFFF   ADDIU A2, T3, -1
9D004540  0087282B   SLTU A1, A0, A3
9D004544  10A00004   BEQ A1, ZERO, 0x9D004558
9D004548  00872823   SUBU A1, A0, A3
9D00454C  2566FFFE   ADDIU A2, T3, -2
9D004550  00882021   ADDU A0, A0, T0
9D004554  00872823   SUBU A1, A0, A3
9D004558  3042FFFF   ANDI V0, V0, -1
9D00455C  00A3001B   DIVU A1, V1
9D004560  006001F4   TEQ V1, ZERO
9D004564  00004810   MFHI T1
9D004568  00003812   MFLO A3
9D00456C  00002012   MFLO A0
9D004570  70EA5002   MUL T2, A3, T2
9D004574  00094C00   SLL T1, T1, 16
9D004578  01221025   OR V0, T1, V0
9D00457C  004A482B   SLTU T1, V0, T2
9D004580  00A3001B   DIVU A1, V1
9D004584  006001F4   TEQ V1, ZERO
9D004588  51200009   BEQL T1, ZERO, 0x9D0045B0
9D00458C  00061400   SLL V0, A2, 16
9D004590  00481021   ADDU V0, V0, T0
9D004594  0048402B   SLTU T0, V0, T0
9D004598  15000004   BNE T0, ZERO, 0x9D0045AC
9D00459C  24E4FFFF   ADDIU A0, A3, -1
9D0045A0  004A502B   SLTU T2, V0, T2
9D0045A4  24E7FFFE   ADDIU A3, A3, -2
9D0045A8  00EA200B   MOVN A0, A3, T2
9D0045AC  00061400   SLL V0, A2, 16
9D0045B0  00821025   OR V0, A0, V0
9D0045B4  03E00008   JR RA
9D0045B8  00001821   ADDU V1, ZERO, ZERO
9D004188  14C00006   BNE A2, ZERO, 0x9D0041A4
9D00418C  71021020   CLZ V0, T0
9D0045E8  14C00006   BNE A2, ZERO, 0x9D004604
9D0045EC  71031820   CLZ V1, T0
9D004190  24020001   ADDIU V0, ZERO, 1
9D004194  0046001B   DIVU V0, A2
9D004198  00C001F4   TEQ A2, ZERO
9D00419C  00004012   MFLO T0
9D0045F0  24030001   ADDIU V1, ZERO, 1
9D0045F4  0066001B   DIVU V1, A2
9D0045F8  00C001F4   TEQ A2, ZERO
9D0045FC  00004012   MFLO T0
9D0041A0  71021020   CLZ V0, T0
9D004600  71031820   CLZ V1, T0
9D0041A4  5440007D   BNEL V0, ZERO, 0x9D00439C
9D0041A8  00484004   SLLV T0, T0, V0
9D004604  5460007B   BNEL V1, ZERO, 0x9D0047F4
9D004608  00684004   SLLV T0, T0, V1
9D0041AC  00A82823   SUBU A1, A1, T0
9D0041B0  00081C02   SRL V1, T0, 16
9D0041B4  3107FFFF   ANDI A3, T0, -1
9D00460C  00A82023   SUBU A0, A1, T0
9D004610  00083C02   SRL A3, T0, 16
9D004614  310BFFFF   ANDI T3, T0, -1
9D004618  24030001   ADDIU V1, ZERO, 1
9D00439C  24090020   ADDIU T1, ZERO, 32
9D0043A0  01224823   SUBU T1, T1, V0
9D0047F4  24020020   ADDIU V0, ZERO, 32
9D0047F8  00431023   SUBU V0, V0, V1
9D0043A4  01255006   SRLV T2, A1, T1
9D0047FC  00454806   SRLV T1, A1, V0
9D0043C0  00452804   SLLV A1, A1, V0
9D0043C4  01244806   SRLV T1, A0, T1
9D0043C8  01252825   OR A1, T1, A1
9D004818  00652804   SLLV A1, A1, V1
9D00481C  00441006   SRLV V0, A0, V0
9D004820  00452825   OR A1, V0, A1
9D0043D0  00444804   SLLV T1, A0, V0
9D004828  00641004   SLLV V0, A0, V1
9D0043A8  00081C02   SRL V1, T0, 16
9D0043AC  0143001B   DIVU T2, V1
9D0043B0  006001F4   TEQ V1, ZERO
9D0043B4  00003010   MFHI A2
9D0043B8  00005812   MFLO T3
9D0043BC  3107FFFF   ANDI A3, T0, -1
9D0043CC  00056402   SRL T4, A1, 16
9D0043D4  71675802   MUL T3, T3, A3
9D0043D8  00063400   SLL A2, A2, 16
9D0043DC  01863025   OR A2, T4, A2
9D0043E0  00CB202B   SLTU A0, A2, T3
9D0043E4  0143001B   DIVU T2, V1
9D0043E8  006001F4   TEQ V1, ZERO
9D0043EC  50800006   BEQL A0, ZERO, 0x9D004408
9D0043F0  00CB3023   SUBU A2, A2, T3
9D0043F4  00C83021   ADDU A2, A2, T0
9D0043F8  00C8202B   SLTU A0, A2, T0
9D0043FC  10800024   BEQ A0, ZERO, 0x9D004490
9D004400  00CB502B   SLTU T2, A2, T3
9D004404  00CB3023   SUBU A2, A2, T3
9D004408  30AAFFFF   ANDI T2, A1, -1
9D00440C  00C3001B   DIVU A2, V1
9D004410  006001F4   TEQ V1, ZERO
9D004414  00002010   MFHI A0
9D004418  00002812   MFLO A1
9D00441C  70A72802   MUL A1, A1, A3
9D004420  00042400   SLL A0, A0, 16
9D004424  008A2025   OR A0, A0, T2
9D004428  0085502B   SLTU T2, A0, A1
9D00442C  00C3001B   DIVU A2, V1
9D004430  006001F4   TEQ V1, ZERO
9D004434  5140FF60   BEQL T2, ZERO, .LBB17
9D004438  00852823   SUBU A1, A0, A1
9D00443C  00882021   ADDU A0, A0, T0
9D004440  0088302B   SLTU A2, A0, T0
9D004444  54C0FF5C   BNEL A2, ZERO, .LBB17
9D004448  00852823   SUBU A1, A0, A1
9D00444C  0085502B   SLTU T2, A0, A1
9D004450  00883021   ADDU A2, A0, T0
9D004454  00CA200B   MOVN A0, A2, T2
9D004458  0B40106E   J .LBB17
9D00445C  00852823   SUBU A1, A0, A1
9D004490  00C82021   ADDU A0, A2, T0
9D004494  0B401101   J 0x9D004404
9D004498  008A300B   MOVN A2, A0, T2
9D004800  00083C02   SRL A3, T0, 16
9D004804  0127001B   DIVU T1, A3
9D004808  00E001F4   TEQ A3, ZERO
9D00480C  00003010   MFHI A2
9D004810  00006012   MFLO T4
9D004814  310BFFFF   ANDI T3, T0, -1
9D004824  00056C02   SRL T5, A1, 16
9D00482C  00001812   MFLO V1
9D004830  718B5002   MUL T2, T4, T3
9D004834  00063400   SLL A2, A2, 16
9D004838  01A63025   OR A2, T5, A2
9D00483C  00CA202B   SLTU A0, A2, T2
9D004840  0127001B   DIVU T1, A3
9D004844  00E001F4   TEQ A3, ZERO
9D004848  5080000B   BEQL A0, ZERO, 0x9D004878
9D00484C  00CA3023   SUBU A2, A2, T2
9D004850  00C83021   ADDU A2, A2, T0
9D004854  00C8202B   SLTU A0, A2, T0
9D004858  14800006   BNE A0, ZERO, 0x9D004874
9D00485C  2583FFFF   ADDIU V1, T4, -1
9D004860  00CA202B   SLTU A0, A2, T2
9D004864  50800004   BEQL A0, ZERO, 0x9D004878
9D004868  00CA3023   SUBU A2, A2, T2
9D00486C  2583FFFE   ADDIU V1, T4, -2
9D004870  00C83021   ADDU A2, A2, T0
9D004874  00CA3023   SUBU A2, A2, T2
9D004878  30ACFFFF   ANDI T4, A1, -1
9D00487C  00C7001B   DIVU A2, A3
9D004880  00E001F4   TEQ A3, ZERO
9D004884  00002010   MFHI A0
9D004888  00005012   MFLO T2
9D00488C  00004812   MFLO T1
9D004890  714B2802   MUL A1, T2, T3
9D004894  00042400   SLL A0, A0, 16
9D004898  008C2025   OR A0, A0, T4
9D00489C  0085602B   SLTU T4, A0, A1
9D0048A0  00C7001B   DIVU A2, A3
9D0048A4  00E001F4   TEQ A3, ZERO
9D0048A8  5180000B   BEQL T4, ZERO, 0x9D0048D8
9D0048AC  00031C00   SLL V1, V1, 16
9D0048B0  00882021   ADDU A0, A0, T0
9D0048B4  0088302B   SLTU A2, A0, T0
9D0048B8  14C00006   BNE A2, ZERO, 0x9D0048D4
9D0048BC  2549FFFF   ADDIU T1, T2, -1
9D0048C0  0085302B   SLTU A2, A0, A1
9D0048C4  50C00004   BEQL A2, ZERO, 0x9D0048D8
9D0048C8  00031C00   SLL V1, V1, 16
9D0048CC  2549FFFE   ADDIU T1, T2, -2
9D0048D0  00882021   ADDU A0, A0, T0
9D0048D4  00031C00   SLL V1, V1, 16
9D0048D8  00852023   SUBU A0, A0, A1
9D0048DC  0B401187   J .LBB16
9D0048E0  01231825   OR V1, T1, V1
9D0041B8  00092402   SRL A0, T1, 16
9D0041BC  00A3001B   DIVU A1, V1
9D0041C0  006001F4   TEQ V1, ZERO
9D0041C4  00005010   MFHI T2
9D0041C8  00003012   MFLO A2
9D0041CC  70C73002   MUL A2, A2, A3
9D0041D0  000A5400   SLL T2, T2, 16
9D0041D4  01442025   OR A0, T2, A0
9D0041D8  0086502B   SLTU T2, A0, A2
9D0041DC  00A3001B   DIVU A1, V1
9D0041E0  006001F4   TEQ V1, ZERO
9D0041E4  51400009   BEQL T2, ZERO, 0x9D00420C
9D0041E8  00862023   SUBU A0, A0, A2
9D0041EC  00882021   ADDU A0, A0, T0
9D0041F0  0088282B   SLTU A1, A0, T0
9D0041F4  54A00005   BNEL A1, ZERO, 0x9D00420C
9D0041F8  00862023   SUBU A0, A0, A2
9D0041FC  0086502B   SLTU T2, A0, A2
9D004200  00882821   ADDU A1, A0, T0
9D004204  00AA200B   MOVN A0, A1, T2
9D004208  00862023   SUBU A0, A0, A2
9D00420C  3126FFFF   ANDI A2, T1, -1
9D004210  0083001B   DIVU A0, V1
9D004214  006001F4   TEQ V1, ZERO
9D004218  00004810   MFHI T1
9D00421C  00002812   MFLO A1
9D004220  70A72802   MUL A1, A1, A3
9D004224  00094C00   SLL T1, T1, 16
9D004228  01264825   OR T1, T1, A2
9D00422C  0125302B   SLTU A2, T1, A1
9D004230  0083001B   DIVU A0, V1
9D004234  006001F4   TEQ V1, ZERO
9D004238  50C00009   BEQL A2, ZERO, .LBE17
9D00423C  01254823   SUBU T1, T1, A1
9D004240  01284821   ADDU T1, T1, T0
9D004244  0128182B   SLTU V1, T1, T0
9D004248  54600005   BNEL V1, ZERO, .LBE17
9D00424C  01254823   SUBU T1, T1, A1
9D004250  0125182B   SLTU V1, T1, A1
9D004254  01284021   ADDU T0, T1, T0
9D004258  0103480B   MOVN T1, T0, V1
9D00425C  01254823   SUBU T1, T1, A1
9D00461C  00023402   SRL A2, V0, 16
9D004620  0087001B   DIVU A0, A3
9D004624  00E001F4   TEQ A3, ZERO
9D004628  00006810   MFHI T5
9D00462C  00006012   MFLO T4
9D004630  00004812   MFLO T1
9D004634  718B5002   MUL T2, T4, T3
9D004638  000D6C00   SLL T5, T5, 16
9D00463C  01A63025   OR A2, T5, A2
9D004640  00CA682B   SLTU T5, A2, T2
9D004644  0087001B   DIVU A0, A3
9D004648  00E001F4   TEQ A3, ZERO
9D00464C  11A00009   BEQ T5, ZERO, 0x9D004674
9D004650  00CA2823   SUBU A1, A2, T2
9D004654  00C83021   ADDU A2, A2, T0
9D004658  00C8202B   SLTU A0, A2, T0
9D00465C  14800004   BNE A0, ZERO, 0x9D004670
9D004660  2589FFFF   ADDIU T1, T4, -1
9D004664  00CA202B   SLTU A0, A2, T2
9D004668  548000A6   BNEL A0, ZERO, 0x9D004904
9D00466C  2589FFFE   ADDIU T1, T4, -2
9D004670  00CA2823   SUBU A1, A2, T2
9D004674  3042FFFF   ANDI V0, V0, -1
9D004678  00A7001B   DIVU A1, A3
9D00467C  00E001F4   TEQ A3, ZERO
9D004680  00005010   MFHI T2
9D004684  00003012   MFLO A2
9D004688  00002012   MFLO A0
9D00468C  70CB5802   MUL T3, A2, T3
9D004690  000A5400   SLL T2, T2, 16
9D004694  01421025   OR V0, T2, V0
9D004698  004B502B   SLTU T2, V0, T3
9D00469C  00A7001B   DIVU A1, A3
9D0046A0  00E001F4   TEQ A3, ZERO
9D0046A4  51400009   BEQL T2, ZERO, .LBE16
9D0046A8  00091400   SLL V0, T1, 16
9D0046AC  00481021   ADDU V0, V0, T0
9D0046B0  0048402B   SLTU T0, V0, T0
9D0046B4  15000004   BNE T0, ZERO, 0x9D0046C8
9D0046B8  24C4FFFF   ADDIU A0, A2, -1
9D0046BC  004B582B   SLTU T3, V0, T3
9D0046C0  24C6FFFE   ADDIU A2, A2, -2
9D0046C4  00CB200B   MOVN A0, A2, T3
9D0046C8  00091400   SLL V0, T1, 16
9D0046CC  03E00008   JR RA
9D0046D0  00821025   OR V0, A0, V0
9D004904  0B40119C   J 0x9D004670
9D00413C  00491006   SRLV V0, T1, V0
9D004260  00491006   SRLV V0, T1, V0
9D004140  03E00008   JR RA
9D004144  00001821   ADDU V1, ZERO, ZERO
9D004264  03E00008   JR RA
9D004268  00001821   ADDU V1, ZERO, ZERO
9D004148  00A7102B   SLTU V0, A1, A3
9D00414C  14400047   BNE V0, ZERO, 0x9D00426C
9D004150  70EA5020   CLZ T2, A3
9D0045BC  00A7102B   SLTU V0, A1, A3
9D0045C0  14400044   BNE V0, ZERO, 0x9D0046D4
9D0045C4  70E84020   CLZ T0, A3
9D0046D4  00001821   ADDU V1, ZERO, ZERO
9D0046D8  03E00008   JR RA
9D0046DC  00001021   ADDU V0, ZERO, ZERO
9D00426C  00801021   ADDU V0, A0, ZERO
9D004270  03E00008   JR RA
9D004274  00A01821   ADDU V1, A1, ZERO
9D004154  15400048   BNE T2, ZERO, 0x9D004278
9D004158  240B0020   ADDIU T3, ZERO, 32
9D0045C8  55000045   BNEL T0, ZERO, 0x9D0046E0
9D0045CC  24020020   ADDIU V0, ZERO, 32
9D00415C  00E5102B   SLTU V0, A3, A1
9D004160  14400005   BNE V0, ZERO, 0x9D004178
9D004164  00861023   SUBU V0, A0, A2
9D004168  0086402B   SLTU T0, A0, A2
9D00416C  15000089   BNE T0, ZERO, 0x9D004394
9D004170  00801021   ADDU V0, A0, ZERO
9D0045D0  00E5282B   SLTU A1, A3, A1
9D0045D4  14A000C8   BNE A1, ZERO, 0x9D0048F8
9D0045D8  0086302B   SLTU A2, A0, A2
9D0045DC  38C20001   XORI V0, A2, 1
9D0045E0  03E00008   JR RA
9D0045E4  00001821   ADDU V1, ZERO, ZERO
9D0048F8  00001821   ADDU V1, ZERO, ZERO
9D004174  00861023   SUBU V0, A0, A2
9D004178  00A72823   SUBU A1, A1, A3
9D00417C  0082202B   SLTU A0, A0, V0
9D004180  03E00008   JR RA
9D004184  00A41823   SUBU V1, A1, A0
9D004278  016A5823   SUBU T3, T3, T2
9D0046E0  00481023   SUBU V0, V0, T0
9D00427C  01473804   SLLV A3, A3, T2
9D004280  01661006   SRLV V0, A2, T3
9D004284  00473825   OR A3, V0, A3
9D0046E4  01073804   SLLV A3, A3, T0
9D0046E8  00461806   SRLV V1, A2, V0
9D0046EC  00673825   OR A3, V1, A3
9D0042B4  01463004   SLLV A2, A2, T2
9D004288  01656806   SRLV T5, A1, T3
9D0046F0  00455006   SRLV T2, A1, V0
9D0042A4  01452804   SLLV A1, A1, T2
9D0042A8  01641006   SRLV V0, A0, T3
9D0042AC  00451025   OR V0, V0, A1
9D00470C  01052804   SLLV A1, A1, T0
9D004710  00441006   SRLV V0, A0, V0
9D004714  00452825   OR A1, V0, A1
9D00428C  00074C02   SRL T1, A3, 16
9D004290  01A9001B   DIVU T5, T1
9D004294  012001F4   TEQ T1, ZERO
9D004298  00006010   MFHI T4
9D00429C  00001812   MFLO V1
9D0042A0  30EEFFFF   ANDI T6, A3, -1
9D0042B0  00022C02   SRL A1, V0, 16
9D0042B8  00004012   MFLO T0
9D0042BC  706E7802   MUL T7, V1, T6
9D0042C0  000C6400   SLL T4, T4, 16
9D0042C4  01856025   OR T4, T4, A1
9D0042C8  018F282B   SLTU A1, T4, T7
9D0042CC  01A9001B   DIVU T5, T1
9D0042D0  012001F4   TEQ T1, ZERO
9D0042D4  10A0000A   BEQ A1, ZERO, 0x9D004300
9D0042D8  01442004   SLLV A0, A0, T2
9D0042DC  01876021   ADDU T4, T4, A3
9D0042E0  0187282B   SLTU A1, T4, A3
9D0042E4  14A00006   BNE A1, ZERO, 0x9D004300
9D0042E8  2468FFFF   ADDIU T0, V1, -1
9D0042EC  018F282B   SLTU A1, T4, T7
9D0042F0  50A00004   BEQL A1, ZERO, 0x9D004304
9D0042F4  018F6023   SUBU T4, T4, T7
9D0042F8  2468FFFE   ADDIU T0, V1, -2
9D0042FC  01876021   ADDU T4, T4, A3
9D004300  018F6023   SUBU T4, T4, T7
9D004304  3042FFFF   ANDI V0, V0, -1
9D004308  0189001B   DIVU T4, T1
9D00430C  012001F4   TEQ T1, ZERO
9D004310  00002810   MFHI A1
9D004314  00001812   MFLO V1
9D004318  00006812   MFLO T5
9D00431C  706E7002   MUL T6, V1, T6
9D004320  00052C00   SLL A1, A1, 16
9D004324  00A21025   OR V0, A1, V0
9D004328  004E282B   SLTU A1, V0, T6
9D00432C  0189001B   DIVU T4, T1
9D004330  012001F4   TEQ T1, ZERO
9D004334  50A00006   BEQL A1, ZERO, 0x9D004350
9D004338  00084400   SLL T0, T0, 16
9D00433C  00471021   ADDU V0, V0, A3
9D004340  0047282B   SLTU A1, V0, A3
9D004344  10A0004C   BEQ A1, ZERO, .LBE25
9D004348  246DFFFF   ADDIU T5, V1, -1
9D00434C  00084400   SLL T0, T0, 16
9D004350  01A84025   OR T0, T5, T0
9D004354  004E1023   SUBU V0, V0, T6
9D004478  004E282B   SLTU A1, V0, T6
9D00447C  50A0FFB4   BEQL A1, ZERO, 0x9D004350
9D004480  00084400   SLL T0, T0, 16
9D004484  246DFFFE   ADDIU T5, V1, -2
9D004488  0B4010D3   J 0x9D00434C
9D00448C  00471021   ADDU V0, V0, A3
9D0046F4  00071C02   SRL V1, A3, 16
9D0046F8  0143001B   DIVU T2, V1
9D0046FC  006001F4   TEQ V1, ZERO
9D004700  00004810   MFHI T1
9D004704  00006812   MFLO T5
9D004708  30EBFFFF   ANDI T3, A3, -1
9D004718  00057402   SRL T6, A1, 16
9D00471C  00001012   MFLO V0
9D004720  71AB6002   MUL T4, T5, T3
9D004724  00094C00   SLL T1, T1, 16
9D004728  012E4825   OR T1, T1, T6
9D00472C  012C702B   SLTU T6, T1, T4
9D004730  0143001B   DIVU T2, V1
9D004734  006001F4   TEQ V1, ZERO
9D004738  11C0000A   BEQ T6, ZERO, 0x9D004764
9D00473C  01063004   SLLV A2, A2, T0
9D004740  01274821   ADDU T1, T1, A3
9D004744  0127502B   SLTU T2, T1, A3
9D004748  15400006   BNE T2, ZERO, 0x9D004764
9D00474C  25A2FFFF   ADDIU V0, T5, -1
9D004750  012C502B   SLTU T2, T1, T4
9D004754  51400004   BEQL T2, ZERO, 0x9D004768
9D004758  012C4823   SUBU T1, T1, T4
9D00475C  25A2FFFE   ADDIU V0, T5, -2
9D004760  01274821   ADDU T1, T1, A3
9D004764  012C4823   SUBU T1, T1, T4
9D004768  30A5FFFF   ANDI A1, A1, -1
9D00476C  0123001B   DIVU T1, V1
9D004770  006001F4   TEQ V1, ZERO
9D004774  00006810   MFHI T5
9D004778  00006012   MFLO T4
9D00477C  00005012   MFLO T2
9D004780  718B5802   MUL T3, T4, T3
9D004784  000D6C00   SLL T5, T5, 16
9D004788  01A52825   OR A1, T5, A1
9D00478C  00AB682B   SLTU T5, A1, T3
9D004790  0123001B   DIVU T1, V1
9D004794  006001F4   TEQ V1, ZERO
9D004798  51A0000B   BEQL T5, ZERO, 0x9D0047C8
9D00479C  00021400   SLL V0, V0, 16
9D0047A0  00A72821   ADDU A1, A1, A3
9D0047A4  00A7182B   SLTU V1, A1, A3
9D0047A8  14600006   BNE V1, ZERO, 0x9D0047C4
9D0047AC  258AFFFF   ADDIU T2, T4, -1
9D0047B0  00AB182B   SLTU V1, A1, T3
9D0047B4  50600004   BEQL V1, ZERO, 0x9D0047C8
9D0047B8  00021400   SLL V0, V0, 16
9D0047BC  258AFFFE   ADDIU T2, T4, -2
9D0047C0  00A72821   ADDU A1, A1, A3
9D0047C4  00021400   SLL V0, V0, 16
9D0047C8  01421025   OR V0, T2, V0
9D0047CC  00AB2823   SUBU A1, A1, T3
9D004358  01060019   MULTU 0, T0, A2
9D00435C  00004810   MFHI T1
9D004374  00003012   MFLO A2
9D0047D0  00460019   MULTU 0, V0, A2
9D0047D4  00003810   MFHI A3
9D004360  0049182B   SLTU V1, V0, T1
9D004364  1460003E   BNE V1, ZERO, .LBB25
9D004368  00004012   MFLO T0
9D00436C  1049004B   BEQ V0, T1, 0x9D00449C
9D004370  00491823   SUBU V1, V0, T1
9D00449C  0088182B   SLTU V1, A0, T0
9D0047D8  00A7182B   SLTU V1, A1, A3
9D0047DC  14600044   BNE V1, ZERO, 0x9D0048F0
9D0047E0  00003012   MFLO A2
9D0047E4  10A7003F   BEQ A1, A3, 0x9D0048E4
9D0047E8  01042004   SLLV A0, A0, T0
9D0048E4  0086302B   SLTU A2, A0, A2
9D0048E8  10C0FFC0   BEQ A2, ZERO, 0x9D0047EC
9D0048EC  00000000   NOP
9D0047EC  03E00008   JR RA
9D0047F0  00001821   ADDU V1, ZERO, ZERO
9D0048F0  0B4011FB   J 0x9D0047EC
9D0048F4  2442FFFF   ADDIU V0, V0, -1
9D004460  01063023   SUBU A2, T0, A2
9D004464  01271823   SUBU V1, T1, A3
9D004468  0106402B   SLTU T0, T0, A2
9D00446C  00681823   SUBU V1, V1, T0
9D004470  0B4010DE   J .LBB24
9D004474  00431823   SUBU V1, V0, V1
9D004378  00863023   SUBU A2, A0, A2
9D00437C  0086202B   SLTU A0, A0, A2
9D004380  00641823   SUBU V1, V1, A0
9D004384  01631004   SLLV V0, V1, T3
9D004388  01463006   SRLV A2, A2, T2
9D00438C  00461025   OR V0, V0, A2
9D004390  01431806   SRLV V1, V1, T2
9D004394  03E00008   JR RA
9D004398  00000000   NOP
9D0048FC  03E00008   JR RA
9D004900  24020001   ADDIU V0, ZERO, 1
